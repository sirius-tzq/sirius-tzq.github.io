<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>-琅然</title>
  
  <subtitle>Levi</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-07T13:14:16.601Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Levi Tan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何开始学习一门语言,以GoLang为例</title>
    <link href="http://example.com/2023/10/07/%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80,%E4%BB%A5GoLang%E4%B8%BA%E4%BE%8B/"/>
    <id>http://example.com/2023/10/07/%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80,%E4%BB%A5GoLang%E4%B8%BA%E4%BE%8B/</id>
    <published>2023-10-07T12:47:02.000Z</published>
    <updated>2023-10-07T13:14:16.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何开始学习一门语言-以GoLang为例"><a href="#如何开始学习一门语言-以GoLang为例" class="headerlink" title="如何开始学习一门语言,以GoLang为例"></a>如何开始学习一门语言,以GoLang为例</h1><h2 id="语言层面"><a href="#语言层面" class="headerlink" title="语言层面"></a>语言层面</h2><p>在语言层面上,学习新语言的最佳方式是对照一门熟悉的语言,进行比较学习。</p><h3 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h3><table><thead><tr><th>基础特性</th><th>GO</th><th>Java</th></tr></thead><tbody><tr><td>关键字</td><td>go，type，const等</td><td>new，public，final等</td></tr><tr><td>流程控制</td><td>for-range，select，defer</td><td>while/do-while，for-each，try-catch</td></tr><tr><td>类型</td><td>静态类型（支持运行时动态），强类型<br />:=,make,var初始化类型</td><td>静态类型（支持运行时动态），强类型<br />new初始化类型</td></tr><tr><td>面向对象</td><td>非面向对象，通过结构体的组合嵌套实现”继承“，但只能继承属性</td><td>原生支持面向对象的继承、多态、封装</td></tr><tr><td>函数</td><td>函数也是一种类型，可独立依附在包中也可以通过接收器依附在结构体上<br />支持多值返回，有匿名返回值和命名返回值</td><td>只能在类中声明</td></tr><tr><td>实现接口</td><td>鸭子类型</td><td>implements</td></tr><tr><td>多态</td><td>只能通过实现接口来实现多态，仅靠结构体的组合嵌套是无法让两者有任何子父关系的</td><td>extends，implements实现多态</td></tr></tbody></table><h3 id="进阶特性"><a href="#进阶特性" class="headerlink" title="进阶特性"></a>进阶特性</h3><table><thead><tr><th>进阶特性</th><th>GO</th><th>Java</th></tr></thead><tbody><tr><td>泛型</td><td>（v1.18）支持，但泛型范围需提前约束，如`function[T int</td><td>string](t T){..}`</td></tr><tr><td>反射</td><td>TypeOf(),ValueOf()</td><td>Class&lt;?&gt;,类加载器</td></tr><tr><td>异常</td><td>error,panic<br />实现error接口即可实现自定义异常</td><td>Exception,RuntimeException<br />继承Exception,RuntimeException实现自定义异常</td></tr></tbody></table><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理也是一门语言必备特性，需要关注于如何抛出异常，如何创建异常，如何捕获异常，能否全局捕获异常</p><table><thead><tr><th>异常处理</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>创建异常</td><td>errors.New()，fmt.Errorf()</td><td>new Exception()</td></tr><tr><td>抛出异常</td><td>将error作为函数返回值返回</td><td>throw显式抛出异常,且函数带有throws</td></tr><tr><td>捕获异常</td><td>通过iferr捕获error</td><td>try-catch捕获</td></tr><tr><td>能否全局捕获异常</td><td>对于panic可以通过recover捕获</td><td>Spring提供@ControllerAdvice, AOP也能实现全局捕获</td></tr></tbody></table><h2 id="并发支持"><a href="#并发支持" class="headerlink" title="并发支持"></a>并发支持</h2><p>需要关注于如何开始并发, 线程通信,如何解决并发竞争,并发效率如何,如何控制并发,能否资源重用</p><table><thead><tr><th>并发支持</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>开启并发</td><td>通过go启动协程</td><td>Thread,Runnable,Callable; 线程池</td></tr><tr><td>通信</td><td>channel,semaphore,Context</td><td>volatile,ThreadLocal,</td></tr><tr><td>并发竞争</td><td>mutex锁, channel</td><td>CAS, synchronize, lock</td></tr><tr><td>并发控制</td><td>WaitGroup, park/unpark</td><td>线程池, wait/notify/join</td></tr><tr><td>资源重用</td><td>Pool池化技术</td><td>线程池,对象池</td></tr><tr><td>线程/协程模型</td><td>GMP</td><td>内核线程模型</td></tr></tbody></table><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>关注编程语言的编译模式，能了解其平台兼容性如何、也能通过反编译了解代码运行细节。主要关注于语言编译模式、运行模式、交叉编译</p><table><thead><tr><th>编译</th><th>GO</th><th>Java</th></tr></thead><tbody><tr><td>编译模式</td><td>编译成可执行文件<br />go build</td><td>编译成中间字节码<br />javac</td></tr><tr><td>运行模式</td><td>直接运行</td><td>通过JVM的解释器运行</td></tr><tr><td>交叉编译</td><td>不同平台需要编译出不同的编译产物<br />CGO_ENABLE=0 GOOS=linux GOARCH=amd64 go build</td><td>不同平台需要安装不同JVM，编译产物本身无视平台差异</td></tr><tr><td>编译流程</td><td>源码-语法分析/AST-类型检查(改写内建函数等)-中间代码生成-机器码生成</td><td>源码-语法分析/AST-填充符号表-注解处理-字节码</td></tr></tbody></table><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>关注IO模型，了解语言在CPU密集型程序或IO密集型程序上的优劣。主要关注于文件IO、网络IO、IO的实践方式、IO的同异步</p><table><thead><tr><th>IO</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>IO实践</td><td>文件IO、网络IO、缓冲IO等，它们都衍生自io包</td><td>BIO(IO流)、NIO(通道)</td></tr><tr><td>IO的同异步</td><td>网络IO为异步，但文件IO是同步</td><td>BIO为同步阻塞、NIO为同步非阻塞</td></tr><tr><td>文件IO</td><td>bufio、os、strings、bytes等方法包</td><td>字节流、字符流</td></tr><tr><td>网络IO</td><td>net包、Gin框架</td><td>Netty框架</td></tr></tbody></table><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>关注内存模型，可以了解语言的GC策略，以避免烂代码。主要关注于内存管理模型、GC策略</p><table><thead><tr><th>内存模型</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>内存管理</td><td>spans、bitmap、arena</td><td>方法区、堆、线程私有栈</td></tr><tr><td>内存分配</td><td>内存分配器(mcache、mcentral、mheap)</td><td>JMM</td></tr><tr><td>垃圾扫描</td><td>三色标记法+混合写屏障</td><td>分代收集算法、标记清除算法、标记整理算法、复制算法</td></tr><tr><td>GC策略</td><td>堆内存GC、定时GC、手动GC</td><td>Serial Old收集器、G1收集器等</td></tr></tbody></table><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>了解语言如何搭建一个应用程序，如何提供服务。主要关注于应用启动流程、Web应用框架，脚本编程</p><table><thead><tr><th>应用程序</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>Web应用框架</td><td>Gin、net/http包</td><td>SpringBoot</td></tr><tr><td>应用启动流程</td><td>监听端口，绑定路由</td><td>设置端口，添加过滤器，添加控制层</td></tr><tr><td>脚本编程</td><td>flag包、go build为可执行文件</td><td>\</td></tr></tbody></table><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>规范编程习惯，写出简洁清晰的代码。主要关注目录规范、代码规范、优秀脚手架</p><table><thead><tr><th>最佳实践</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>脚手架</td><td>Gin、gorm、zaplog等</td><td>Netty、Spring、JPA、mybatis</td></tr><tr><td>代码规范</td><td>Effective Go、Uber Go</td><td>阿里巴巴Java开发手册</td></tr><tr><td>目录规范</td><td><a href="https://github.com/golang-standards/project-layout/tree/master#standard-go-project-layout">Standard Go Project Layout</a></td><td>MVC模式、DDD模式</td></tr></tbody></table><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>综上能基本了解一门语言的优劣，进而了解其合适的应用场景</p><table><thead><tr><th>实用场景</th><th>Go</th><th>Java</th></tr></thead><tbody><tr><td>场景类型</td><td>高并发，分布式</td><td></td></tr><tr><td>业务倾向</td><td>云计算、中间件、区块链</td><td>嵌入式、软件应用、大数据</td></tr><tr><td>知名方案</td><td>K8s，Docker，etcd，tidb</td><td>Spring，matlab，</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何开始学习一门语言-以GoLang为例&quot;&gt;&lt;a href=&quot;#如何开始学习一门语言-以GoLang为例&quot; class=&quot;headerlink&quot; title=&quot;如何开始学习一门语言,以GoLang为例&quot;&gt;&lt;/a&gt;如何开始学习一门语言,以GoLang为例&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RPC调用过程</title>
    <link href="http://example.com/2023/09/23/RPC%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2023/09/23/RPC%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2023-09-23T09:15:46.000Z</published>
    <updated>2023-09-24T04:04:49.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h1><p>RPC五大核心组成</p><ul><li>server(provider) ：服务提供者</li><li>server-stub(provider-stub) ：服务端的本地存根。进行类型和参数转换，“翻译员”</li><li>user(consumer)：服务消费者</li><li>user-stub(consumer-stub) ：消费端的本地存根</li><li>RPCRuntime：RPC通信者。负责传输数据包，服务端/消费端均存在一个RPCRuntime，负责两边的通信<img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309231228130.png" alt="image-20230923122825047"></li></ul><p>完整的RPC中隐藏了许多细节，比方服务发现、序列化等等。RPC框架则能屏蔽这些细节，让使用者无感地调用RPC</p><h1 id="RPC框架的主要问题"><a href="#RPC框架的主要问题" class="headerlink" title="RPC框架的主要问题"></a>RPC框架的主要问题</h1><ul><li>服务发现：各服务如何互知对方地址（注册中心）</li><li>通讯协议：调用方和服务方如何通信（TCP/HTTP）</li><li>序列化：通信消息如何解压缩（文本型Json/XML；二进制型）</li><li>代理：调用方如何像调用本地API一样无感调用RPC</li></ul><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>服务可以通过固定的IP或者DNS域名解析来发现其他服务的地址，但这些除扩展性差外，对服务上下线状态也不敏感<br>注册中心的<strong>服务注册表</strong>可以记录各个微服务实例的信息，服务启动时主动将信息注册到服务中心，用于调用方查询，同时提供<strong>服务检查</strong>，如果心跳探测不到实例则会将服务移出注册表</p><p>注意，注册中心只提供服务发现功能，并不转发客户端的调用请求</p><h1 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h1><p>gRPC采用HTTP2协议，Dubbo采用TCP协议。<br>传输数据格式有文本格式如JSON、XML；也有二进制格式如JDK原生序列化。二进制方式数据包小，传输速率块，但对于<strong>异构型语言</strong>并不友好，主要因为二进制不好被反编码到其他语言。</p><p>(NOTE) 异构型语言解决方案</p><ul><li>规定各语言以相同的机制序列化,如Hession、Json</li><li>采用IDL作为标准描述语言，如Thrift、ProtoBuf</li></ul><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><ul><li>测试场景下，客户端的测试实例需要路由到特定服务实例上</li><li>流量隔离场景下，将流量隔离到不同服务实例上</li><li>灰度发布时，新服务只会接受少量的请求</li><li>路由规则由注册中心下发给客户端</li></ul><h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><p> 轮询算法：按照服务节点列表的顺序轮流发送请求<br> 随机算法：随机选取服务节点中的一个服务节点发送请求<br> 加权随机算法：按权重随机服务节点，权重大的被选中概率更大<br> 最少活跃数算法：对每个服务节点设置活跃数，每发送一个请求活跃数加1，每完成一个请求活跃数减1，服务运行一段时间后，性能相对较高的节点处理请求更快，活跃数下降得快，因此消费者只需要选择活跃数最小的节点发送请求<br> 一致性hash算法：使用hash计算，尽可能将请求均匀分配到后端服务，并且同一个用户的请求总<br>是访问到同一个服务器</p><h1 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h1><p> 服务实例在一段时间内出现故障导致响应过慢或者出现错误过多，实例就会被熔断<br> 服务中某个实例被熔断后，调用者的请求会被转发给剩余正常的实例</p><h1 id="优雅启动和优雅宕机"><a href="#优雅启动和优雅宕机" class="headerlink" title="优雅启动和优雅宕机"></a>优雅启动和优雅宕机</h1><p>在微服务架构中，服务的频繁上下线，系统的扩缩容都是常见现象，这些现象发生时应当对整个系统是无损的</p><h2 id="优雅启动"><a href="#优雅启动" class="headerlink" title="优雅启动"></a>优雅启动</h2><p>新服务完全启动后，通过Hook自动将信息发布到注册中心。新服务还不能承担全体流量。应随着时间的增加逐渐提升自身权重，最后与旧服务持平。</p><h2 id="优雅宕机"><a href="#优雅宕机" class="headerlink" title="优雅宕机"></a>优雅宕机</h2><p>宕机时先在注册中心注销，不被客户端发现。随后处理完已接受的请求，再关闭服务。期间如果有新请求则返回错误码，让客户端转发到其他客户端重试</p><h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP/1.x的性能存在问题，主要因为同一连接同一时间只能处理一个请求，其他请求的多数时间浪费在了阻塞等待上。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309231228311.png" alt="image-20230923122806232"></p><p>HTTP/1.1管道化解决了请求的阻塞问题，但队头阻塞依然存在，且返回也要按照请求顺序，否则会被阻塞。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309231227658.png" alt="image-20230923122748588"></p><p>HTTP/2以流的方式分组，能够多路复用同一个TCP连接。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309231227433.png" alt="image-20230923122737388"></p><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><p>protobuf支持多语言，在使用前通过预先定义的Schema来下序列化各种语言代码，保证传输出去的数据包格式一致。<br>protobuf工作时，先将.proto“一式两分”地转为客户端存根供客户端调用，另一个作为服务基类嵌入服务器中。此后，客户端直接调用存根即可调用启用服务，就像是调用本地API一样。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309231227374.png" alt="image-20230923122727281"></p><h2 id="RPC模式"><a href="#RPC模式" class="headerlink" title="RPC模式"></a>RPC模式</h2><ul><li>一元RPC：一次请求对应一次响应</li><li>服务端流模式：一次请求，服务器返回连续的数据流</li><li>客户端流模式：客户端源源不断发送数据流，而在发送结束后，服务端返回一个响应</li><li>双向流模式：客户端与服务端都可以向对方发送数据，实现实时交互</li></ul><h2 id="gRPC缺点"><a href="#gRPC缺点" class="headerlink" title="gRPC缺点"></a>gRPC缺点</h2><ul><li><p>不提供服务发现、负载均衡</p></li><li><p>protobuf可读性差</p></li><li><p>不支持动态Schema</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC调用过程&quot;&gt;&lt;a href=&quot;#RPC调用过程&quot; class=&quot;headerlink&quot; title=&quot;RPC调用过程&quot;&gt;&lt;/a&gt;RPC调用过程&lt;/h1&gt;&lt;p&gt;RPC五大核心组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server(provider) ：服务提供者&lt;/li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis简言</title>
    <link href="http://example.com/2023/09/14/Redis%E7%AE%80%E8%BF%B0/"/>
    <id>http://example.com/2023/09/14/Redis%E7%AE%80%E8%BF%B0/</id>
    <published>2023-09-14T12:56:24.000Z</published>
    <updated>2023-09-24T04:05:10.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简言"><a href="#Redis简言" class="headerlink" title="Redis简言"></a>Redis简言</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><pre><code class=" mermaid">graph TDA(String) --&gt; B[简单动态字符串:embstr&#x2F;raw]A --&gt; b[int]C(List) --&gt; D[双向链表]C --&gt; E[压缩列表]F(Hash) --&gt; EF --&gt; G[哈希表]H(Sorted Set) --&gt; EH --&gt; I[跳表]J(Set) --&gt; GJ --&gt; K[整数数组]</code></pre><h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>redisObject定义在redis.h中，用于表示所有类型的key，value。其中有一些重要属性</p><ol><li>type：表示数据类型，包括String、List、Hash、ZSet、Set</li><li>encoding：表示数据的编码方式，即双向链表，压缩列表，动态字符串等等</li><li>ptr：数据指针，指向数据的真实存储位置</li></ol><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String有三种编码方式:int、raw、embstr。</p><p>当value为整型时，encoding设为int,ptr指向数字的储存位置。</p><p>当value为字符串，且字符串长度不多于32字节时，encoding设为embstr，否则设为raw。ptr则都指向SDS（simple dynamic string）结构。</p><p>SDS结构包含三个属性：buf[]为字符组，free表示buf还未利用的空间大小，len表示字符串长度</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><a href="https://zhuanlan.zhihu.com/p/166549206">哈希表</a></h4><p>Hash的底层储存结构主要是字典dict,该结构包含两个重要属性:ht,rehashidx标志渐进式rehash的进度。其中ht由两个dictht类型数组构成，其中一个是数据的储存位置，一个用于rehash。</p><p><img src="https://pic2.zhimg.com/v2-dd8e346e267fd00c6e8d47f32d15ce1d_r.jpg" alt="字典结构"></p><p>dictht结构的几个重要属性：table：储存键值对dictEntry的数组，size：数组table的长度，sizemask：等于size-1，用于hash寻址，used：表示已有的dictEntry数量</p><p>dictEntry结构的几个重要属性：key为HKey，v为HValue，next指向下一dictEntry</p><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>redis通过链地址法解决Hash冲突，但冲突率过高就需要进行扩容，要扩容就要对所有节点rehash。可以试想，如果在一个dictht上rehash，该dictht在rehash过程中是不可用的。这也就是为什么会有第二个dictht，在第一个dictht的节点rehash到第二个dictht的过程中，redis依然是可以对外提供服务的，这也就是渐进式rehash。而rehashidx就是用来指示当前rehash到了哪个下标。</p><p>扩容时，ht[1].size会设定为N(2*ht[0].size &lt;= N &lt;= 2^n^，n尽可能取最小值)，扩容过程中遍历所有节点并逐渐迁移到ht[1].table中</p><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>压缩列表是一段完整连续的内存块</p><p><img src="https://pic1.zhimg.com/80/v2-8fd5104994d92443af483d747d631390_720w.webp" alt="ziplist"></p><ol><li><code>zlbytes</code>：4个字节的大小，记录压缩列表占用内存的字节数。</li><li><code>zltail</code>：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。</li><li><code>zllen</code>：2个字节的大小，记录压缩列表中的节点数。</li><li><code>entry</code>：表示列表中的每一个节点。<ol><li><code>previous_entry_ength</code>表示前一个节点entry的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的。</li><li><code>encoding</code>：这里保存的是content的内容类型和长度。</li><li><code>content</code>：content保存的是每一个节点的内容。</li></ol></li><li><code>zlend</code>：表示压缩列表的特殊结束符号<code>&#39;0xFF&#39;</code></li></ol><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List底层除了使用压缩列表实现，也可以通过双向链表实现。</p><p><img src="https://pic1.zhimg.com/80/v2-102238a40860c08faf37c492f61f6d94_720w.webp" alt="linkedlist"></p><p>因为List双向链表的pop/push特性，所以List可用作是实现阻塞队列</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set可以通过哈希表实现，区别于Hash，Set只是不解决哈希冲突问题。此外当集合的元素数量不多时，Set会通过整数数组实现</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d652474acd9a4e068c791fcd0544db98~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="intset"></p><p>其中三个属性值<code>encoding、length、contents[]</code>，分别表示编码方式、整数集合的长度、以及元素内容</p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a><a href="https://zhuanlan.zhihu.com/p/386473631">Zset</a></h3><p>当Zset中节点数量过多或节点过大时，Zset底部会由压缩表转换为跳表。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309142054924.png" alt="image-20230914205407453"></p><p>skipList本质是多层链表,只是每个高层节点都有一个指向正下方底层节点的指针。</p><p>插入节点时，会随机选取一个层级LayerN（从第1层到第32层的概率逐级递减，选取第一层有50%的概率）。该节点顺序插入到LayerN的链表中后，又会复制一份插入到LayerN-1的链表中，如此操作直到Lyaer1的链表也有该节点。</p><p>据此，我们可以知道跳表的一些基本特性：</p><ol><li>跳表的最底层拥有所有节点</li><li>节点插入跳表后，从选取的层级开始，直到最底层都有该节点的副本。且上层节点有个指向下层节点的指针。</li><li>每层的链表是一个<strong>双向链表</strong></li></ol><p>查询score=5.5的节点</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309142054821.png" alt="image-20230914205421766"></p><p>最后在底层的5和6之间发现5.5不存在。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>当从节点首次加入集群或发生主从切换时，触发全量复制：</p><pre><code class=" mermaid">sequenceDiagram从节点 -&gt;&gt;主节点: psync ? -1主节点 -&gt;&gt;从节点: FULLRESYNC offsetNote right of 主节点: bgsave生成RDB主节点 -&gt;&gt;从节点: 发送RDBNote right of 主节点: 继续接受命令并写入bufferBNote left of 从节点: 加载RDB主节点 -&gt;&gt;从节点: 发送bufferNote left of 从节点: 加载buffer</code></pre><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>当主从断开重连或主节点同步时,触发增量复制</p><pre><code class=" mermaid">sequenceDiagram从节点 -&gt;&gt;主节点: 重连从节点 -&gt;&gt;主节点: psync ID offset主节点 -&gt;&gt;从节点: 从offset到最新数据的差值Note right of 主节点: 继续接受命令并写入buffer主节点 -&gt;&gt;从节点: 发送bufferNote left of 从节点: 加载buffer</code></pre><h3 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h3><p>Redis通过Hash分片将请求均匀地打到各个节点上，Hash = CRC16(Key)%2^14^。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>当集群扩缩容后，各节点的位置都有可能有变化。这样客户端的请求就可能无法打到正确节点上，因此Redis节点在接受命令后先校验自身是否为目标节点，如果不是，则返回moved命令，指导客户端重定向到正确节点上。</p><h3 id="哨兵分布式投票"><a href="#哨兵分布式投票" class="headerlink" title="哨兵分布式投票"></a>哨兵分布式投票</h3><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>save会阻塞当前Redis服务器，直到RDB生成。bgsave则是fork一个子进程来生成RDB文件，只有在fork的过程中会阻塞Redis服务器一段时间。</p><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><ol><li>save m n：m秒中发生n次修改，自动触发bgsave</li><li>全量同步时触发bgsave</li><li>执行shutdown时，如果没有开启AOF则会触发bgsave</li></ol><h3 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h3><p>bgsave执行的是cow(copy and write)流程，表面意义就是Redis将所有数据生成一份快照，子进程根据快照生成RDB，主进程则继续对外服务。但显然，Redis不会这么做，因为这会直接将可用内存削减掉一半。</p><p>Redis创建子进程后，不会进行copy，主进程和子进程共享数据。但是主进程会将所有内存页权限设置为read-only，当主进程尝试修改某一内存页时，会触发页异常中断。之后该页生成一份快照供子进程使用，解除限制的内存页就继续对外服务。这样，在理想状态下，如果主进程没有写操作，整个bgsave都不会产生额外内存开销。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>写操作命令会追加到aof_buf缓冲区中，之后根据appendfsync策略决定何时将缓冲区写到AOF中</p><p>可以预想到，如果不做控制，AOF的体积会不断膨大。为此，Redis可以通过AOF重写将AOF中的命令压缩，以做到命令更少，但结果一致。</p><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>在aof文件重写时，fork一个子进程将内存数据以RDB二进制格式写入AOF头部，重写后执行的redis命令，会以aof持久化的方式追加到aof文件尾部。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis事务本质是将一组命令顺序排列，保证一次性执行完命令组。MULTI开启事务，EXEC结束事务并执行命令组。Redis事务相比于MySQL事务，不会进行回滚。</p><p>Redis不支持分布式事务，即事务中的所有命令都必须在同一节点上执行，否则事务丢失。Redis提供了Hash Tag作为Sharding Key，以保证带有同一Hash Tag的命令都会被分到同一slot中，如<code>set &#123;tag&#125;key value</code></p><p>Redis并非完全不支持事务回滚，在事务开启前执行WATCH Key，如果事务过程中Key被修改，则回滚所有操作。</p><h1 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>为尽量保证缓存与数据库的数据是一致的，业内多采用延迟双删。修改数据库前删除缓存，修改成功后再次尝试删除缓存。</p><h2 id="TTL设计"><a href="#TTL设计" class="headerlink" title="TTL设计"></a>TTL设计</h2><p>缓存最好都设置过期时间，以免冷数据长期占用内存空间。TTL过小会影响缓存命中率，TTL过大则会不必要地占用内存。如何在命中率和内存占用中权衡，有下经验：</p><p>递增式设置不同TTL，统计TTL内请求的用户量，请求总量。通过公式 $$ 命中率 = 1-  \frac{TTL内请求的用户量}{TTL内请求总量}$$ 计算命中率，随后设计缓存类型是String还是Hash，在<a href="http://www.redis.cn/redis_memory/">Redis内存估计</a>中预算出TTL内缓存的内存占用量，其中Key个数约等于TTL内请求的用户量。</p><table><thead><tr><th>时间</th><th>10s</th><th>30s</th><th>1min</th><th>10min</th><th>20min</th><th>30min</th></tr></thead><tbody><tr><td>设备数量</td><td>31296</td><td>35139</td><td>35261</td><td>37013</td><td>38523</td><td>38505</td></tr><tr><td>请求总数</td><td>31378</td><td>93770</td><td>187632</td><td>1878392</td><td>3755227</td><td>5631076</td></tr><tr><td>命中率（%）</td><td>0.26</td><td>62.5</td><td>81.21</td><td>98.03</td><td>98.97</td><td>99.32</td></tr><tr><td>内存估计（M）</td><td>5.16</td><td>5.79</td><td>5.81</td><td>6.10</td><td>6.35</td><td>6.35</td></tr></tbody></table><p>列出数据后，比对可发现合适的TTL。</p><p>但注意，需要一些额外设计：</p><ol><li>所有缓存设置同一TTL会引发缓存雪崩，为避免这一现象，应该在TTL基础上随机加盐。以上表为例，TTL设定在10min±3min比较合适</li><li>对于数据库中不存在的数据，应该在缓存中回写空值，以避免缓存穿透。对于不合理的请求，比如主键为负值，缓存就应该直接拒绝，以避免缓存穿透（<strong>布隆过滤器实现</strong>）</li><li>对于写多读少的场景，Redis持久化可以选择AOF或混合持久化；否则，RDB会更为合适</li></ol><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器由n个无偏Hash函数和二进制数组组成。某一Key在添加到过滤器的时候，会先通过n个无偏Hash函数获得n个hash值，这n个值落在二进制数组上就将该值改为1。如果需要查询某Key原先是否已存在，只需将该Key在二进制数组落点上的所有值进行与运算，结果为0则表示该Key不存在，但结果为1并不意味着一定存在，因为那些为1的落点有可能是其他Key落下的。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309142054756.png" alt="image-20230914205449687"></p><p>二进制数组越长，Hash函数越多就越容易减小Key3这种情况的概率。但这也会带来性能损耗，如何权衡便是一个问题，<a href="https://krisives.github.io/bloom-calculator/">Bloom Filter Calculator</a>能帮忙计算合适的数组长度和Hash数量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis简言&quot;&gt;&lt;a href=&quot;#Redis简言&quot; class=&quot;headerlink&quot; title=&quot;Redis简言&quot;&gt;&lt;/a&gt;Redis简言&lt;/h1&gt;&lt;h2 id=&quot;底层数据结构&quot;&gt;&lt;a href=&quot;#底层数据结构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2023/09/13/MySQL/"/>
    <id>http://example.com/2023/09/13/MySQL/</id>
    <published>2023-09-13T15:11:54.000Z</published>
    <updated>2023-09-13T15:11:56.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL简言"><a href="#MySQL简言" class="headerlink" title="MySQL简言"></a>MySQL简言</h1><h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">6</span>) <span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>] col1, col2, agg_func(col3) <span class="hljs-keyword">AS</span> alias<br>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">JOIN</span> t2<br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">ON</span> (join_conditions)<br>(<span class="hljs-number">3</span>) <span class="hljs-keyword">WHERE</span> where_conditions<br>(<span class="hljs-number">4</span>) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> col1, col2<br>(<span class="hljs-number">5</span>) <span class="hljs-keyword">HAVING</span> having_condition<br>(<span class="hljs-number">7</span>) <span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>]<br>    ...<br>(<span class="hljs-number">8</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col1 <span class="hljs-keyword">ASC</span>,col2 <span class="hljs-keyword">DESC</span><br>(<span class="hljs-number">9</span>) <span class="hljs-keyword">OFFSET</span> m <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">FETCH</span> NEXT num_rows <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>;<br></code></pre></td></tr></table></figure><h2 id="储存引擎"><a href="#储存引擎" class="headerlink" title="储存引擎"></a>储存引擎</h2><p>MySQl5.5后默认使用InnoDB引擎，与此前的MyISAM相比，InnoDB支持事务，行锁，间隙锁，MVCC，外键；索引也采用聚簇索引</p><h3 id="BufferPool"><a href="#BufferPool" class="headerlink" title="BufferPool"></a>BufferPool</h3><p>为提升读写性能，InnoDB不会直接读写磁盘而是引入BufferPool。</p><p>BufferPool基本思路</p><ol><li>减少磁盘IO次数：读先读缓存，写先写redo log再批量刷脏</li><li>IO合并为顺序IO：多次写操作合并后再顺序执行，将随机IO变为顺序IO，这能减少磁盘寻址的时间</li></ol><h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><p>checkpoint是在redo log中指示脏数据（留在bufferpool未刷入盘的数据）位置的指针，根据种类，checkpoint会按照指定策略刷脏。</p><h3 id="改进型LRU"><a href="#改进型LRU" class="headerlink" title="改进型LRU"></a><a href="https://zhuanlan.zhihu.com/p/142087506">改进型LRU</a></h3><p>实际上，MySQL 确实没有直接使用 LRU 算法，而是在 LRU 算法上进行了优化。这是因为全表扫描和预读机制中，MySQL的一次读取都可能带着很多其他数据页，这就可能把不久前刚读出来的数据页挤占出去。</p><p>改进型LRU则相当于冷热分离，其相比于LRU，新元素不从头部插入，而是从中间位插入。该中间位将LRU队列分为了old区和young区。新数据如果在1s（由<code>innodb_old_blocks_time</code>控制）内被访问就会晋升到young区，如果需要淘汰数据页也只会从old区淘汰。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309132143862.png" alt="image-20230913214357685"></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><table><thead><tr><th></th><th>bin-log</th><th>redo-log</th><th>undo-log</th></tr></thead><tbody><tr><td>生成</td><td>MySQL Server</td><td>InnoDB</td><td>InnoDB</td></tr><tr><td>作用</td><td>主从复制/数据恢复</td><td>崩溃恢复</td><td>MVCC/事务回滚</td></tr><tr><td>类型</td><td>逻辑日志</td><td>物理日志</td><td>逻辑日志</td></tr></tbody></table><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主节点的数据变更先记录在bin-log上，从节点的IO进程会主动向主节点的Log-Dump线程拉取bin-log的更新内容，拉取后从节点记录到自己的relay log中。从节点还有SQL进程，用于读取relay log并执行语句，进而实现主从同步。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309132144353.png" alt="image-20230913214418283"></p><p>主从复制有三种模式:</p><ol><li>异步模式：master提交事务后立刻返回结果给客户端，不关心slave是否已经接收到binlog并处理</li><li>半同步模式：master提交事务后需等待至少一个slave接收到bin log并写到relay log才返回成功</li><li>全同步模式：master提交事务后必须等待所有的slave都接收到bin log并写道relay log后才能返回成功</li></ol><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>InnoDB的索引结构为B+树，相比于B树有以下优势：</p><ol><li>B+树只有叶子节点储存数据：B+树的非叶子节点体积要更小，而树的每一层占用一页，这导致一页能储存更多的节点，B+树整体会更为矮壮。那么高度越低，检索的时间复杂度也越低。</li><li>B+树叶子节点以双向链表连接：叶子节点可互相访问，这样范围查询的效率更高</li></ol><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引是一颗B+树，叶子节点储存索引列的数据。InnoDB会根据每张表的主键构造主键索引，索引的叶子节点存放的是完整的数据行。非主键上构建的索引称为辅助索引，辅助索引的叶子节点就只储存了数据行在索引列上的数据，以及数据行在主键索引的位置。</p><p>而非聚簇索引的主键索引和辅助索引结构一致，也都是B+树。叶子节点不储存数据，数据储存在独立的地方，而叶子节点储存一个指向真正数据的地址。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309132144126.png" alt="image-20230913214436030"></p><h2 id="索引覆盖与回表"><a href="#索引覆盖与回表" class="headerlink" title="索引覆盖与回表"></a>索引覆盖与回表</h2><p>InnoDB的辅助索引的叶子节点只有索引列的数据，如果查询的SELECT列包含在了索引列中，本次查询就只需要经历一次辅助索引，称之为索引覆盖。否则，SELECT中额外的列需要回到主键索引中继续查询，该过程称为回表。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>在遍历索引的时候，先查询索引包含的字段，过滤掉不符合条件的记录，减少回表次数。</p><h2 id="页"><a href="#页" class="headerlink" title="页"></a><a href="https://www.cnblogs.com/fenglianchen/p/10013520.html">页</a></h2><p>MySQL与磁盘交互的最小单位为页，页默认为16KB，页内储存着不定量的数据行。页内的数据行是根据主键升序排列的，因此如果插入了一个随机主键的数据，为保证有序性，页内数据就会迁移到合适位置，进而可能导致页分裂。其中涉及到的数据重排、新页申请都会影响插入效率。</p><p>MySQL查询主要流程：</p><ol><li>查询数据时，先通过索引定位到数据所在的页，</li><li>然后将页内整体加载到缓存中，</li><li>通过二分法在页中检索数据，定位数据到某两个slot之间</li><li>最后从start slot 指向的记录向后查找，直到查到数据或者end slot的最后一条记录。</li></ol><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p>对于联合索引(a,b,c)，MySQL会从左至右依次匹配查询列，直至遇到范围查询。对于WHERE a=1 and b&gt;2 and c=3，ab会利用上索引，c则不会。</p><h2 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h2><p>除了不符合最左匹配原则，有些场景会直接导致索引失效。</p><ol><li>WHERE a+1=2 | WHERE a=‘1’ | WHERE a != 1 | WHERE a is not null | WHERE a like ‘%a’</li><li>or查询中，有一个条件的索引失效都会导致整个查询的索引失效</li></ol><h2 id="高效利用索引"><a href="#高效利用索引" class="headerlink" title="高效利用索引"></a>高效利用索引</h2><ol><li>高频查询的，内容简短的、区分度高的字段适合建立索引，更新频率高的字段不适合做索引</li><li>WHERE语句遵循最左匹配原则，SELECT要尽量是索引覆盖，覆盖不了也要保证索引下推</li><li>避免索引失效场景</li></ol><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol><li><p>事务的原子性是通过 undo log 来实现的</p></li><li><p>事务的持久性是通过 redo log 来实现</p></li><li><p>事务的隔离性是通过 (读写锁+MVCC)来实现，读写锁解决写写冲突，MVCC解决读写冲突</p></li><li><p>事务的一致性是通过 原子性、持久性和隔离性 来实现</p></li></ol><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><a href="https://zhuanlan.zhihu.com/p/408175328">持久性</a></h2><p>MySQL的数据修改会先记录在redo log上，redo log再根据刷盘策略持久化到磁盘上。此外，InnoDB存储引擎有一个后台线程，每隔<code>1</code>秒，就会把redo log buffer中的内容写到文件系统缓存（page cache），然后调用fsync刷盘。</p><h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的<code>redo log</code>日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。组件组将多个redo log环形排列，write pos标记当前记录位置，记录新数据则后移；checkpoint标记脏数据的开始位置，刷脏时后移</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309132144549.png" alt="image-20230913214455498"></p><p>当write pos追上checkpoint就必须刷脏了。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>当事务对数据进行修改时，undo log会记录修改的反向操作。当事务需要回滚时便可以利用undo log恢复到原状态。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>并发事务会存在脏读、不可重复读、幻读的问题，MySQL提供的读已提交、可重复读、可串行化隔离级别能够依次解决以上问题。</p><h3 id="锁实现"><a href="#锁实现" class="headerlink" title="锁实现"></a>锁实现</h3><p>读已提交：读操作不添加锁，写操作要求排它锁X</p><p>可重复读：读操作要求共享锁，读完就释放，写操作要求排它锁</p><p>可串行化：读操作要求共享锁，事务结束才释放，写操作要求排它锁</p><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>排它锁和共享锁并不能完全解决幻读问题，如果读操作是范围查询，就需要间隙锁将整个范围都锁住，共享锁只能锁住一行。</p><p>间隙锁有Gap Lock和Next-key Lock，Next-key Lock比起Gap Lock多锁住了记录行。</p><h3 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a>MVCC实现</h3><p>MVCC通过版本控制来实现不加锁而达到读写分离的效果。InnoDB为每一行记录都创建了两个隐藏列，分别记录了行的创建版本和行的删除版本。Undo log中记录了数据行的版本变更，这样每一行都会有历史可追溯。</p><p>此外Read View用来屏蔽高于Read View版本的数据变更，这样如果要解决脏读，读事务会在每次读操作前更新Read View，保证每次读的都是最新版本的数据。如果要解决不可重复读，读事务只会在事务开始时生成Read View，保证读到的都是同一版本。</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="数据库瓶颈"><a href="#数据库瓶颈" class="headerlink" title="数据库瓶颈"></a>数据库瓶颈</h2><h3 id="IO瓶颈"><a href="#IO瓶颈" class="headerlink" title="IO瓶颈"></a>IO瓶颈</h3><p>磁盘IO: 如果热点数据过多，数据库缓存被占满，每次查询会产生大量IO进而降低查询速度。此时可采用<strong>分库或垂直分表</strong></p><p>网络IO：请求数据过多，网络带宽不足。此时可采用<strong>分库</strong></p><h3 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h3><p>SQL：SQL查询包含了耗时操作如join、group by、索引不当等会增加CPU运算压力。此时多为优化表结构、SQL语句或是业务简化</p><p>单表数据过大：查询时扫描的行过多。此时可采用<strong>水平分表</strong></p><h2 id="分库分表策略"><a href="#分库分表策略" class="headerlink" title="分库分表策略"></a>分库分表策略</h2><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>以字段为依据，按照一定策略（Hash、Range、Tag等）将数据引流到不同库中。<strong>分库的库结构一样、库中数据不重复、所有库的数据的并集是全量数据。</strong></p><p>水平分库在面对高并发量的场景能很好缓解IO和CPU压力</p><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>以字段为依据，按照一定策略将数据引流到不同表中。</p><p>相比于水平分库，水平分表适用于并发量不高但单表数据过于庞大的情况。</p><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>以表为依据，按照业务归属不同，将数据引流至对应的库中。</p><p>垂直分库是以服务化的思想来看待，库与库之间的数据不具有相关性，每个库应该服务于单个或多个强相关的服务</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>以字段为依据，按照字段的活跃程度分离出热表（主表）和冷表（扩展表）。一般来说，冷热表应至少有一列交集，用于关联数据。</p><p>垂直分表适用于并发量不高，但表字段很多，且有明显的热点数据和非热点数据区别，单行数据的储存空间较大。</p><h2 id="非Sharding-Key查询"><a href="#非Sharding-Key查询" class="headerlink" title="非Sharding Key查询"></a>非Sharding Key查询</h2><p>分片依据（Sharding Key）要求选择查询频率高，长度简短的列。当查询时不带Sharding Key，则需要想办法引入Sharding Key用于寻找表的位置。</p><h3 id="映射法"><a href="#映射法" class="headerlink" title="映射法"></a>映射法</h3><p>另建查询列和Sharding Key的映射表，查询前先找到Sharding Key再定位到具体表</p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309132145425.png" alt="image-20230913214516343" style="zoom:67%;" /><h3 id="基因法"><a href="#基因法" class="headerlink" title="基因法"></a>基因法</h3><p>查询列经过转化生成一串基因,取出后x位(x取决于分布式数据库个数),将其代替掉分布式ID的后x位,得到的就是Sharding Key.</p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309132145225.png" alt="image-20230913214542136" style="zoom:67%;" /><h2 id="分库分表问题"><a href="#分库分表问题" class="headerlink" title="分库分表问题"></a>分库分表问题</h2><ol><li>事务一致性问题，解决方案有：<br>• 分布式事务</li><li>跨库join查询，解决方案有：<br>• 表冗余，全局表<br>• 字段冗余<br>• ER分片，有关联关系的表放同一个分片上，能有效避免跨分片join的问题<br>• 业务层分两次查询然后组装（常用）</li><li>跨节点分页、排序、函数问题，解决方案有：<br>• 将不同分片的结果集进行汇总和再排序</li><li>全局主键避重问题，解决方案有：<br>• 分布式id，比如雪花算法、基于数据库实现的号段模式等。</li><li>数据迁移、扩容问题，解决方案有：<br>• 迁移历史数据、容量规划<br>• Range + Hash取模 分组法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL简言&quot;&gt;&lt;a href=&quot;#MySQL简言&quot; class=&quot;headerlink&quot; title=&quot;MySQL简言&quot;&gt;&lt;/a&gt;MySQL简言&lt;/h1&gt;&lt;h2 id=&quot;SQL执行顺序&quot;&gt;&lt;a href=&quot;#SQL执行顺序&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GoLang&amp;Java</title>
    <link href="http://example.com/2023/09/09/GoLang-Java/"/>
    <id>http://example.com/2023/09/09/GoLang-Java/</id>
    <published>2023-09-09T06:05:43.000Z</published>
    <updated>2023-09-09T06:06:06.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang与Java"><a href="#Golang与Java" class="headerlink" title="Golang与Java"></a>Golang与Java</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table><thead><tr><th>对比项</th><th>Java</th><th>Golang</th><th></th></tr></thead><tbody><tr><td>实现跨平台</td><td>通过JVM支持</td><td>能直接在目标平台编译执行</td><td></td></tr><tr><td>内存管理</td><td>1. 运行期间依托JVM进行内存管理<br />2.配置繁杂<br />3.启动所需内存大,速度慢</td><td>1.配置简单<br />2.启动所需内存少,速度快</td><td>Java的GC更为成熟</td></tr><tr><td>并发</td><td>支持多线程级别,本质是更高效地利用系统线程. Java19开始支持虚拟线程<br />1.线程池<br />2.volatile、atomic<br />3.锁：sychronized、CAS<br />4.ThreadLocal</td><td>支持用户级线程：协程<br />1. channel实现协程通信</td><td></td></tr><tr><td>面向对象</td><td>1.原生支持继承、多态、封装<br />2.类是对象的表现形式</td><td>1.非面向对象，通过结构体的嵌套和“鸭子类型”来实现继承的思想<br />2.结构体是“对象”的表现形式<br />3.Optional模式可以实现Java重载的效果</td><td></td></tr><tr><td>异常处理</td><td>1.有全局异常处理机制，捕获Exception与Error<br />2.try_catch可用于内部消化异常或重包装异常<br />3.throw主动抛出异常,此时必须由catch捕获处理或throws抛到函数外面,但throw RuntimeException无需这么处理</td><td>1.recover可以全局部捕获panic<br />2.Errors.New()新建异常,不能内部消耗就只能将error作为函数返回值<br />3.iferr是常见的消化异常</td><td>因为Go没有全局异常处理机制,如果想扔到外部消化而调用链较长,代码就会出现非常多的iferr</td></tr><tr><td>数据结构</td><td>1.八大基本数据类型<br />2.每个数据类型都有对应的封装类,用于提供更多的数据操作</td><td>1.原生支持map,slice,list</td><td>Java的数据类型更为丰富,有如各类HashMap、LinkedList、Stack</td></tr><tr><td>反射</td><td>1.<a href="https://zhuanlan.zhihu.com/p/405325823">可以在运行时动态加载实例的具体类</a><br />2.Class对象再内存空间是唯一的，通过ClassName便可以反射出一些Class基本信息<br />3.面对声明类型为父类的实例，通过反射可以了解到实际类型<br />4.Class.getField().set()操作属性</td><td>1.<a href="https://zhuanlan.zhihu.com/p/411313885">TypeOf()获取实际类型(Type)的基本信息,包括成员名,类型名</a><br />2.ValueOf()获取实际值(Value)</td><td></td></tr><tr><td>泛型</td><td>1.泛型类ClassName&lt;[T,E,K,V]&gt;,实例化时必须指明具体类型,但不能是基本数据类型<br />2.泛型方法<T> T function(T t),使用时传入的类型也就是返回的类型</td><td>1.泛型方法 fuction(t T) T, 使用时需要指明T类型<code>function[T=int](t)</code><br />2.泛型结构type StructName[T int|float32|float64] struct,使用时选择类型StructName[int]{…}</td><td></td></tr><tr><td>特有语法</td><td>1.注解支持<br />2.继承,多态,重载覆写<br />3.static静态属性,静态块<br />4.异常处理</td><td>1.函数多值返回,也可以自由选择接受那些返回值<br />2.指针<br />3.函数也是一种类型,可以作为参数或返回值<br />4.defer延迟执行<br />5.协程与channel</td><td></td></tr></tbody></table><h2 id="如何实现继承"><a href="#如何实现继承" class="headerlink" title="如何实现继承"></a>如何实现继承</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>java实现通过extends或implements实现继承,子类可以像父类一样使用其所有变量和方法，当继承一个接口时，编译器会强制检查继承者是否实现了所有抽象方法。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>Golang以“鸭子类型”的方式实现“继承”，即我拥有你的所有变量和方法，我即是你。因而，Golang在结构体A中直接嵌入另一结构体类型B，在编译器看来A既可以是A也可以是B，实际类型依然是A。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;<br>    Person<br>    StudentID <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> s Person = Student&#123;&#125;<br></code></pre></td></tr></table></figure><p>当类型B是一个接口类型时，编译器理所当然的认为A也是B类型，A使用接口方法时编译器也不会检查A是否实现了接口方法，直到程序运行到该处才会报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span>&#123;<br>    write() <span class="hljs-keyword">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;<br>    Writer<br>    StudentID <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">var</span> w Writer = &amp;Student&#123;&#125;<br>w.write() <span class="hljs-comment">//runtime error: invalid memory address or nil pointer dereference</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Student)</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//只有Student实现该接口方法,运行时才不会报错</span><br></code></pre></td></tr></table></figure><p>当然,A可以不嵌入B接口,如果实现了B的所有接口方法,编译器也会认为A是B类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span>&#123;<br>    write() <span class="hljs-keyword">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;<br>    StudentID <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Student)</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>但这也带来一个问题，编译器不会判断A是否实现了所有接口方法，写代码的时候就可能遗漏。为了让编译器强制检查A是否实现所有接口方法，可以通过类型强转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ Writer = (*Student)(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><h2 id="控制范围"><a href="#控制范围" class="headerlink" title="控制范围"></a>控制范围</h2><h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h3><p>Java控制范围以Class和Package为单元, private,default,protected,public严格控制了访问范围</p><table><thead><tr><th align="left"></th><th align="left">类内部</th><th align="left">本包</th><th align="left">子类</th><th>外部包</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">√</td><td align="left">√</td><td align="left">√</td><td>√</td></tr><tr><td align="left">protected</td><td align="left">√</td><td align="left">√</td><td align="left">√</td><td>×</td></tr><tr><td align="left">default</td><td align="left">√</td><td align="left">√</td><td align="left">×</td><td>×</td></tr><tr><td align="left">private</td><td align="left">√</td><td align="left">×</td><td align="left">×</td><td>×</td></tr></tbody></table><h3 id="Golang-1"><a href="#Golang-1" class="headerlink" title="Golang"></a>Golang</h3><p>Go的控制范围以Package为单元, 首字母大写则能在包外访问, 否则不能</p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h3><p>Java在并发控制上能操控的更多,更细致。如线程池的核心参数，拒绝策略；volatile做信号量；wait/notify/join控制线程流程；ThreadLocal独享变量，各种锁。</p><p>Java新建线程可以继承Thread、实现Runnable，实现Callable<T>，lambda实例化Thread类</p><h3 id="Golang-2"><a href="#Golang-2" class="headerlink" title="Golang"></a>Golang</h3><p>Golang新建协程只需要调用go关键词，但并发控制比较受局限。如channel通信，mutex互斥锁，rwmutex读写锁，semaphore信号量机制，atomic的各种原子操作，WaitGroup控制协程流程，Context实现上下文共享</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h3><p>java除了try_catch直接捕获异常,消化异常外,Spring还提供了全局异常处理机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> </span>&#123;<br>    <span class="hljs-meta">@ExceptionHandler(UserInfoException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseVO <span class="hljs-title">handleUserInfoException</span><span class="hljs-params">(UserInfoException e)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (e.getClass().getSimpleName()) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;PhoneFormatException&quot;</span>:<br>                log.error(<span class="hljs-string">&quot;[Phone Format Error]&quot;</span>, e);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseVO(Status.PHONE_FORMAT_ERR);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;UserNotExistException&quot;</span>:<br>                log.error(<span class="hljs-string">&quot;[Uesr Not Exist Error]: &quot;</span>, e);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseVO(Status.USER_NOT_EXIST_ERR);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;PasswordWrongException&quot;</span>:<br>                log.error(<span class="hljs-string">&quot;[Password Wrong Error]: &quot;</span>, e);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseVO(Status.PASSWD_WRONG_ERR);<br>            <span class="hljs-keyword">default</span>:<br>                log.error(<span class="hljs-string">&quot;[UserInfoException] Can not handle this kind of exception&quot;</span>, e);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseVO(Status.SERVER_ERR);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该异常处理机制可以捕获Controller里任何地点没被消化的异常</p><p>用户继承Exception即可自定义异常,这些异常也可以被全局异常处理机制捕获</p><h3 id="Golang-3"><a href="#Golang-3" class="headerlink" title="Golang"></a>Golang</h3><p>Golang的recover可以捕获全局Panic, 但无法捕获用户自定义的Error,因此用户只能通过iferr判断每个函数可能返回的error</p><h2 id="Try-Resource"><a href="#Try-Resource" class="headerlink" title="Try_Resource"></a>Try_Resource</h2><h3 id="Java-4"><a href="#Java-4" class="headerlink" title="Java"></a>Java</h3><p>Java在打开资源时通常要在finally中释放资源, Java1.7后新增try-with-resource语法糖允许不用手动释放资源.</p><h3 id="Golang-4"><a href="#Golang-4" class="headerlink" title="Golang"></a>Golang</h3><p>Golang习惯在打开资源后紧跟着defer的资源释放语句, 确保资源一定会被释放</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="Java-5"><a href="#Java-5" class="headerlink" title="Java"></a>Java</h3><p>Java使用Maven管理依赖包(jar), maven首先前往本地仓库拉去依赖,失败后才会去远程仓库(maven repository)拉取.</p><p>此外maven-plugin可以管理项目的生命周期</p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309091406867.png" alt="image-20230909140355281" style="zoom:67%;" /><p>maven clean package则可以顺序执行clean周期到clean阶段,执行default周期到package阶段</p><h3 id="Golang-5"><a href="#Golang-5" class="headerlink" title="Golang"></a>Golang</h3><h4 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h4><p>golang在1.11后正式推出<a href="https://www.cnblogs.com/wongbingming/p/12941021.html">GoMoudles模式</a>,在此之前,Golang的依赖包需要放在GOPATH下,任何import都会从GOPATH下寻找。但逐渐出现许多问题：</p><ol><li>依赖包的不同版本无法共存在GOPATH下，不同项目依赖不同版本时要么独立设置GOPATH，要么更名另一版本的依赖包</li><li>没有管理项目依赖项的工具，如果某些依赖被剔除，需要人为检查</li></ol><h4 id="Go-Vendor"><a href="#Go-Vendor" class="headerlink" title="Go Vendor"></a>Go Vendor</h4><p>golang在1.5开始支持go vendor，开启时每个项目都会构建vendor目录，所有以来也都会下载到自己的vendor目录下。寻找依赖包时，vendor优先级高于GOPATH。</p><h4 id="Go-Moudles"><a href="#Go-Moudles" class="headerlink" title="Go Moudles"></a>Go Moudles</h4><p>GO111MODULE=on开启GoMoudle模式。GoMoudles模式对应的工具为go mod。新建GoMoudle项目时只需要执行go mod init ”github.com/levi/testmod“即可在本目录下生成go.mod文件, go.mod所在的根目录即为一个GoMoudle项目。</p><p>其他使用者通过go mod get ”github.com/levi/testmod“即可下载。</p><p>go moudles没有中心库和本地库的区别，下载依赖包就是直接拉取源码。而且如果处于内网开发，就无法下载依赖。此时go mod vendor就能下载到vendor目录并隔离外网开发。</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>如果本地开发需要依赖一些本地模块或未发布模块，通过replace即可替换掉远程模块。但每个人replace为本地模块时填写的本地路径都不一样</p><p>golang在1.18后又新增了<a href="https://juejin.cn/post/7083317886785159204?from=search-suggest">go work</a>。go.work支持将多个Go Moudle的聚拢到当前go.work的项目中, 然后再通过replace替换为本地项目,以此达到原先在go.mod的replace效果。go.work不用上传,留在本地即可。</p><h2 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h2><table><thead><tr><th align="left">对比项</th><th align="left">Java</th><th align="left">Go</th><th align="left">影响程度</th></tr></thead><tbody><tr><td align="left">支持跨平台编译</td><td align="left">支持</td><td align="left">支持</td><td align="left">可以减轻重复工作量；<br/>但Go跨平台编译需要做额外工作：编写Makefile文件，通过Makefile文件标注各种平台编译需要的环境变量</td></tr><tr><td align="left">支持跨平台运行</td><td align="left">支持</td><td align="left">支持，但需要在编译阶段下功夫</td><td align="left">影响大，避免按平台区别编码，增加工作量;<br/>java一次编码，到处运行，go如果需要c库，则会有影响，大部分情况没有影响</td></tr><tr><td align="left">编译产物</td><td align="left">当前项目jar+所有依赖的项目jar文件</td><td align="left">一个单独的exe文件，没有依赖项</td><td align="left">影响大，影响CD部署环境的维护工作量，这一点，Go的优势更大</td></tr><tr><td align="left">编译产物大小</td><td align="left">取决于项目的依赖包多少以及各依赖项的大小</td><td align="left">相对小</td><td align="left">影响磁盘空间；<br/>影响镜像拉取速度，进而影响服务启动速度</td></tr><tr><td align="left">运行环境</td><td align="left">取需要安装JVM</td><td align="left">无需安装任何依赖，直接运行exe文件</td><td align="left">直接影响运维的工作量，GO对运维主机的维护更简单</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang与Java&quot;&gt;&lt;a href=&quot;#Golang与Java&quot; class=&quot;headerlink&quot; title=&quot;Golang与Java&quot;&gt;&lt;/a&gt;Golang与Java&lt;/h1&gt;&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>有了MAC为什么还需要IP</title>
    <link href="http://example.com/2023/09/03/%E6%9C%89%E4%BA%86MAC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81IP/"/>
    <id>http://example.com/2023/09/03/%E6%9C%89%E4%BA%86MAC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81IP/</id>
    <published>2023-09-03T13:34:41.000Z</published>
    <updated>2023-09-03T15:53:52.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="端到端的网络"><a href="#端到端的网络" class="headerlink" title="端到端的网络"></a>端到端的网络</h1><p>如今只有两台主机，他们之间想要通信，我们顺理成章地在两台主机之间接上了一根网线，这样他们就可以通信了。之后又有主机想要加入通信，但似乎也不是问题，只是每个主机都连接两根网线。可随着更多主机的加入，我们发现主机的网口已经被占满了。于是我们需要一个“集线器”，作为主机间的中间设备。每个主机只需要连接“集线器”，主机间的通信可以通过这个设备转发。</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>但这并没有完全解决问题，“集线器”做不到原先端到端的定点传输，还只能是广播转发。为了让“集线器”更加智能，我们设计了<strong>MAC地址表</strong>，MAC地址则是每台主机的唯一标识。在这一设计下，主机发送消息前会在数据包外附加一层带有本机MAC地址（源MAC地址）和目标主机MAC地址（目标MAC地址）的数据。这全部就称之为<strong>帧</strong>。帧在到达“集线器”后，根据MAC地址表可以找到目标主机连接在哪一端口，从而定向转发。这种具有转发能力的中间设备，我们称为“交换机”。</p><p>交换机刚加入网络时，MAC地址表肯定是空的，又是如何逐步建立起来的？以主机A向主机B通信为例，主机A发出的帧在到达交换机时，交换机会在MAC地址表记录下MAC_A到PORT_A的映射，但因为没有主机B的记录，交换机会将该帧广播给所有可用端口。此后主机B接受到帧，比较自身MAC和帧记录的目标MAC，发现自己是目标主机，于是打包好响应帧（源MAC为MAC_B，目标MAC为MAC_A）并返还给交换机。之后交换机收到响应帧，记录MAC_B到PORT_B的映射，然后因为原先有记录便直接把响应帧通过PORT_A转发给主机A，至此，MAC地址表记录下了A、B的信息。对于其他主机C、D等等，当发现自己不是目标主机就会丢弃帧，自然也不会在MAC地址表留下记录。</p><h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>可网络继续扩大，直到路由器的物理端口也被占满了呢？再添加一个交换机，交换机间用网线连接，这是一个解决办法，但每个交换机依然要记录网络拓扑中所有主机的MAC地址。如果网络规模发展至千万级别，MAC地址表将不堪重负。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309032220756.png" alt="图片"></p><p>我们注意到，主机A、B、C、D向主机E、F、G、H通信时，数据第一次肯定通过上图的红线转发出去。自然的，A、B、C、D形成了一个网络区域，对于这一网络区域的任何主机而言，向另一网络区域通信时都只需要统一向一个端口转发即可，至于这个端口外面的网络有多大多复杂，我似乎并不需要在意。</p><p>这样，网络区域向网络区域的数据转发工作，就由一个新设备“交换机”来承担。交换机存在于不同的网络区域之间，即上图红线处。被交换机划分出的网络区域我们称之为局域网。局域网内的通信可以由交换机完成，否则要先转发给路由器。那么路由器也就需要自己的MAC地址了，作为这个局域网向外通信的默认MAC地址。</p><blockquote><p>值得注意的是，路由器的每一个端口都有独立的MAC地址。这是因为路由器要为每一个连接到的局域网提供默认MAC地址。</p></blockquote><p>局域网怎么知道数据包是否要发往网外呢？理想的方式是通过地址前缀判断，如果数据包的源、目的MAC地址的固定前缀一样，则表明源、目的主机在同一局域网内。</p><p>可这种方式仍有很大的局限性：MAC地址是烧录在设备上的，想凑到同一局域网就必须找到同一前缀的设备；此外设备也很难迁移到其他局域网里。</p><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p>为此，我们构造了IPv4，即一个由4组8位二进制数构成，共32位的二进制动态编号，每组以<code>.</code>相连。比如<code>11000000.10101000.00000000.00000001</code>，转换成十进制就是我们熟知的IP地址<code>192.168.0.1</code>。</p><p>再套用地址前缀的理念，当我们规定前缀长度为5时，就有<code>11111000.00000000.00000000.00000000</code>，两主机的IP分别与该IP作与运算的结果如果相同，就说明两主机处于同一局域网，否则两主机的通信就要借助交换机转发。我们称这种特殊IP为子网掩码，路由器的端口IP称为默认网关。</p><p>有了IP的加入，主机在帧的外面还要附加一层带有源IP和目标IP的数据，整体称之为<code>段</code>。</p><p>主机在打包数据前，先判断目标主机是否处于同一子网，是则正常把源MAC和目的MAC打包进段中，不是就把目的MAC改为路由器MAC，也就是告诉交换机要把流量转发给路由器处理。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>我们提到过，路由器每个端口都有独立的MAC地址，以便连接各个局域网。但是问题来了，局域网内的主机只有默认网关，即路由器端口的IP地址，可向外通信时填写的路由器MAC，主机是怎么知道的呢？</p><p>通过目标IP寻找目标MAC的过程称为ARP，为了知道目标MAC，源主机会广播一条ARP请求，目标主机比对IP后就会回复ARP响应，其中就带有自己的MAC地址。此外，主机内部有一张<code>ARP缓存表</code>，用于储存目标地址到目标MAC的映射。在这次的ARP过程中，源主机和目标主机就都记录下了各自的IP和MAC。</p><p>同样的，目的IP为外网IP时，路由器端口就会回应这次ARP请求，源主机也就知道了路由器端口的MAC地址。</p><h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>有了目的IP（外网主机IP）、目的MAC（路由器端口MAC），发送的段也抵达了路由器。那问题来了，路由器怎么知道转发到哪个端口呢？或者说，转发到哪个子网呢？</p><p>类似与MAC地址表，路由器的路由表储存着子网到端口的映射，子网也就通过IP和子网掩码来表示。这里了解一个新的表示方法，IP：192.168.0.0，子网掩码：255.255.255.0；简写为192.168.0.0/24。24也就是子网掩码在二进制下的前缀长度。</p><p>至于路由表是如何建立起来的，涉及到的路由算法可参考<a href="https://zhuanlan.zhihu.com/p/138122809">路由算法（全网最细） - 知乎 (zhihu.com)</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，从两台主机到亿万台主机网络的发展过程已经概述了一遍。主机、交换机和路由器在网络中各司其职就能织成一张巨大的网络。</p><p>站在主机视角上：</p><ul><li>需要知道源IP和目的IP</li><li>需要知道子网源码和默认网关，用于判断目的IP是否处于同一局域网，以及向外通信时要找谁转发</li><li>ARP缓存没有目的MAC时需要先通过ARP找到</li></ul><p>站在交换机视角上：</p><ul><li>需要知道目的MAC地址，可以不关心源MAC地址</li><li>MAC地址表没有对应记录时，直接广播</li><li>收到数据包的同时更新或新增MAC地址表项</li></ul><p>站在路由器视角上：</p><ul><li>需要知道目的IP地址</li><li>查找路由表来转发，没找到就返回路由不可达的响应包</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ">如果让你来设计网络 (qq.com)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;端到端的网络&quot;&gt;&lt;a href=&quot;#端到端的网络&quot; class=&quot;headerlink&quot; title=&quot;端到端的网络&quot;&gt;&lt;/a&gt;端到端的网络&lt;/h1&gt;&lt;p&gt;如今只有两台主机，他们之间想要通信，我们顺理成章地在两台主机之间接上了一根网线，这样他们就可以通信了。之后又</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>powershell beautify</title>
    <link href="http://example.com/2023/09/02/powershell-beautify/"/>
    <id>http://example.com/2023/09/02/powershell-beautify/</id>
    <published>2023-09-02T09:00:09.000Z</published>
    <updated>2023-09-02T09:01:06.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先从PowerShell说起"><a href="#先从PowerShell说起" class="headerlink" title="先从PowerShell说起"></a><strong>先从PowerShell说起</strong></h1><p>Windows自带的Windows PowerShell一般为PowerShell 5, 相比于最新的PowerShell 7有着<a href="https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/differences-from-windows-powershell?view=powershell-7.3">比较多的差异</a>。</p><p>本文后续的所有美化与功能加强都将基于PowerShell 7。建议在<a href="https://github.com/PowerShell/PowerShell/releases">Github-PowerShell</a>下载PowerShell 7+版本，即<code>pwsh</code>。注意，pwsh与原生Windows PowerShell为两个独立终端，pwsh做的工作并不会生效在Windows PowerShell上。</p><h1 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a><strong>Windows Terminal</strong></h1><p>新版pwsh的界面依然不是很耐看，其自带的风格定义十分有限。且pwsh只是一个独立终端，不能满足多终端协同工作。Windows Terminal能集成PowerShell、Git Bash、Azure、WSL等终端，并且能定义界面背景、字体颜色等等。其依然可以在<a href="https://github.com/microsoft/terminal/releases">Github-terminal</a>中下载，微软商城也能下载，但速度很慢。</p><h2 id="新增终端pwsh"><a href="#新增终端pwsh" class="headerlink" title="新增终端pwsh"></a><strong>新增终端pwsh</strong></h2><p><code>ctrl+，</code>打开Windos Terminal的设置，新增配置文件，填入pwsh的路径</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309021700840.png" alt="image-20230902164057151"></p><h1 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a><strong>Scoop</strong></h1><p>Scoop是一款适用于WIndows平台的命令行软件包管理工具，满足用户对软件包的安装管理需求。其作用可类比于macOS的homebrew、Linux的apt-get、python的pip等工具。</p><h2 id="为什么Scoop"><a href="#为什么Scoop" class="headerlink" title="为什么Scoop"></a><strong>为什么Scoop</strong></h2><p>本章的Scoop主要用于安装oh-my-posh（终端主题）和各种unix工具。针对oh-my-posh而言，主流教程都是通过<code>Install-Module oh-my-posh</code>来安装，但经过笔者试验会报错</p><blockquote><p>Install-Package: No match was found for the specified search criteria and module name ‘oh-my-posh’. Try Get-PSRepository to see all available registered module repositories.</p></blockquote><p>这是因为PSRepository没被注册，自然无法找到需要安装的模块。但如果尝试<code>Register-PSRepository -Default</code>,或指定安装PSGallery,或改变管理端口,<a href="https://stackoverflow.com/questions/43323123/warning-unable-to-find-module-repositories">warning-unable-to-find-module-repositories</a>。发现都无法生效时，建议使用Scoop安装。</p><h2 id="安装Scoop"><a href="#安装Scoop" class="headerlink" title="安装Scoop"></a><strong>安装Scoop</strong></h2><p>设置Powershell执行策略</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Set</span>-ExecutionPolicy -ExecutionPolicy RemoteSigned -<span class="hljs-keyword">Scope</span> CurrentUser<br></code></pre></td></tr></table></figure><p>安装Scoop</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Invoke-Expression (New-Object System.Net.WebClient).<span class="hljs-constructor">DownloadString(&#x27;<span class="hljs-params">https</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">get</span>.<span class="hljs-params">scoop</span>.<span class="hljs-params">sh</span>&#x27;)</span><br></code></pre></td></tr></table></figure><p>该命令默认安装至C盘，如需要更改目录，则在执行上述命令前添加环境变量定义：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$env</span><span class="hljs-symbol">:SCOOP=<span class="hljs-string">&#x27;D:\Applications\Scoop&#x27;</span></span><br>[Environment]::SetEnvironmentVariable(<span class="hljs-string">&#x27;SCOOP&#x27;</span>, <span class="hljs-variable">$env</span><span class="hljs-symbol">:SCOOP</span>, <span class="hljs-string">&#x27;User&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="安装oh-my-posh"><a href="#安装oh-my-posh" class="headerlink" title="安装oh-my-posh"></a><strong>安装oh-my-posh</strong></h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">scoop </span><span class="hljs-keyword">install </span>oh-my-posh<br></code></pre></td></tr></table></figure><h1 id="Oh-my-posh"><a href="#Oh-my-posh" class="headerlink" title="Oh-my-posh"></a><strong>Oh-my-posh</strong></h1><p>Oh-my-posh作为一款终端Prompt个性化工具,衍生于Oh-my-zsh。如今除Windows外，Oh-my-posh还支持了WSL，macOS系统上的各式终端。Oh-my-posh预置了几十款主题，风格各异，通过<code>Get-PoshThemes</code>可以预览所有预置主题:</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309021700825.png" alt="image-20230902164647627"></p><p>在输出的尾部可以看到Themes的储存位置，用户还可以在<a href="https://ohmyposh.dev/docs/themes">官网主题</a>下载主题并放置于此。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a><strong>安装主题</strong></h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">oh-my-posh prompt init pwsh --config C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\L</span>evi<span class="hljs-symbol">\s</span>coop<span class="hljs-symbol">\a</span>pps<span class="hljs-symbol">\o</span>h-my-posh<span class="hljs-symbol">\1</span>8.0.1<span class="hljs-symbol">\t</span>hemes<span class="hljs-symbol">\t</span>akuya.omp.json | Invoke-Expression<br></code></pre></td></tr></table></figure><p>其中–config跟随的是目标主题的配置文件路径，如需要更换主题则修改路径即可</p><h2 id="安装Nerd-Font字体"><a href="#安装Nerd-Font字体" class="headerlink" title="安装Nerd Font字体"></a><strong>安装Nerd Font字体</strong></h2><p>有些主题的完整显示需要一些特殊字符或图标，否则表现成一个个方框。这里推荐安装<a href="https://www.nerdfonts.com/">Nerd Font</a>，同样的如果无法访问就前往<a href="https://github.com/ryanoasis/nerd-fonts/releases">Github-NerdFonts</a>下载</p><p>下载好的字体包，右键<code>为所有用户安装</code>即可安装字体，以<code>AurulentSansM Nerd Font</code>为例，在设置-个性化-字体 中可以找到安装的字体：</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309021700930.png" alt="image-20230902164829377"></p><p>打开Windoes Terminal的配置文件</p><p>找profile.defaults并修改font内容，注意face内容不是字体的元数据里的全称：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;profiles&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;defaults&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;font&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;face&quot;</span>: <span class="hljs-string">&quot;AurulentSansM Nerd Font&quot;</span>,<br>                <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">12.0</span><br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，重启Windows Terminal就能看到完整的主题了。</p><h2 id="集成git-bash"><a href="#集成git-bash" class="headerlink" title="集成git bash"></a><strong>集成git bash</strong></h2><p>如果想像git bash一样，支持显示当前分支名等功能，可以尝试<code>scoop install posh-git</code>安装。具体步骤笔者没有亲试，感兴趣者可以通过关键词posh-git自行搜索相关流程。</p><h1 id="Unix工具链"><a href="#Unix工具链" class="headerlink" title="Unix工具链"></a><strong>Unix工具链</strong></h1><p>如果你是Linux用户，开始使用Windows时会十分不适应，主要因为Windows缺少很多实用工具如vim，cat，grep，甚至是ls的功能都不全！！！</p><p>当然，在Windows里是有些命令能对应到Linux，比如Get-ChildItem，但相比下并不好用。</p><h2 id="安装busybox"><a href="#安装busybox" class="headerlink" title="安装busybox"></a><strong>安装busybox</strong></h2><p>busybox中涵盖了大多常用的Linux命令，包括awk、clear、tail、sed等等。通过<code>scoop install busybox</code>安装。之后通过<code>busybox --list</code>可以查看其支持的命令。</p><h2 id="定向查找"><a href="#定向查找" class="headerlink" title="定向查找"></a><strong>定向查找</strong></h2><p>对于busybox没有涵盖的命令或功能不全的命令，如zip。可以通过<code>scoop search unzip</code>查看提供该功能的工具包，选择一个即可安装。</p><p>注意，新安装的工具包内如果有命令与其他工具包的命令重名，新工具包的命令会取代现有命令。</p><h2 id="自动补全与历史显示"><a href="#自动补全与历史显示" class="headerlink" title="自动补全与历史显示"></a><strong>自动补全与历史显示</strong></h2><p>Linux除了常用的命令外，TAB键的自动补全功能也能有效提高工作效率，尤其是在进入层层目录的时候。</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309021700818.png" alt="image-20230902165259514"></p><p>通过命令<code>Set-PSReadlineKeyHandler -Key Tab -Function Complete</code>可以加上该功能，挑选目录时也可以通过方向键选择。</p><p>此外，根据历史命令预测本次命令的功能也能极大改善使用体验。这里我只需要输入cd，终端就能根据最近的历史命令向我提供补全提示，按下右方向键即可补全完整命令了：</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309021700891.png" alt="image-20230902165343779"></p><p>通过命令<code>Set-PSReadLineOption -PredictionSource History -ShowToolTips</code>可以加上该功能。</p><h2 id="其他选用工具"><a href="#其他选用工具" class="headerlink" title="其他选用工具"></a><strong>其他选用工具</strong></h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">PSReadLineKeyHandler</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Key</span> <span class="hljs-built_in">Tab</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Function</span> <span class="hljs-variable">MenuComplete</span>  <span class="hljs-operator">//</span>自动补全的风格为<span class="hljs-variable">zsh</span>风格<br><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">PSReadLineKeyHandler</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Key</span> <span class="hljs-string">&quot;Ctrl+z&quot;</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Function</span> <span class="hljs-variable">Undo</span>   <span class="hljs-operator">//</span>撤销最近的输入<br><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">PSReadLineKeyHandler</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Key</span> <span class="hljs-built_in">UpArrow</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Function</span> <span class="hljs-variable">HistorySearchBackward</span>   <span class="hljs-operator">//</span>向上查阅命令历史<br><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">PSReadLineKeyHandler</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Key</span> <span class="hljs-built_in">DownArrow</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Function</span> <span class="hljs-variable">HistorySearchForward</span>  <span class="hljs-operator">//</span>向下查阅命令历史<br></code></pre></td></tr></table></figure><h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a><strong>配置自启动</strong></h2><p>以上功能包括oh-my-posh主题、自动补全等在新建pwsh窗口时都会失效，因为命令行方式启动只会作用于当前窗口。为了保证每一新建窗口都应用上配置的功能，我们需要改动pwsh的启动配置文件（.ps1文件）</p><p>在pwsh上执行<code>$PROFILE</code>可以看到pwsh的启动文件位置。注意，该文件有可能不存在，这是正常的，我们只需要照着路径创建该文件即可：<code>touch $PROFILE</code>。打开该文件，将需要的预命令写入：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"># TAB菜单选项<br>Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete<br>Set-PSReadLineOption -PredictionSource History -ShowToolTips<br># 推荐velvet，ys等主题<br>oh-my-posh prompt init pwsh --config C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\L</span>evi<span class="hljs-symbol">\s</span>coop<span class="hljs-symbol">\a</span>pps<span class="hljs-symbol">\o</span>h-my-posh<span class="hljs-symbol">\1</span>8.0.1<span class="hljs-symbol">\t</span>hemes<span class="hljs-symbol">\t</span>akuya.omp.json | Invoke-Expression<br></code></pre></td></tr></table></figure><p>至此，一套改装完的，崭新的Windows终端就完全配置好了。相信它能够满足你的日常使用。</p><h1 id="集成VsCode"><a href="#集成VsCode" class="headerlink" title="集成VsCode"></a><strong>集成VsCode</strong></h1><p>笔者习惯使用VsCode作为日常的IDE，当然VsCode也需要同样集成pwsh。</p><h2 id="更改默认终端"><a href="#更改默认终端" class="headerlink" title="更改默认终端"></a><strong>更改默认终端</strong></h2><p>打开VsCode的用户setting.json(ctrl+shift+P,再输入<code>user setting json</code>关键字)。在<code>terminal.integrated.profiles.windows</code>中新增pwsh的路径：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-string">&quot;pwsh&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;D:<span class="hljs-subst">\\</span>PowerShell<span class="hljs-subst">\\</span>pwsh.exe&quot;</span>,<br>            <span class="hljs-string">&quot;icon&quot;</span>: <span class="hljs-string">&quot;terminal-powershell&quot;</span>,<br>            <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;terminal.ansiGreen&quot;</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>同时设置<code>&quot;terminal.integrated.defaultProfile.windows&quot;: &quot;pwsh&quot;</code></p><h2 id="设置Nerd-Font字体"><a href="#设置Nerd-Font字体" class="headerlink" title="设置Nerd Font字体"></a><strong>设置Nerd Font字体</strong></h2><p>笔者实践时发现VsCode终端的字体与pwsh并不同步，需要单独设置。同样在用户setting.json中，添加以下两行：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="hljs-string">&quot;AurulentSansM Nerd Font&quot;</span>,<br><span class="hljs-string">&quot;terminal.integrated.fontSize&quot;</span>: <span class="hljs-number">12</span>,<br></code></pre></td></tr></table></figure><h1 id="其他改善"><a href="#其他改善" class="headerlink" title="其他改善"></a><strong>其他改善</strong></h1><h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a><strong>自定义命令</strong></h2><p>pwsh的启动配置文件提供了function块，我们可以据此实现一些自定义的命令。比如busybox提供的ls命令功能十分有限，既不能高亮输出，也不能简略输出内容。在启动配置文件中添加：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ll</span>&#123;</span><br>    param(<br>        [switch]$<span class="hljs-keyword">al</span><br>    )<br>    <span class="hljs-keyword">if</span> ($<span class="hljs-keyword">al</span>)&#123;<br>        <span class="hljs-keyword">sh</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&#x27;ls -al&#x27;</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">sh</span> -<span class="hljs-keyword">c</span> <span class="hljs-string">&#x27;ls&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过ll来模拟bash中的ls命令，效果如下：</p><p><img src="https://levitan-1309521248.cos.ap-guangzhou.myqcloud.com/qapm/img/202309021700895.png" alt="image-20230902165636782"></p><h2 id="自定义高亮颜色"><a href="#自定义高亮颜色" class="headerlink" title="自定义高亮颜色"></a><strong>自定义高亮颜色</strong></h2><p><code>Set-PSReadLineOption -Colors</code>可以自定义命令行各个部分的颜色，色值既可以使用<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit">ANSI escape code</a>也可以使用16色值。推荐网站<a href="http://zhongguose.com/">中国色</a></p><p>微软提供以下一些<a href="https://learn.microsoft.com/en-us/powershell/module/psreadline/set-psreadlineoption?view=powershell-7.2#-colors">可自定义颜色的选项</a>，主要关注Command、Selection、inlinePrediction即可。以下为笔者使用的，可供参考：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Set</span>-PSReadLineOption <span class="hljs-comment">-Colors @&#123;</span>`<br>    Command            <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;Yellow&#x27;</span><br>    Type               <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;Blue&#x27;</span><br>    <span class="hljs-keyword">Variable</span>           <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;DarkGreen&#x27;</span><br>    <span class="hljs-keyword">Parameter</span>          <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;DarkGreen&#x27;</span><br>    ContinuationPrompt <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;DarkGray&#x27;</span><br>    Default            <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;DarkGray&#x27;</span><br>    Selection <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;#F05E1C&#x27;</span><br>    inlinePrediction <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;#91AD70&#x27;</span><br>    Error <span class="hljs-comment">=</span> <span class="hljs-comment">&#x27;Red&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先从PowerShell说起&quot;&gt;&lt;a href=&quot;#先从PowerShell说起&quot; class=&quot;headerlink&quot; title=&quot;先从PowerShell说起&quot;&gt;&lt;/a&gt;&lt;strong&gt;先从PowerShell说起&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;Windo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes</title>
    <link href="http://example.com/2021/09/20/Kubernetes/"/>
    <id>http://example.com/2021/09/20/Kubernetes/</id>
    <published>2021-09-20T02:11:52.000Z</published>
    <updated>2021-12-13T05:51:15.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="K8s集群架构"><a href="#K8s集群架构" class="headerlink" title="K8s集群架构"></a>K8s集群架构</h2><p><img src="https://pic.imgdb.cn/item/6147f1b62ab3f51d9166dd40.jpg"></p><h3 id="Master主控节点"><a href="#Master主控节点" class="headerlink" title="Master主控节点"></a>Master主控节点</h3><ul><li><strong>API Server</strong></li></ul><p>是集群的统一入口，都以RestFul风格交给Etcd存储。提供认证、授权、访问控制、API注册和发现等机制</p><ul><li><strong>Scheduler</strong></li></ul><p>节点调度，选择node节点应用部署</p><ul><li><strong>controller-manager</strong></li></ul><p>处理集群中常规后台任务，一个资源对应一个控制器</p><ul><li><strong>Etcd</strong></li></ul><p>储存系统，用于保存集群相关的数据</p><h3 id="Node工作节点"><a href="#Node工作节点" class="headerlink" title="Node工作节点"></a>Node工作节点</h3><ul><li><strong>kubelet</strong></li></ul><p>Master节点指派到Node的代表，用于管理本机容器</p><ul><li><strong>kube-proxy</strong></li></ul><p>提供网络代理，负载均衡等</p><h2 id="K8s核心概念"><a href="#K8s核心概念" class="headerlink" title="K8s核心概念"></a>K8s核心概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul><li>pod是K8s中最小的执行单元</li><li>pod是一组容器的集合，其中的容器共享一个网络</li><li>生命周期十分短暂，服务器重启之后就找不到了。</li></ul><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><ul><li>申明在Pod容器中可访问的文件目录</li><li>可以挂载在Pod中多个容器的指定路径下</li><li>支持多种后端储存抽象，本地存储、分布式存储、云存储</li></ul><h4 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h4><ul><li>用于对象资源查询，筛选</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>确保预期的Pod副本数量</li><li>实现Pod的无状态部署（Deployment）和有状态部署（StatefulSet）</li><li>可以让多个Node运行同一个Pod</li></ul><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><ul><li>定义一组Pod副本数目，版本等</li><li>通过控制器维持Pod数目（自动修复，回收失败的Pod）</li><li>通过控制器以指定的策略控制版本（回滚，滚动升级等）</li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul><li>定义一组Pod的访问规则，为一个或多个Pod提供稳定的访问地址</li></ul><h2 id="K8s流程"><a href="#K8s流程" class="headerlink" title="K8s流程"></a>K8s流程</h2><ul><li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APl server写入etcd</li><li>此时Controller Manager通过API Server的监听资源变化的接口<strong>监听到此RC事件</strong></li><li>Controller Manager分析之后，发现当前集群中还没有它所对应的Pod实例，于是根据RC里的Pod模板定义一个<strong>生成Pod对象</strong>，通过API Server写入etcd</li><li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod<strong>选定一个落户的Node</strong>，然后通过API Server讲这一结果写入etcd中</li><li>目标Node上运行的Kubelet进程通过API Server监测到这个新生的Pod.并按照它的定义，<strong>启动该Pod</strong>并任劳任怨地负责它的下半生，直到Pod的生命结束</li><li>随后，我们通过Kubectl<strong>提交一个新的映射</strong>到该Pod的Service的创建请求</li><li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的<strong>Endpoints信息</strong>，并通过APIServer写入到etcd中</li><li>接下来，所有Node上运行的Proxy进程通过API Server查询并监听Service对象与其对应的Endpoints信息，建立一个软件方式的负载均衡器来实现<strong>Service访问到后端Pod</strong>的流量转发功能</li></ul><p><img src="https://pic.imgdb.cn/item/6151b04f2ab3f51d919f924d.jpg"></p><h2 id="K8s集群搭建"><a href="#K8s集群搭建" class="headerlink" title="K8s集群搭建"></a>K8s集群搭建</h2><p>视频搭建：<a href="https://www.bilibili.com/video/BV1GT4y1A756?p=6">k8s教程由浅入深-尚硅谷_哔哩哔哩_bilibili</a></p><p>博客借鉴：<a href="http://www.moguit.cn/#/info?blogOid=548">使用kubeadm方式搭建K8S集群 (moguit.cn)</a></p><blockquote><p>注意，因为我穷买不起那么多服务器来搭建集群，于是通过VMWare软件创建了三个”服务器”，使用镜像为CentOS-7-x86_64-Minimal-2009.iso，分配硬件资源最好每台都能是2C4G往上，即使内存不够用可以降为2G，但<strong>处理器一定要2C往上，这是K8s的最低标准</strong></p></blockquote><p>有两种方式搭建集群，<strong>kubeadm和二进制包</strong>。Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><h1 id="使用kubeadm方式搭建K8S集群"><a href="#使用kubeadm方式搭建K8S集群" class="headerlink" title="使用kubeadm方式搭建K8S集群"></a>使用kubeadm方式搭建K8S集群</h1><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p><p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个 Master 节点</span><br>kubeadm init<br><br><span class="hljs-comment"># 将一个 Node 节点加入到当前集群中</span><br>kubeadm join &lt;Master节点的IP和端口 &gt;<br></code></pre></td></tr></table></figure><p>=以下ip请以虚拟机内分配的主机ip为准：==</p><p>输入“ip addr”并按回车键确定，发现无法获取IP(CentOS 7默认没有ifconfig命令)，记录下网卡名称（本例中为ens33）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33<br>修改文件中ONBOOT=no为ONBOOT=yes<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service network restart#重启网路服务<br>ip addr#获取本机IP，之后就可以直接在XShell中登陆操作了<br></code></pre></td></tr></table></figure><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p><ul><li>一台或多台机器，操作系统 CentOS7.x-86_x64</li><li>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多【注意master需要两核】</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点</li><li><strong>禁止swap分区</strong></li></ul><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>192.168.177.130</td></tr><tr><td>node1</td><td>192.168.177.131</td></tr><tr><td>node2</td><td>192.168.177.132</td></tr></tbody></table><p>然后开始在每台机器上执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span><br>systemctl stop firewalld<br>systemctl <span class="hljs-built_in">disable</span> firewalld<br><br><span class="hljs-comment"># 关闭selinux</span><br><span class="hljs-comment"># 永久关闭</span><br>sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <br><span class="hljs-comment"># 临时关闭</span><br>setenforce 0  <br><br><span class="hljs-comment"># 关闭swap</span><br><span class="hljs-comment"># 临时</span><br>swapoff -a <br><span class="hljs-comment"># 永久关闭</span><br>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<br><br><span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span><br>hostnamectl set-hostname k8smaster<br><span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span><br>hostnamectl set-hostname k8snode1<br><span class="hljs-comment"># 根据规划设置主机名【node2节点操作】</span><br>hostnamectl set-hostname k8snode2<br><br><span class="hljs-comment"># 在master添加hosts</span><br>cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">192.168.177.130 k8smaster</span><br><span class="hljs-string">192.168.177.131 k8snode1</span><br><span class="hljs-string">192.168.177.132 k8snode2</span><br><span class="hljs-string">EOF</span><br><br><br><span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span><br>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment"># 生效</span><br>sysctl --system  <br><br><span class="hljs-comment"># 时间同步</span><br>yum install ntpdate -y<br>ntpdate time.windows.com<br></code></pre></td></tr></table></figure><h2 id="安装Docker-kubeadm-kubelet"><a href="#安装Docker-kubeadm-kubelet" class="headerlink" title="安装Docker/kubeadm/kubelet"></a>安装Docker/kubeadm/kubelet</h2><p>所有节点安装Docker/kubeadm/kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>首先配置一下Docker的阿里yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">[docker-ce-edge]</span><br><span class="hljs-string">name=Docker CE Edge - \$basearch</span><br><span class="hljs-string">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=1</span><br><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>然后yum方式安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># yum安装</span><br>yum -y install docker-ce<br><br><span class="hljs-comment"># 查看docker版本</span><br>docker --version  <br><br><span class="hljs-comment"># 启动docker</span><br>systemctl <span class="hljs-built_in">enable</span> docker<br>systemctl start docker<br></code></pre></td></tr></table></figure><p>配置docker的镜像源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>然后重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="添加kubernetes软件源"><a href="#添加kubernetes软件源" class="headerlink" title="添加kubernetes软件源"></a>添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=0</span><br><span class="hljs-string">repo_gpgcheck=0</span><br><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h3 id="安装kubeadm，kubelet和kubectl"><a href="#安装kubeadm，kubelet和kubectl" class="headerlink" title="安装kubeadm，kubelet和kubectl"></a>安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装kubelet、kubeadm、kubectl，同时指定版本</span><br>yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0<br><span class="hljs-comment"># 设置开机启动</span><br>systemctl <span class="hljs-built_in">enable</span> kubelet<br></code></pre></td></tr></table></figure><h2 id="部署Kubernetes-Master【master节点】"><a href="#部署Kubernetes-Master【master节点】" class="headerlink" title="部署Kubernetes Master【master节点】"></a>部署Kubernetes Master【master节点】</h2><p>在 192.168.177.130 执行，也就是master节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16<br></code></pre></td></tr></table></figure><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p><p><img src="http://image.moguit.cn/95ab34ae2cc34204810a14c25ceca070" alt="image-20200929094302491"></p><p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p><p><img src="http://image.moguit.cn/780700cd15894df68d3c1a0734ed930d" alt="image-20200929094620145"></p><p>使用kubectl工具 【master节点操作】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get nodes<br></code></pre></td></tr></table></figure><p><img src="http://image.moguit.cn/3d3bcdafe5a94b3eaeb72d461e9605f4" alt="image-20200929094933142"></p><p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p><p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p><h2 id="加入Kubernetes-Node【Slave节点】"><a href="#加入Kubernetes-Node【Slave节点】" class="headerlink" title="加入Kubernetes Node【Slave节点】"></a>加入Kubernetes Node【Slave节点】</h2><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p><p>执行在Master节点Kubernetes初始化成功之后的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \<br>    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500<br></code></pre></td></tr></table></figure><blockquote><p>注意，以上的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p></blockquote><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">kubeadm token <span class="hljs-built_in">create</span> <span class="hljs-comment">--print-join-command</span><br></code></pre></td></tr></table></figure><p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get node<br></code></pre></td></tr></table></figure><p><img src="http://image.moguit.cn/70b8b97d34924ec9809fea3b49b58954" alt="image-20201113165358663"></p><p>token过期后，node还需要加入master就需要重新获得token和ca证书sha256编码hash值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubeadm token create</span><br><br>W1020 17:31:05.411260   22815 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]<br>rl7uvf.hcarslhzos1lfd5r<br><span class="hljs-meta">$</span><span class="bash"> openssl x509 -pubkey -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span></span><br><br>11049fe03b790733f3e9e23199e35259d1d871d0d97cd4727250d31a312cc5ba<br></code></pre></td></tr></table></figure><p>在node上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm join 192.168.71.136:6443 --token rl7uvf.hcarslhzos1lfd5r --discovery-token-ca-cert-hash sha256:11049fe03b790733f3e9e23199e35259d1d871d0d97cd4727250d31a312cc5ba<br></code></pre></td></tr></table></figure><h2 id="部署CNI网络插件"><a href="#部署CNI网络插件" class="headerlink" title="部署CNI网络插件"></a>部署CNI网络插件</h2><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载网络插件配置</span><br>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加</span><br>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br><br><span class="hljs-comment"># 查看状态 【kube-system是k8s中的最小单元】</span><br>kubectl get pods -n kube-system<br></code></pre></td></tr></table></figure><p>运行后的结果</p><p><img src="http://image.moguit.cn/317f8efc40a74b119ea22eeb980caa48" alt="image-20201113165929510"></p><p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p><p><img src="http://image.moguit.cn/ccc13ff8365741a18d382cedbd3dfc5f" alt="image-20201113194557147"></p><p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># master节点将该节点删除</span><br>kubectl delete node k8snode1<br> <br><span class="hljs-comment"># 然后到k8snode1节点进行重置</span><br> kubeadm reset<br><span class="hljs-comment"># 重置完后在加入</span><br>kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500<br></code></pre></td></tr></table></figure><h2 id="测试kubernetes集群"><a href="#测试kubernetes集群" class="headerlink" title="测试kubernetes集群"></a>测试kubernetes集群</h2><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p><p>在Kubernetes集群中的Master中创建一个pod，验证是否正常运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载nginx 【会联网拉取nginx镜像】</span><br>kubectl create deployment nginx --image=nginx<br><span class="hljs-comment"># 查看状态</span><br>kubectl get pod<br></code></pre></td></tr></table></figure><p>如果我们出现Running状态的时候，表示已经成功运行了</p><p><img src="http://image.moguit.cn/314c73f0f5b9450f9b340dc83918c407" alt="image-20201113203537028"></p><p>下面我们就需要将端口暴露出去，让其它外界能够访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 暴露端口</span><br>kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort<br><span class="hljs-comment"># 查看一下对外的端口</span><br>kubectl get pod,svc<br></code></pre></td></tr></table></figure><p>能够看到，我们已经成功暴露了 80端口 到 30529上</p><p><img src="http://image.moguit.cn/7dfa4966921c49aea386b2962659336b" alt="image-20201113203840915"></p><p>我们到我们的宿主机浏览器上，访问如下地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://192.168.177.130:30529/<br></code></pre></td></tr></table></figure><p>发现我们的nginx已经成功启动了</p><p><img src="http://image.moguit.cn/aab9c0c500064e049ac6a80becd074eb" alt="image-20201113204056851"></p><p>到这里为止，我们就搭建了一个单master的k8s集群</p><p><img src="http://image.moguit.cn/071dc14b637641ef857e914f8d4894d0" alt="image-20201113204158884"></p><h2 id="错误汇总"><a href="#错误汇总" class="headerlink" title="错误汇总"></a>错误汇总</h2><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><p>在执行Kubernetes init方法的时候，出现这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:<br>[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2<br></code></pre></td></tr></table></figure><p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:<br>[ERROR Swap]: running with swap on is not supported. Please <span class="hljs-built_in">disable</span> swap<br></code></pre></td></tr></table></figure><p>错误原因是我们需要关闭swap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭swap</span><br><span class="hljs-comment"># 临时</span><br>swapoff -a <br><span class="hljs-comment"># 临时</span><br>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<br></code></pre></td></tr></table></figure><h3 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h3><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">The HTTP call equal to <span class="hljs-string">&#x27;curl -sSL http://localhost:10248/healthz&#x27;</span> failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused<br></code></pre></td></tr></table></figure><p>解决方法，首先需要到 master 节点，创建一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建文件夹</span><br>mkdir /etc/systemd/system/kubelet.service.d<br><br><span class="hljs-comment"># 创建文件</span><br>vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf<br><br><span class="hljs-comment"># 添加如下内容</span><br>Environment=<span class="hljs-string">&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span><br><br><span class="hljs-comment"># 重置</span><br>kubeadm reset<br></code></pre></td></tr></table></figure><p>然后删除刚刚创建的配置目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube<br></code></pre></td></tr></table></figure><p>然后 在master重新初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16<br></code></pre></td></tr></table></figure><p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \<br>    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5<br></code></pre></td></tr></table></figure><p>添加完成后，我们使用下面命令，查看节点是否成功添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get nodes<br></code></pre></td></tr></table></figure><h3 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h3><p>我们再执行查看节点的时候， kubectl get nodes 会出现问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of <span class="hljs-string">&quot;crypto/rsa: verification error&quot;</span> <span class="hljs-keyword">while</span> trying to verify candidate authority certificate <span class="hljs-string">&quot;kubernetes&quot;</span>)<br></code></pre></td></tr></table></figure><p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>我们需要做的就是把配置文件删除，然后重新执行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube<br></code></pre></td></tr></table></figure><p>然后再次创建一下即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME/.kube 给移除掉，再次创建时就会出现问题了</p><h3 id="错误五"><a href="#错误五" class="headerlink" title="错误五"></a>错误五</h3><p>安装的时候，出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Another app is currently holding the yum lock; waiting <span class="hljs-keyword">for</span> it to <span class="hljs-built_in">exit</span>...<br></code></pre></td></tr></table></figure><p>是因为yum上锁占用，解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install docker-ce<br></code></pre></td></tr></table></figure><h1 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl [command] [type] [name] [flags]<br></code></pre></td></tr></table></figure><ul><li>command：指定要对资源执行的操作，例如create、get、describe、delete</li><li>type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式</li><li>name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源</li><li>flags：指定可选的参数，例如，可用 -s 或者 -server参数指定Kubernetes API server的地址和端口</li></ul><blockquote><p>通过==kubectl –help==获取详细命令，==kubectl get –help==获取使用范例和详细用法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个nginx镜像</span><br>kubectl create deployment nginx --image=nginx<br><br><span class="hljs-meta">#</span><span class="bash"> 对外暴露端口</span><br>kubectl expose deployment nginx --port=80 --type=NodePort<br><br><span class="hljs-meta">#</span><span class="bash"> 查看资源</span><br>kubectl get pod, svc<br></code></pre></td></tr></table></figure><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>常见的基础命令</p><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>create</td><td>通过文件名或标准输入创建资源</td></tr><tr><td>expose</td><td>将一个资源公开为一个新的Service</td></tr><tr><td>run</td><td>在集群中运行一个特定的镜像</td></tr><tr><td>set</td><td>在对象上设置特定的功能</td></tr><tr><td>get</td><td>显示一个或多个资源</td></tr><tr><td>explain</td><td>文档参考资料</td></tr><tr><td>edit</td><td>使用默认的编辑器编辑一个资源</td></tr><tr><td>delete</td><td>通过文件名，标准输入，资源名称或标签来删除资源</td></tr></tbody></table><h2 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h2><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>rollout</td><td>管理资源的发布</td></tr><tr><td>rolling-update</td><td>对给定的复制控制器滚动更新</td></tr><tr><td>scale</td><td>扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job</td></tr><tr><td>autoscale</td><td>创建一个自动选择扩容或缩容并设置Pod数量</td></tr></tbody></table><h2 id="集群管理命令"><a href="#集群管理命令" class="headerlink" title="集群管理命令"></a>集群管理命令</h2><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>certificate</td><td>修改证书资源</td></tr><tr><td>cluster-info</td><td>显示集群信息</td></tr><tr><td>top</td><td>显示资源(CPU/M)</td></tr><tr><td>cordon</td><td>标记节点不可调度</td></tr><tr><td>uncordon</td><td>标记节点可被调度</td></tr><tr><td>drain</td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td>taint</td><td>修改节点taint标记</td></tr></tbody></table><h2 id="故障和调试命令"><a href="#故障和调试命令" class="headerlink" title="故障和调试命令"></a>故障和调试命令</h2><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>describe</td><td>显示特定资源或资源组的详细信息</td></tr><tr><td>logs</td><td>在一个Pod中打印一个容器日志，如果Pod只有一个容器，容器名称是可选的</td></tr><tr><td>attach</td><td>附加到一个运行的容器</td></tr><tr><td>exec</td><td>执行命令到容器</td></tr><tr><td>port-forward</td><td>转发一个或多个</td></tr><tr><td>proxy</td><td>运行一个proxy到Kubernetes API Server</td></tr><tr><td>cp</td><td>拷贝文件或目录到容器中</td></tr><tr><td>auth</td><td>检查授权</td></tr></tbody></table><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>apply</td><td>通过文件名或标准输入对资源应用配置</td></tr><tr><td>patch</td><td>使用补丁修改、更新资源的字段</td></tr><tr><td>replace</td><td>通过文件名或标准输入替换一个资源</td></tr><tr><td>convert</td><td>不同的API版本之间转换配置文件</td></tr><tr><td>label</td><td>更新资源上的标签</td></tr><tr><td>annotate</td><td>更新资源上的注释</td></tr><tr><td>completion</td><td>用于实现kubectl工具自动补全</td></tr><tr><td>api-versions</td><td>打印受支持的API版本</td></tr><tr><td>config</td><td>修改kubeconfig文件（用于访问API，比如配置认证信息）</td></tr><tr><td>help</td><td>所有命令帮助</td></tr><tr><td>plugin</td><td>运行一个命令行插件</td></tr><tr><td>version</td><td>打印客户端和服务版本信息</td></tr></tbody></table><h2 id="Yaml"><a href="#Yaml" class="headerlink" title="Yaml"></a>Yaml</h2><p>通过yaml文件可以创建一个pod，而yaml文件比较复杂，我们可以基于拉取的远程镜像的yaml或导出现有Pod的yaml进行自定义修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create deployment web --image=nginx -o yaml --dry-run &gt; mynginx.yaml<br></code></pre></td></tr></table></figure><p>==–dry-run==表明只是拉取而不是真正创建Pod，将其yaml文件导出至mynginx.yaml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get deploy nginx -o=yaml &gt; mynginx.yaml<br></code></pre></td></tr></table></figure><p>这个则是直接导出现有的Pod的yaml文件到mynginx.yaml</p><h1 id="Pod-1"><a href="#Pod-1" class="headerlink" title="Pod"></a>Pod</h1><p>Pod是K8S系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在K8S上运行容器化应用的资源对象，其它的资源对象都是用来支撑或者扩展Pod对象功能的，比如控制器对象是用来管控Pod对象的，Service或者Ingress资源对象是用来暴露Pod引用对象的，PersistentVolume资源对象是用来为Pod提供存储等等</p><p>K8S不会直接处理容器，而是Pod，Pod是由一个或多个container组成。其中有一个被称为“根容器”的Pause容器，其镜像来源于Kubernetes平台。</p><p>创建容器使用docker，一个docker对应一个容器，一个容器运行一个应用进程。Pod是多进程设计，运用多个应用程序，也就是一个Pod里面有多个容器，而一个容器里面运行一个应用程序</p><h2 id="为什么不直接操作容器？"><a href="#为什么不直接操作容器？" class="headerlink" title="为什么不直接操作容器？"></a>为什么不直接操作容器？</h2><ul><li>Kubernetes并不是只支持Docker这一个容器运行。</li></ul><p>Kubernetes通过CRI这个抽象层，支持除Docker之外的其他容器运行时，比如rkt甚至支持客户自定义容器运行时。因此，借助CRI这个抽象层，使得Kubernetes不依赖于底层某一种具体的容器运行时实现技术，而是直接操作pod，pod内部再管理多个业务上紧密相关的用户业务容器，这种架构便于Kubernetes做扩展</p><ul><li>可以定义一组容器的状态</li></ul><p>假设Kubernetes没有pod的概念，而是直接管理容器，那么一组容器作为一个单元，假设其中一个容器死亡了，此时这个单元的状态应该如何定义呢？应该理解成整体死亡，还是个别死亡？</p><p>这也是每个pod里都有一个Kubernetes系统自带的pause容器的原因，通过引入pause这个与业务无关并且作用类似于Linux操作系统守护进程的Kubernetes系统标准容器，以pause容器的状态来代表整个容器组的状态</p><ul><li>共享网络，频繁通信</li></ul><p>pod里所有的业务容器共享pause容器的IP地址，以及pause容器mount的Volume，通过这种设计，业务容器之间可以直接通信，文件也能够直接彼此共享。</p><p>Kubernetes里的每个pod都有唯一的IP地址。Pod的IP地址可以通过命令kubectl describe pod来查看。也就意味着Kubernetes的底层网络可以借助Flannel,openswitch等虚拟二层网络技术来实现集群内任意两个pod之间的TCP/IP通信。即使是不同主机间的Pod。</p><h2 id="Pod配置清单"><a href="#Pod配置清单" class="headerlink" title="Pod配置清单"></a>Pod配置清单</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>     <span class="hljs-comment">#必选，版本号，例如v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>       　 <span class="hljs-comment">#必选，资源类型，例如 Pod</span><br><span class="hljs-attr">metadata:</span>       　 <span class="hljs-comment">#必选，元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#必选，Pod名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#Pod所属的命名空间,默认为&quot;default&quot;</span><br>  <span class="hljs-attr">labels:</span>       　　  <span class="hljs-comment">#自定义标签列表</span><br>    <span class="hljs-attr">string:</span> <span class="hljs-string">string</span>      　          <br><span class="hljs-attr">spec:</span>  <span class="hljs-comment">#必选，Pod中容器的详细定义</span><br>  <span class="hljs-attr">containers:</span>  <span class="hljs-comment">#必选，Pod中容器列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>   <span class="hljs-comment">#必选，容器名称</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#必选，容器的镜像名称</span><br>    <span class="hljs-attr">imagePullPolicy:</span> [ <span class="hljs-string">Always|Never|IfNotPresent</span> ]  <span class="hljs-comment">#获取镜像的策略 </span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]   <span class="hljs-comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">string</span>]      <span class="hljs-comment">#容器的启动命令参数列表</span><br>    <span class="hljs-attr">workingDir:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#容器的工作目录</span><br>    <span class="hljs-attr">volumeMounts:</span>       <span class="hljs-comment">#挂载到容器内部的存储卷配置</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>      <span class="hljs-comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#存储卷在容器内mount的绝对路径，应少于512字符</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span> <span class="hljs-comment">#是否为只读模式</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment">#需要暴露的端口库号列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>        <span class="hljs-comment">#端口的名称</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span>  <span class="hljs-comment">#容器需要监听的端口号</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span>       <span class="hljs-comment">#容器所在主机需要监听的端口号，默认与Container相同</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#端口协议，支持TCP和UDP，默认TCP</span><br>    <span class="hljs-attr">env:</span>   <span class="hljs-comment">#容器运行前需设置的环境变量列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#环境变量名称</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#环境变量的值</span><br>    <span class="hljs-attr">resources:</span> <span class="hljs-comment">#资源限制和请求的设置</span><br>      <span class="hljs-attr">limits:</span>  <span class="hljs-comment">#资源限制的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span>  <span class="hljs-comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span><br>      <span class="hljs-attr">requests:</span> <span class="hljs-comment">#资源请求的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#Cpu请求，容器启动的初始可用数量</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#内存请求,容器启动的初始可用数量</span><br>    <span class="hljs-attr">lifecycle:</span> <span class="hljs-comment">#生命周期钩子</span><br>        <span class="hljs-attr">postStart:</span> <span class="hljs-comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span><br>        <span class="hljs-attr">preStop:</span> <span class="hljs-comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span><br>    <span class="hljs-attr">livenessProbe:</span>  <span class="hljs-comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span><br>      <span class="hljs-attr">exec:</span>       　 <span class="hljs-comment">#对Pod容器内检查方式设置为exec方式</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]  <span class="hljs-comment">#exec方式需要制定的命令或脚本</span><br>      <span class="hljs-attr">httpGet:</span>       <span class="hljs-comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">HttpHeaders:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">tcpSocket:</span>     <span class="hljs-comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span><br>         <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>       <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span>       <span class="hljs-comment">#容器启动完成后首次探测的时间，单位为秒</span><br>       <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span>    　　    <span class="hljs-comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br>       <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span>     　　    <span class="hljs-comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br>       <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">securityContext:</span><br>         <span class="hljs-attr">privileged:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">OnFailure</span>]  <span class="hljs-comment">#Pod的重启策略</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span><br>  <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">obeject</span> <span class="hljs-comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span><br>  <span class="hljs-attr">imagePullSecrets:</span> <span class="hljs-comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br>  <span class="hljs-attr">volumes:</span>   <span class="hljs-comment">#在该pod上定义共享存储卷列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#共享存储卷名称 （volumes类型有很多种）</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;       <span class="hljs-comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br>    <span class="hljs-attr">hostPath:</span> <span class="hljs-string">string</span>   <span class="hljs-comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">string</span>      　　        <span class="hljs-comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span><br>    <span class="hljs-attr">secret:</span>       　　　<span class="hljs-comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span><br>      <span class="hljs-attr">scretname:</span> <span class="hljs-string">string</span>  <br>      <span class="hljs-attr">items:</span>     <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>    <span class="hljs-attr">configMap:</span>         <span class="hljs-comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">items:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure><h2 id="Pod类型"><a href="#Pod类型" class="headerlink" title="Pod类型"></a>Pod类型</h2><p>Pod是K8S集群中所有业务类型的基础，可以把Pod看作运行在K8S集群上的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8S的业务主要可以分为以下几种</p><ul><li>长期伺服型：long-running</li><li>批处理型：batch</li><li>节点后台支撑型：node-daemon</li><li>有状态应用型：stateful application</li></ul><p>上述的几种类型，分别对应的小机器人控制器为：Deployment、Job、DaemonSet 和 StatefulSet </p><h2 id="Pod实现机制"><a href="#Pod实现机制" class="headerlink" title="Pod实现机制"></a>Pod实现机制</h2><h3 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h3><p>当Pod中的容器处于同一Namespace时即可实现网络共享。</p><p>以共享网络方式实现Pod，会先在Pod中创建一个根容器==Pause容器==，然后在创建业务容器时会把它放到==info容器==中，而info容器中会独立出ip、mac、port等信息，这样业务容器就会被划分到一个共享网络中。</p><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>如果Node宕机，为了继续运行Pod的服务，需要在另一个Node里运行这个Pod。但是如果通过拉取新镜像来复原服务环境，就会丢失原Node的数据。因而，将Pod内的container数据实现持久化存储，即挂载数据卷。</p><h2 id="Pod镜像拉取"><a href="#Pod镜像拉取" class="headerlink" title="Pod镜像拉取"></a>Pod镜像拉取</h2><p><img src="https://pic.imgdb.cn/item/6151a7af2ab3f51d91962a34.jpg"></p><ul><li>IfNotPresent：默认值，镜像在宿主机上不存在才拉取</li><li>Always：每次创建Pod都会重新拉取一次镜像</li><li>Never：Pod永远不会主动拉取这个镜像</li></ul><h2 id="Pod资源限制"><a href="#Pod资源限制" class="headerlink" title="Pod资源限制"></a>Pod资源限制</h2><p>新生的Pod要由Sheduler调度到合适的Node中，其中资源限制就是调度算法的考虑点。</p><p><img src="https://pic.imgdb.cn/item/6151a99d2ab3f51d91982915.jpg"></p><ul><li>requests：容器正常运行最低要求的资源数，也就是对Node配置的最低要求。</li><li>limits：限制容器扩张，是Node最多能分配给容器使用的资源量。</li></ul><h2 id="Pod重启机制"><a href="#Pod重启机制" class="headerlink" title="Pod重启机制"></a>Pod重启机制</h2><p><img src="https://pic.imgdb.cn/item/6151ab112ab3f51d9199b314.jpg"></p><ul><li>Always：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】</li><li>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</li><li>Never：当容器终止退出，从不重启容器 【批量任务，只执行一次】</li></ul><h2 id="Pod健康检查"><a href="#Pod健康检查" class="headerlink" title="Pod健康检查"></a>Pod健康检查</h2><p><img src="https://pic.imgdb.cn/item/6151ad4b2ab3f51d919c09cb.jpg"></p><p>两种检查后的处理策略：</p><ul><li>==livenessProbe(存活检查)==：如果检查出错，将杀死容器，再根据Pod的重启策略操作</li><li>==readinessProbe(就绪检查)==：如果检查出错，K8s会将Pod从Service endpoint中剔除，并用一个相同的Pod代替。</li></ul><p>三种检查方式：</p><ul><li>==http Get==：发送HTTP请求，返回200 - 400 范围状态码为成功</li><li>==exec==：执行Shell命令返回状态码是0为成功</li><li>==tcpSocket==：发起TCP Socket建立成功</li></ul><h2 id="Pod调度"><a href="#Pod调度" class="headerlink" title="Pod调度"></a>Pod调度</h2><h3 id="Pod节点选择器"><a href="#Pod节点选择器" class="headerlink" title="Pod节点选择器"></a>Pod节点选择器</h3><p><img src="https://pic.imgdb.cn/item/6151b3482ab3f51d91a2fb92.jpg"></p><p>Pod调度除了Sheduler分配，还能够人为调度。<code>env_role</code>后面选择的是Node，<code>dev</code>为Node的别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl label node k8snode1 env_role=dev#该命令可以为Node设置别名<br></code></pre></td></tr></table></figure><h3 id="Pod节点亲和性"><a href="#Pod节点亲和性" class="headerlink" title="Pod节点亲和性"></a>Pod节点亲和性</h3><p>除了Pod资源限制会影响调度，Pod还可以要求Node的其他属性符合。根据该要求的强硬程度分为硬亲和性和软亲和性。</p><p><img src="https://pic.imgdb.cn/item/6151b55e2ab3f51d91a5bc76.jpg"></p><ul><li>==operator==：判断是否满足亲和性的操作符。<code>In</code>就要求Pod要调度到标签为dev、test的Node中。类似的操作符还有<code>NotIn、Exists、Gt、Lt、DoesNotExists</code></li></ul><h3 id="污点和污点容忍"><a href="#污点和污点容忍" class="headerlink" title="污点和污点容忍"></a>污点和污点容忍</h3><p>可以为Node设置污点值，但调度时就会通过污点值来判断能否分配Pod到该Node中。污点值有三：</p><ul><li>NoSchedule：一定不被调度</li><li>PreferNoSchedule：尽量不被调度</li><li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li></ul><p>查看Node污点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl describe node k8snode1 | grep Taint<br></code></pre></td></tr></table></figure><p>添加污点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl taint node k8snode1 env_role=tzq:NoSchedule<br><span class="hljs-meta">#</span><span class="bash">kubectl taint node k8snode1 key=value:污点值</span><br></code></pre></td></tr></table></figure><p>删除污点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl taint node k8snode1 env_role:NoSchedule-<br></code></pre></td></tr></table></figure><p>我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-toleration</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">tolerations:</span>      <span class="hljs-comment"># 添加容忍</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;env_role&quot;</span>        <span class="hljs-comment"># 要容忍的污点的key</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span> <span class="hljs-comment"># 操作符</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;tzq&quot;</span>    <span class="hljs-comment"># 容忍的污点的value</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span>   <span class="hljs-comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span><br></code></pre></td></tr></table></figure><p>我们为Pod添加污点容忍，这样就可以分配到env_role=tzq:NoSchedule的Node中去了。</p><h1 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h1><p>博客借鉴：<a href="https://gitee.com/yooome/golang/blob/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.md#6-pod%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%A6%E8%A7%A3">yooome/LearningNotes</a></p><p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p><p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p><ul><li>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量<strong>扩缩容，镜像版本升级</strong></li><li>Deployment：通过控制ReplicaSet来控制Pod，并支持<strong>滚动升级、回退版本</strong></li><li>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现<strong>削峰填谷</strong></li><li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于<strong>守护进程类的任务</strong></li><li>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于<strong>执行一次性任务</strong></li><li>Cronjob：它创建的Pod负责<strong>周期性任务控制</strong>，不需要持续后台运行</li><li>StatefulSet：管理有状态应用</li></ul><h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p>Replication Controller 保证了在所有时间内，都有特定数量的Pod副本正在运行，如果太多则会按照template新建几个。</p><h3 id="Pod-template"><a href="#Pod-template" class="headerlink" title="Pod template"></a>Pod template</h3><p>一个Replication Controller通过模版来创建pod,这个是Replication Controller对象内置的功能，但是我们计划要将这个功能从Replication Controller剥离开来</p><p>与其说Pod的模版是一个多有Pod副本的期望状态，Pod的模版更像是一个饼干的模具，一旦从模具中出来之后，饼干就和饼干模具没啥关系了，没有任何关联。而Replication Controller创建的pod可以在之后直接的修改。</p><h3 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h3><p>由Replication Controller监控的Pod的数量是是由一个叫 selector（标签选择器）决定的，selector在Replication Controller和被控制的pod创建了一个松散耦合的关系,与pod相比，pod与他们的定义文件关系紧密。</p><p>因为Replication Controller是通过selector链接Pod的，因此由template创造出来的Pod必须拥有selector的标签。虽然Replication Controller也可以有自己的标签，这只是用来被Controller-manager标识的</p><p><strong>所以，删除一个Pod可以通过改变其标签，令Replication Controller失去该Pod，这样改Pod就会被自动的替换掉。反过来，如果想要清空Replication Controller所管辖的Pods，可以将.<code>spec.replicas</code>设置为零。这与直接删除Replication Controller不同，直接删除是不会影响已经被创造出来的Pods的</strong></p><h2 id="ReplicaSet-rs"><a href="#ReplicaSet-rs" class="headerlink" title="ReplicaSet(rs)"></a>ReplicaSet(rs)</h2><p>ReplicaSet的资源清单文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">rs</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p></li><li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制</p><p>在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p></li><li><p>template：模板，就是当前控制器创建pod所使用的模板</p></li></ul><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl create -f pc-replicaset.yaml<span class="hljs-comment">#通过配置文件创建控制器</span></span><br><br><span class="hljs-meta">#</span><span class="bash">DESIRED:期望的副本数CURRENT：当前副本数READY：准备提供服务的副本数</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl get rs pc-replicaset -n dev -o wide</span><br>NAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR<br>pc-replicaset 3         3       3     22s   nginx        nginx:1.17.1       app=nginx-pod<br><br><span class="hljs-meta">#</span><span class="bash">在kubernetes删除RS前，会将RS的replicas调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl delete rs pc-replicaset -n dev</span><br><span class="hljs-meta">#</span><span class="bash">推荐直接删除配置文件</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl delete -f pc-replicaset.yaml</span><br></code></pre></td></tr></table></figure><p><strong>扩缩容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">先更改配置文件的replicas，再运行</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl edit rs pc-replicaset -n dev</span><br><span class="hljs-meta">#</span><span class="bash">也可以命令实现</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl scale rs pc-replicaset --replicas=2 -n dev</span><br></code></pre></td></tr></table></figure><p><strong>镜像升级</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">更改配置文件的image，再运行</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl edit rs pc-replicaset -n dev</span><br><span class="hljs-meta">#</span><span class="bash">也可以命令实现</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl <span class="hljs-built_in">set</span> image rs pc-replicaset nginx=nginx:1.17.1  -n dev</span><br></code></pre></td></tr></table></figure><h2 id="Deployment-deploy"><a href="#Deployment-deploy" class="headerlink" title="Deployment(deploy)"></a>Deployment(deploy)</h2><p>Deployment不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p><p>相比于ReplicaSet，Deployment多了以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 保留历史版本</span><br>  <span class="hljs-attr">paused:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 暂停部署，默认是false</span><br>  <span class="hljs-attr">progressDeadlineSeconds:</span> <span class="hljs-number">600</span> <span class="hljs-comment"># 部署超时时间（s），默认是600</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate|Recreate</span> <span class="hljs-comment"># 滚动更新策略|代替原有pod策略</span><br>    <span class="hljs-attr">rollingUpdate:</span> <span class="hljs-comment"># 为滚动更新策略时才生效</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 滚动升级的过程中，最大可以超出期望Pod数的副本数，可以为百分比（默认25%），也可以为整数</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 滚动升级的过程中，不可用状态的 Pod 的最大值，可以为百分比（默认25%），也可以为整数</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl create -f pc-deployment.yaml --record=<span class="hljs-literal">true</span></span><br> <br><span class="hljs-meta">#</span><span class="bash">UP-TO-DATE 最新版本的Pod数量AVAILABLE 当前可用的Pod数量</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl get deploy pc-deployment -n dev</span><br>NAME            READY   UP-TO-DATE   AVAILABLE   AGE<br>pc-deployment   3/3     3            3           15s<br><br><span class="hljs-meta">$</span><span class="bash"> kubectl delete -f pc-deployment.yaml</span><br></code></pre></td></tr></table></figure><p><strong>扩缩容、镜像更新</strong></p><p>扩缩容方式和ReplicSet一致，只是将操作符从<code>rs</code>换成<code>deploy</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale deployment pc-deployment --replicas 10<br><span class="hljs-meta">#</span><span class="bash">如果集群支持 horizontal pod autoscaling 的话，还可以为Deployment设置自动扩展：</span><br>kubectl autoscale deployment pc-deployment --min=10 --max=15 --cpu-percent=80<br></code></pre></td></tr></table></figure><p>镜像更新则扩展了<code>重建更新和滚动更新</code>，通过<code>strategy.type</code>指定策略类型,支持两个属性<code>RollingUpdate</code>和<code>Recreate</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl set image deployment/pc-deployment nginx=nginx:1.17.2 #更新时会按照Depolyment的strategy.type来决定使用哪种更新策略<br></code></pre></td></tr></table></figure><p>==滚动更新==：更新时新版本的pod的创建不会影响旧版本pod的运行，新版本创建成功后才会删除旧版本</p><p>==重建更新==：旧版本被删除，一直等到新版本上线</p><p><strong>版本回退</strong></p><p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p><ul><li>status 显示当前升级状态</li><li>history 显示 升级历史记录</li><li>pause 暂停版本升级过程</li><li>resume 继续已经暂停的版本升级过程</li><li>restart 重启版本升级过程</li><li>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl rollout undo deployment pc-deployment --to-revision=2<br></code></pre></td></tr></table></figure><p><strong>金丝雀发布</strong></p><p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job的配置清单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">job</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job需要成功运行Pods的次数。默认值: 1</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span><br>  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">30</span> <span class="hljs-comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span><br>  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">6</span> <span class="hljs-comment"># 指定job失败后进行重试的次数。默认是6</span><br>  <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否可以使用selector选择器选择pod，默认是false</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">counter-pod</span>]&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 重启策略只能设置为Never或者OnFailure</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]<br></code></pre></td></tr></table></figure><p>Job负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。</p><p>Kubernetes支持以下几种Job，通过根据<code>.spec.completions</code>和<code>.spec.Parallelism</code>的设置可以划分：</p><table><thead><tr><th align="center">Job类型</th><th align="center">使用示例</th><th align="center">行为</th><th align="center">completions</th><th align="center">Parallelism</th></tr></thead><tbody><tr><td align="center">一次性Job</td><td align="center">数据库迁移</td><td align="center">创建一个Pod直至其成功结束</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">固定结束次数的Job</td><td align="center">处理工作队列的Pod</td><td align="center">依次创建一个Pod运行直至completions个成功结束</td><td align="center">2+</td><td align="center">1</td></tr><tr><td align="center">固定结束次数的并行Job</td><td align="center">多个Pod同时处理工作队列</td><td align="center">依次创建多个Pod运行直至completions个成功结束</td><td align="center">2+</td><td align="center">2+</td></tr><tr><td align="center">并行Job</td><td align="center">多个Pod同时处理工作队列</td><td align="center">创建一个或多个Pod直至有一个成功结束</td><td align="center">1</td><td align="center">2+</td></tr></tbody></table><h2 id="CronJob-CJ"><a href="#CronJob-CJ" class="headerlink" title="CronJob(CJ)"></a>CronJob(CJ)</h2><p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p><p>CRonJob的资源清单相比于Job多了以下部分，将Job的配置转移至了.<code>spec.jobTemplate</code>下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">&quot;*/1 * * * *&quot;</span> <span class="hljs-comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span><br>  <span class="hljs-attr">concurrencyPolicy:</span> <span class="hljs-comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span><br>  <span class="hljs-attr">failedJobHistoryLimit:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 为失败的任务执行保留的历史记录数，默认为1</span><br>  <span class="hljs-attr">successfulJobHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 为成功的任务执行保留的历史记录数，默认为3</span><br>  <span class="hljs-attr">startingDeadlineSeconds:</span> <span class="hljs-comment"># 启动作业错误的超时时长</span><br>  <span class="hljs-attr">jobTemplate:</span> <span class="hljs-comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span><br>  <span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">compeletions:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>schedule:*<em>用于指定任务的执行时间。 **多个时间可以用逗号隔开； 范围可以用连字符给出；\</em>可以作为通配符； /表示每…</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">*/1    *      *    *     *<br>&lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;<br></code></pre></td></tr></table></figure><h1 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h1><p>每个pod都由自己的ip，这些IP也随着时间的变化也不能持续依赖。这样就引发了一个问题：如果一些Pods（让我们叫它作后台，后端）提供了一些功能供其它的Pod使用（让我们叫作前台），在kubernete集群中是如何实现让这些前台能够持续的追踪到这些后台的？</p><p>Kubernete Service 是一个定义了一组Pod的策略的抽象，我们也有时候叫做宏观服务。这些被服务标记的Pod都是（一般）通过label Selector决定的。Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200408194716912-1626783758946.png" alt="img"></p><h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p><p>kube-proxy目前支持三种工作模式：</p><p>==userspace==</p><p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。 该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200509151424280.png" alt="img"></p><p>==iptables==</p><p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。 该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200509152947714.png" alt="img"></p><p>==ipvs==</p><p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p><p>此模式必须开启ipvs内核，否则会降级成iptables模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 开启ipvs</span><br>[root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system<br><span class="hljs-meta">#</span><span class="bash"> 修改mode: <span class="hljs-string">&quot;ipvs&quot;</span></span><br>[root@k8s-master01 ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200509153731363.png" alt="img"></p><h2 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h2><p>Service资源清单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>  <span class="hljs-comment"># 资源类型</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>  <span class="hljs-comment"># 资源版本</span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service</span> <span class="hljs-comment"># 资源名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 命名空间</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 描述</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 标签选择器，用于确定当前service代理哪些pod</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span> <span class="hljs-comment"># Service类型，指定service的访问方式，默认ClusterIP</span><br>  <span class="hljs-attr">clusterIP:</span>  <span class="hljs-comment"># 虚拟服务的ip地址，只能在集群内部访问</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-comment"># session亲和性，支持ClientIP、None两个选项</span><br>  <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 端口信息</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <br>      <span class="hljs-attr">port:</span> <span class="hljs-number">3017</span>  <span class="hljs-comment"># service端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5003</span> <span class="hljs-comment"># pod端口</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">31122</span> <span class="hljs-comment"># 主机端口，将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</span><br></code></pre></td></tr></table></figure><p>.<code>spec.type</code>的可选值：</p><ul><li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li><li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li><li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li><li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li></ul><h2 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h2><p>创建deployment.yaml，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>      <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>创建改deployment后，查看pod分配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels<br>NAME                             READY   STATUS     IP            NODE     LABELS<br>pc-deployment-66cb59b984-8p84h   1/1     Running    10.244.1.39   node1    app=nginx-pod<br>pc-deployment-66cb59b984-vx8vx   1/1     Running    10.244.2.33   node2    app=nginx-pod<br>pc-deployment-66cb59b984-wnncx   1/1     Running    10.244.1.40   node1    app=nginx-pod<br></code></pre></td></tr></table></figure><p>配置service-clusterip.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-clusterip</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.97</span><span class="hljs-number">.97</span><span class="hljs-number">.97</span> <span class="hljs-comment"># service的ip地址，如果不写，默认会生成一个</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>  <span class="hljs-comment"># Service端口       </span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># pod端口</span><br></code></pre></td></tr></table></figure><p>创建改service，会发现改service统一管理了标签为app: nginx-pod的pods。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建service</span><br>[root@k8s-master01 ~]# kubectl create -f service-clusterip.yaml<br>service/service-clusterip created<br><br><span class="hljs-meta">#</span><span class="bash"> 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span><br>[root@k8s-master01 ~]# kubectl describe svc service-clusterip -n dev<br>Name:              service-clusterip<br>Namespace:         dev<br>Labels:            &lt;none&gt;<br>Annotations:       &lt;none&gt;<br>Selector:          app=nginx-pod<br>Type:              ClusterIP<br>IP:                10.97.97.97<br>Port:              &lt;unset&gt;  80/TCP<br>TargetPort:        80/TCP<br>Endpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80<br>Session Affinity:  None<br>Events:            &lt;none&gt;<br><br><span class="hljs-meta">#</span><span class="bash"> 也可以查看ipvs的映射规则</span><br>[root@k8s-master01 ~]# ipvsadm -Ln<br>TCP  10.97.97.97:80 rr#rr表示采用轮询访问<br><span class="hljs-meta">  -&gt;</span><span class="bash"> 10.244.1.39:80               Masq    1      0          0</span><br><span class="hljs-meta">  -&gt;</span><span class="bash"> 10.244.1.40:80               Masq    1      0          0</span><br><span class="hljs-meta">  -&gt;</span><span class="bash"> 10.244.2.33:80               Masq    1      0          0</span><br></code></pre></td></tr></table></figure><p>我们可以看到，一个Service管理了三个Pod的通信，外部可以通过访问10.244.1.39:80来访问Pod1的服务，也可以通过10.97.97.97:80来访问Pod1的服务，只不过要注意Service采用的是轮询方式，第一次访问到Pod1，再一次就会访问Pod2了。</p><h2 id="EndPoint"><a href="#EndPoint" class="headerlink" title="EndPoint"></a>EndPoint</h2><p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址。一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong></p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200509191917069.png" alt="image-20200509191917069"></p><p>正如上面提到的，外部统一访问Service时，Service默认会通过轮询的方式把流量转发给后面的Pod，但也可以基于客户端地址保持会话，即同一个客户端的请求交给固定的一个Pod处理。</p><p>这种Service负载分发策略由属性.<code>spec.sessionAffinity</code>决定，<code>spec.sessionAffinity = ClusterIP</code>时表示基于客户端地址保持会话。</p><h2 id="HeadLiness"><a href="#HeadLiness" class="headerlink" title="HeadLiness"></a>HeadLiness</h2><p>ClusterIP提供的两种负载均衡方式难以满足显示要求，而HeadLiness能够自定义负载均衡策略。这类Service不会分配Cluster Ip，如果要访问service，只能通过service的域名进行查询。</p><p>创建HeadLiness类型Service，只需要在ClusterIP类型上将<code>spec.clusterIP</code>设置为None即可</p><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。相比于CLusterIP，NodePort会将Service的一个端口映射到Node的真实端口上，这样访问Node对应端口就能访问到Service了</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200620175731338.png" alt="img"></p><h3 id="K8s的三种IP"><a href="#K8s的三种IP" class="headerlink" title="K8s的三种IP"></a>K8s的三种IP</h3><ul><li>Node IP：Node节点IP地址</li><li>Pod IP：Pod的IP地址</li><li>Cluster IP：Service的IP地址</li></ul><p>​    NodeIP是Kubernetes集群中每个节点的物理网卡的IP地址,这是一个真实存在的物理网络,所有属于这个网络的服务器之间都能通过这个网络直接通讯，不管他们中间是否含有不属于Kubernetes集群中的节点。想Kubernetes之外的节点访问Kubernetes集群内的节点或者<strong>TCP/IP</strong>服务时，必须通过Node IP</p><p>　Pod IP是每个Pod的IP地址,通常是一个虚拟的二层网络，用于不同Pod间彼此直接通讯。所以Kubernetes里一个Pod里的容器访问另外一个Pod里的容器,就是通过Pod IP所在的虚拟二层网络进行通信，而真实的TCP/IP流量则是通过Node IP所在的物理网卡流出</p><p>​    而ClusterIP仅仅是个用于统一管理PodIP的虚拟网络，更无法在Kubernets外访问。如果外网想要访问Pods就需要使用NodePort类型的Service来代理PodIP</p><h3 id="配置NodePort"><a href="#配置NodePort" class="headerlink" title="配置NodePort"></a>配置NodePort</h3><p>创建service-nodeport.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-nodeport</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span> <span class="hljs-comment"># service类型</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30002</span> <span class="hljs-comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>创建Service后查看该NodePort-service可以看到被映射到了30002端口，这时使用任意NodeIP:30002都能访问到Pod</p><p><img src="https://pic.imgdb.cn/item/617158d52ab3f51d91cfd6de.jpg" alt="NodePort"></p><p>其实我们也可以发现，我们当初直接创建Pod时为了暴露端口，也用了NodePort</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create deployment nginx --image=nginx<br>kubectl expose deployment nginx --port=80 --type=NodePort<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/61715a1a2ab3f51d91d2b442.jpg"></p><h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200510103945494.png" alt="img"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;kind&quot;:</span> <span class="hljs-string">&quot;Service&quot;</span>,<br>    <span class="hljs-attr">&quot;apiVersion&quot;:</span> <span class="hljs-string">&quot;v1&quot;</span>,<br>    <span class="hljs-attr">&quot;metadata&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;my-service&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;spec&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;selector&quot;:</span> &#123;<br>            <span class="hljs-attr">&quot;app&quot;:</span> <span class="hljs-string">&quot;MyApp&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;ports&quot;:</span> [<br>            &#123;<br>                <span class="hljs-attr">&quot;protocol&quot;:</span> <span class="hljs-string">&quot;TCP&quot;</span>,<br>                <span class="hljs-attr">&quot;port&quot;:</span> <span class="hljs-number">80</span>,<br>                <span class="hljs-attr">&quot;targetPort&quot;:</span> <span class="hljs-number">9376</span>,<br>                <span class="hljs-attr">&quot;nodePort&quot;:</span> <span class="hljs-number">30061</span><br>            &#125;<br>        ],<br>        <span class="hljs-attr">&quot;clusterIP&quot;:</span> <span class="hljs-string">&quot;10.0.171.239&quot;</span>,<br>        <span class="hljs-attr">&quot;loadBalancerIP&quot;:</span> <span class="hljs-string">&quot;78.11.24.19&quot;</span>,<br>        <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;LoadBalancer&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;status&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;loadBalancer&quot;:</span> &#123;<br>            <span class="hljs-attr">&quot;ingress&quot;:</span> [<br>                &#123;<br>                    <span class="hljs-attr">&quot;ip&quot;:</span> <span class="hljs-string">&quot;146.148.47.155&quot;</span><br>                &#125;<br>            ]<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-loadbalancer</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">Loadbalancer</span> <span class="hljs-comment"># service类型</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30002</span> <span class="hljs-comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.97</span><span class="hljs-number">.97</span><span class="hljs-number">.98</span><br>  <span class="hljs-attr">loadBalancerIP:</span> <span class="hljs-number">78.11</span><span class="hljs-number">.24</span><span class="hljs-number">.19</span><br></code></pre></td></tr></table></figure><p>从外部负载均衡器的流量将会被引到后端的Pod，然而具体这个如何实现则要看云提供商。一些云提供商允许指定loadBalancerIP。如果字段loadBalancerIP没有指定，该负载均衡器会被指定一个短暂性的IP。如果指定了loadBalancerIP，但是云提供商不支持这个特性，这个字段会被忽略。</p><h2 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h2><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200510113311209.png" alt="img"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">service-externalname</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ExternalName</span> <span class="hljs-comment"># service类型</span><br>  <span class="hljs-attr">externalName:</span> <span class="hljs-string">www.baidu.com</span>  <span class="hljs-comment">#改成ip地址也可以</span><br></code></pre></td></tr></table></figure><h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><ul><li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li><li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li></ul><p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p><p><img src="https://gitee.com/yooome/golang/raw/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubenetes.assets/image-20200623092808049.png" alt="img"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[root@k8s-master01 ~]<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h1&gt;&lt;h2 id=&quot;K8s集群架构&quot;&gt;&lt;a href=&quot;#K8s集群架构&quot; class</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/09/10/Redis/"/>
    <id>http://example.com/2021/09/10/Redis/</id>
    <published>2021-09-10T03:20:19.000Z</published>
    <updated>2021-11-18T06:53:47.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p><a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=9">【狂神说Java】Redis最新超详细版教程通俗易懂_哔哩哔哩_bilibili</a></p><h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h2><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/keys-del.html">DEL key</a> 该命令用于在 key 存在时删除 key。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/keys-dump.html">DUMP key</a> 序列化给定 key ，并返回被序列化的值。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/redis/keys-exists.html">EXISTS key</a> 检查给定 key 是否存在。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/keys-expire.html">EXPIRE key seconds</a>  为给定 key 设置过期时间，以秒计。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/keys-expireat.html">EXPIREAT key timestamp</a> EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/keys-pexpire.html">PEXPIRE key milliseconds</a> 设置 key 的过期时间以毫秒计。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/keys-pexpireat.html">PEXPIREAT key milliseconds-timestamp</a> 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/keys-keys.html">KEYS pattern</a> 查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/keys-move.html">MOVE key db</a> 将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/keys-persist.html">PERSIST key</a> 移除 key 的过期时间，key 将持久保持。</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/keys-pttl.html">PTTL key</a> 以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/keys-ttl.html">TTL key</a> 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/keys-randomkey.html">RANDOMKEY</a> 从当前数据库中随机返回一个 key 。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/keys-rename.html">RENAME key newkey</a> 修改 key 的名称</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/keys-renamenx.html">RENAMENX key newkey</a> 仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/redis/keys-scan.html">SCAN cursor [MATCH pattern …] [COUNT count]</a> 迭代数据库中的数据库键。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/keys-type.html">TYPE key</a> 返回 key 所储存的值的类型。</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a> 设置指定 key 的值</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/strings-get.html">GET key</a> 获取指定 key 的值。</td></tr><tr><td align="left"><strong>3</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-getrange.html">GETRANGE key start end</a> 返回 key 中字符串值的子字符</strong></td></tr><tr><td align="left"><strong>4</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-getset.html">GETSET key value</a> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</strong></td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/strings-mget.html">MGET key1 [key2..]</a> 获取所有(一个或多个)给定 key 的值。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/strings-setbit.html">SETBIT key offset value</a> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td></tr><tr><td align="left"><strong>8</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-setex.html">SETEX key seconds value</a> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</strong></td></tr><tr><td align="left"><strong>9</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX key value</a> 只有在 key 不存在时设置 key 的值。</strong></td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/strings-setrange.html">SETRANGE key offset value</a> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/strings-strlen.html">STRLEN key</a> 返回 key 所储存的字符串值的长度。</td></tr><tr><td align="left"><strong>12</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-mset.html">MSET key value [key value …]</a> 同时设置一个或多个 key-value 对。</strong></td></tr><tr><td align="left"><strong>13</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-msetnx.html">MSETNX key value [key value …]</a> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</strong></td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/strings-psetex.html">PSETEX key milliseconds value</a> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a> 将 key 中储存的数字值增一。</td></tr><tr><td align="left"><strong>16</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a> 将 key 所储存的值加上给定的增量值（increment） 。</strong></td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/redis/strings-decr.html">DECR key</a> 将 key 中储存的数字值减一。</td></tr><tr><td align="left"><strong>19</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-decrby.html">DECRBY key decrement</a> key 所储存的值减去给定的减量值（decrement） 。</strong></td></tr><tr><td align="left"><strong>20</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/strings-append.html">APPEND key value</a> 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</strong></td></tr></tbody></table><ul><li><code>GETRANGE key start end</code>获取key[start,end]，<code>end/start</code>为负数时代表倒数第<code>|end|/|start|</code>个字符。当start值大于end时返回空字符串！！</li></ul><p><img src="https://pic.imgdb.cn/item/613ad33f44eaada7396ef65b.jpg"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis的List与常规说的列表有所不同，一般来说列表是单口的，即.append()只能在列表尾添加元素。但是Redis的List是双口的，能在列表首尾添加元素。而且元素的取存是和堆栈一致的。</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/lists-blpop.html">BLPOP key1 [key2 …] timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/lists-brpop.html">BRPOP key1 [key2 …] timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left"><strong>3</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a> 通过索引获取列表中的元素</td></tr><tr><td align="left"><strong>5</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</strong></td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a> 获取列表长度</td></tr><tr><td align="left"><strong>7</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a> 移出并获取列表的第一个元素</strong></td></tr><tr><td align="left"><strong>8</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-lpush.html">LPUSH key value1 [value2 …]</a> 将一个或多个值插入到列表头部</strong></td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td align="left"><strong>10</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a> 获取列表指定范围内的元素</strong></td></tr><tr><td align="left"><strong>11</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a> 移除列表count个相同元素</strong></td></tr><tr><td align="left"><strong>12</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a> 通过索引设置列表元素的值</strong></td></tr><tr><td align="left"><strong>13</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</strong></td></tr><tr><td align="left"><strong>14</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</strong></td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td align="left">16</td><td align="left"><strong><a href="https://www.runoob.com/redis/lists-rpush.html">RPUSH key value1 [value2 …]</a> 在列表中添加一个或多个值</strong></td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a> 为已存在的列表添加值</td></tr></tbody></table><ul><li><img src="https://pic.imgdb.cn/item/613b092f44eaada739bfd20f.jpg"></li></ul><p>LPUSH相当于堆栈的FILO原则，RPUSH相当于队列的FIFO原则</p><ul><li><img src="https://pic.imgdb.cn/item/613b107544eaada739caddce.jpg"></li></ul><p>AFTER是队列右端插入元素，BEFORE是往队列左端插入元素</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>和Java的Set一样，Set是一个<strong>无序不重复集合</strong>，因而Set不能通过下标指定获取元素，但可以用作随机数集合。</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/sets-sadd.html">SADD key member1 [member2 …]</a> 向集合添加一个或多个成员</td></tr><tr><td align="left"><strong>2</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a> 获取集合的成员数</strong></td></tr><tr><td align="left">3</td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF key1 [key2 …]</a> 返回第一个集合与其他集合之间的差异。</strong></td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/sets-sdiffstore.html">SDIFFSTORE destination key1 [key2 …]</a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left"><strong>5</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-sinter.html">SINTER key1 [key2  …]</a> 返回给定所有集合的交集</strong></td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/sets-sinterstore.html">SINTERSTORE destination key1 [key2 …]</a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left"><strong>7</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</strong></td></tr><tr><td align="left"><strong>8</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a> 返回集合中的所有成员</strong></td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td align="left"><strong>10</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a> 移除并返回集合中的一个随机元素</strong></td></tr><tr><td align="left"><strong>11</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-srandmember.html">SRANDMEMBER key [count …]</a> 返回集合中一个或多个随机数</strong></td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/sets-srem.html">SREM key member1 [member2 …]</a> 移除集合中一个或多个成员</td></tr><tr><td align="left"><strong>13</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sets-sunion.html">SUNION key1 [key2 …]</a> 返回所有给定集合的并集</strong></td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/sets-sunionstore.html">SUNIONSTORE destination key1 [key2 …]</a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/redis/sets-sscan.html">SSCAN key cursor [MATCH pattern …] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left"><strong>1</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1 [field2 …]</a> 删除一个或多个哈希表字段</strong></td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hexists.html">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td align="left"><strong>4</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</strong></td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a> 获取所有哈希表中的字段</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a> 获取哈希表中字段的数量</td></tr><tr><td align="left"><strong>9</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/hashes-hmget.html">HGET key field1 [field2 …]</a> 获取所有给定字段的值</strong></td></tr><tr><td align="left"><strong>10</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/hashes-hmset.html">HSET key field1 value1 [field2 value2  …]</a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</strong></td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a> 获取哈希表中所有值。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/redis/hashes-hscan.html">HSCAN key cursor [MATCH pattern …] [COUNT count]</a> 迭代哈希表中的键值对。</td></tr></tbody></table><ul><li><p>HMGET和HMSET在Redis 4.0.0后被官方废弃，其功能和HSET，HGET一致。</p></li><li><p>HGETALL可以获取key-value，HKEYS只能获取key，HVALS只能获取value</p></li></ul><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>Zset相比于Set，是个有序的无重复集合，Zset的主要方法用来排列集合数据</p><p>Zset存储的数据结构也与Set不一样，类似于value-key的结构，这样就可以通过key来定向获取分数了。</p><table><thead><tr><th align="left">序号</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD key score1 member1 [score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td align="left"><strong>3</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</strong></td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left"><strong>5</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">ZINTERSTORE destination numkeys key [key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</strong></td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left"><strong>7</strong></td><td align="left"><strong><a href="https://redis.io/commands/zrange">ZRANGE key min max [BYSCORE|BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</a>通过索引区间返回有序集合指定区间内的成员</strong></td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM key member [member …]</a> 移除有序集合中的一个或多个成员</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td align="left"><strong>19</strong></td><td align="left"><strong><a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">ZUNIONSTORE destination numkeys key [key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</strong></td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/redis/sorted-sets-zscan.html">ZSCAN key cursor [MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr><tr><td align="left"><strong>21</strong></td><td align="left"><strong>ZRANDMEMBER key [count [WITHSCORES]] 随机获取集合中count个member</strong></td></tr></tbody></table><ul><li><p>Zset会自动对内部的数据进行<strong>递增的排序</strong></p></li><li><p>ZRANGE是个功能齐全的方法，能够替代之前的<a href="https://redis.io/commands/zrevrange">ZREVRANGE</a>, <a href="https://redis.io/commands/zrangebyscore">ZRANGEBYSCORE</a>, <a href="https://redis.io/commands/zrevrangebyscore">ZREVRANGEBYSCORE</a>, <a href="https://redis.io/commands/zrangebylex">ZRANGEBYLEX</a> and <a href="https://redis.io/commands/zrevrangebylex">ZREVRANGEBYLEX</a>.</p></li><li><p><code>ZRANGE key min max</code>是以下标为截取范围如<code>ZRANGE key 0 -1</code>截取第一个到倒数第一个。</p></li><li><p><code>ZRANGE key min max BYSCORE</code>是以分数为截取范围，如<code>ZRANGE key -inf +inf BYSCORE</code>截取负无穷到正无穷</p></li><li><p><code>ZRANGE key min max BYLEX</code>是以字典顺序为截取范围，且只以member在字典的顺序为排序（此模式下要求最好所有member的分数都要一致，否则返回的结果不可预测）</p><p><img src="https://pic.imgdb.cn/item/613c72ef44eaada739deef13.jpg" alt="Zset是以分数排序，因而a排在最后"></p><blockquote><p>因为BYLEX只看member在字典的顺序，而a排在最后面违反了Zset递增排序的规则，这样BYLEX查询就会出错。</p></blockquote><p>对于<code>ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g</code>而言，<code>ZRANGE myzset - + BYLEX</code>截取所有member。<code>ZRANGE myset (a [d BYLEX</code>返回b、c、d</p></li><li><p><code>ZRANGE key max min REV</code>会以降序返回，但注意范围是max min。</p></li><li><p><code>ZRANGE key min max WITHSCORES</code>会将member和score一起返回，默认只返回member。</p></li><li><p><code>ZCOUNT key min max</code>是基于分数为截取范围，<code>ZLEXCOUNT key min max</code>才是基于字典顺序为截取范围。</p></li></ul><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td>GEOADD key  longitude latitude member [longitude latitude member …] 添加地理位置</td></tr><tr><td>2</td><td>GEOPOS key member [member …] 获取地点的经纬</td></tr><tr><td>3</td><td>ZREM key member [member …] Geo没有专门的删除方法，但Geo也是一个Zset。</td></tr><tr><td><strong>4</strong></td><td><strong>GEODIST key member1 member2 [m|km|ft|mi] 测量两地点之间的直线距离</strong></td></tr><tr><td>5</td><td>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key] 获取离特定点radius距离内的所有地点，并按从近到远排列输出</td></tr><tr><td>6</td><td>[GEOSEARCH key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] <a href="https://redis.io/commands/geosearch">COUNT count [ANY] ] [WITHCOORD] [WITHDIST]</a> 寻找count个以member或指定坐标为中心的圆形/方形范围内的地点。</td></tr></tbody></table><ul><li><p>GEOADD china:city 121.47 31.23 shanghai 116.40 39.90 beijing 106.50 29.53 chongqing 114.05 22.52 shenzhen 120.16 30.24 hangzhou</p></li><li><p><strong>有效经度为 -180 到 180 度。有效纬度是从 -85.05112878 到 85.05112878 度。</strong></p></li><li><p>GEORADIUS在Redis 6.2.0已经被弃用，代替的是 <a href="https://redis.io/commands/geosearch">GEOSEARCH</a> 和<a href="https://redis.io/commands/geosearchstore">GEOSEARCHSTORE</a></p></li><li><p>FROMMEMBER:使用给定的&lt;成员&gt;在已排序集合中的位置。<br>FROMLONLAT:使用给定的&lt;经度&gt;和&lt;纬度&gt;位置。<br>BYRADIUS:类似于GEORADIUS，根据给定的<code>&lt;radius&gt;</code>搜索圆形区域内。<br>BYBOX:在轴对齐的矩形内搜索，由<code>&lt;height&gt;</code>和<code>&lt;width&gt;</code>决定。<br>COUNT:在返回结果中截取前COUNT个元素,如果开启ANY选项，直到找到足够的匹配项就直接返回。否则会全部找完再进行排序。<br>WITHCOORD:将地点的经纬同时返回<br>WITHDIST：将地点与中心点的距离也返回，距离单位与搜寻范围的距离单位一致</p></li></ul><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://redis.io/commands/pfadd">PFADD key element [element …]</a> 添加一组元素</td></tr><tr><td>2</td><td><a href="https://redis.io/commands/pfcount">PFCOUNT key [key …]</a> 返回所有key集合交集的基数</td></tr><tr><td>3</td><td>PFMERGE destkey sourcekey [sourcekey …] 合并sourcekey并存到destkey</td></tr></tbody></table><ul><li>PFADD如果添加了已有的元素，重复的元素将被阻止添加。</li><li>PFCOUNT计算集合的基数<strong>（集合中不重复的元素个数）</strong>，当PFCOUNT用单个键调用时，因为PFCOUNT使用缓存来记住之前计算的基数，而基数很少改变，故而计算时间很短。当使用多个键调用PFCOUNT时，会执行HyperLogLogs的动态合并，而且无法缓存合并的基数，故而计算时间较长。</li></ul><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td>SETBIT key offset value 在offset偏移处设置0/1</td></tr><tr><td>2</td><td>GETBIT key offset 获取offset的bit位</td></tr><tr><td>3</td><td>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</td></tr><tr><td>4</td><td>BITCOUNT key [start end] 统计bit位为1的位数</td></tr><tr><td>5</td><td>BITOP AND|OR|XOR destkey key [key …] 将所有key进行位运算并存储结果到destkey<br />BITOP NOT destkey srckey</td></tr></tbody></table><ul><li>Bitmap并不是一个特殊的数据结构，可以看作是字符串类型。因而bitmap也能使用GET、SET方法。</li><li>SETBIT设置了一个高bit位的值后，Bitmap会自动增长以确保能在offset处保持位，未被设置的位则默认为0。offset参数要求大于或等于0，并且小于2^32^(这将Bitmap限制为512MB)</li></ul><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis事物本质是一组命令的集合，在事务的执行过程中会按照顺序执行。Redis事务是<strong>一次性、顺序性、排他性</strong>的。</p><p><strong>但注意，Redis事务没有隔离级别的概念，而Redis命令是保持原子性的，但事务本身不保证原子性！</strong></p><blockquote><p>事务执行</p></blockquote><ol><li><p>MULTI（开启事务）</p></li><li><p>SET、GET … （命令入队）</p></li><li><p>EXEC （执行事务）</p></li></ol><blockquote><p>事务出现编译异常</p></blockquote><p>Redis命令如果出现了语法错误，当其尝试入队时Redis会提示错误。最后运行时整个事务都会被阻止。</p><blockquote><p>运行时异常</p></blockquote><p>Redis命令如果操作了不得当数据，如自增字符串，用Hash命令操作List、String等，执行事务时正常命令可以照样执行，错误命令则抛出异常。</p><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>通过Jedis连接远程服务器的Redis：</p><p>建立maven项目，导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创立代码文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.levi;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJedis</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;47.101.160.130&quot;</span>, <span class="hljs-number">6379</span>);<br>        System.out.println(jedis.ping());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改变Redis配置（备份在/usr/local/bin/leviconfig/redis.conf），允许远程连接：</p><p>注释掉bind，protected-mode为no</p><p><img src="https://img2020.cnblogs.com/blog/757087/202012/757087-20201225094304067-242192253.png" alt="img"></p><p>防火墙开启6379端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=6379/tcp --permanent<br><span class="hljs-meta">#</span><span class="bash">重新加载并查看开放的端口号</span><br>firewall-cmd --reload<br>firewall-cmd --permanent --zone=public --list-ports<br></code></pre></td></tr></table></figure><p>阿里云开放安全组6379端口</p><p>以上完成后执行Java代码即可看到PONG的输出。</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis数据库是存在于内存中的，具有<strong>断电即失</strong>的特点，因而Redis持久化数据很重要</p><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><p>通过拍摄快照的方式实现持久化，将某个时间的内存数据存储在一个rdb文件中，在redis服务重新启动的时候加载文件中的数据</p><p><img src="https://pic.imgdb.cn/item/6141b0192ab3f51d91da2f23.png"></p><p>Redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，带持久化过程结束了，再用该临时文件替换上次持久化好的文件。整个持久化的过程中，主进程不进行任何IO操作，创建子进程后主进程仍然可以响应Client请求。</p><p>如果需要进行<strong>大规模数据的恢复，且对于数据恢复的完整性不是很敏感</strong>的话，RDB比AOF方式更为有效。</p><p>RDB的缺点就是<strong>最后一次持久化后的数据可能会丢失</strong>。</p><h3 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h3><p>以下是Redis配置文件关于RDB的默认配置值。</p><p><img src="https://pic.imgdb.cn/item/6141b2542ab3f51d91dc2b2f.jpg"></p><blockquote><p>RDB触发条件</p></blockquote><p>1、 满足save 900 1 的条件</p><p>2、 执行了bgasve/save命令，bgsave不会阻塞主进程，而save会</p><p>3、 shutdown退出Redis/flush清除数据</p><p>注：FLUSHALL生成的rdb/aof文件是能储存flush之前的数据的：<a href="https://www.cnblogs.com/lizexiong/p/14730747.html">Redis的flushall/flushdb误操作 - 小家电维修 - 博客园 (cnblogs.com)</a></p><blockquote><p>RDB恢复快照</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; CONFIG GET dir<br>1) &quot;dir&quot;<br>2) &quot;/usr/local/bin&quot;<br></code></pre></td></tr></table></figure><p>只要dump.rdb保留在/usr/local/bin（默认在redis-server同级目录），重新启动redis就能重载备份数据。</p><blockquote><p>FLUSHALL后恢复RDB数据</p></blockquote><p><a href="https://www.cnblogs.com/dalianpai/p/12539396.html">Redis使用rdb文件恢复数据 - 天宇轩-王 - 博客园 (cnblogs.com)</a></p><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>AOF文件能够将我们的操作记录下来，在redis启动的时候会顺序执行记录的写命令。这种方式明显就不适合大量数据的存储了，但能很好地防止Flush的误操作恢复备份。</p><p><img src="https://pic.imgdb.cn/item/6141bf9d2ab3f51d91f946ab.jpg"></p><h3 id="Redis-conf-1"><a href="#Redis-conf-1" class="headerlink" title="Redis.conf"></a>Redis.conf</h3><p><img src="https://pic.imgdb.cn/item/6141bfd22ab3f51d91f9e84e.jpg"></p><blockquote><p>AOF触发条件</p></blockquote><p>appendfsync默认是每秒触发，即每秒记录一次写操作。</p><blockquote><p>AOF修复</p></blockquote><p>AOF可能因为电脑宕机导致文件破损，使用<code>redis-check-aof --fix</code>就可以修复AOF文件，修复方式就是删去出错的写操作。<strong>如果AOF没有被修复，那么Redis是无法开启的</strong>。</p><blockquote><p>FLUSH后恢复AOF数据</p></blockquote><p><a href="https://blog.csdn.net/qq_34556414/article/details/107427209">Redis AOF之执行flushdb或flushall之后的后悔药_小楼一夜听春雨，深巷明朝卖杏花-CSDN博客</a></p><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在同一台服务器上搭建一主二从的拟集群环境，建立三分Redis配置文件，分别为redis79.conf,redis80.conf,redis81.conf</p><p><a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=31">【狂神说Java】Redis集群环境搭建</a></p><p>搭建好后进入redis，会发现每一台redis都是主节点。因为<strong>默认情况下每个节点都是主节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:master<br>connected_slaves:0<br>master_failover_state:no-failover<br>master_replid:a3d4f6b6132911f4933991b2f6b3b69cc5aeb40a<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure><p>选择一个作为从机通过<code>SLAVEOF 127.0.0.1 6379</code>就能指定主机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379<br>OK<br>127.0.0.1:6380&gt; info replication<br><span class="hljs-meta">#</span><span class="bash"> Replication</span><br>role:slave<br>master_host:127.0.0.1<br>master_port:6379<br>master_link_status:up<br>master_last_io_seconds_ago:7<br>master_sync_in_progress:0<br>slave_repl_offset:28<br>slave_priority:100<br>slave_read_only:1<br>replica_announced:1<br>connected_slaves:0<br>master_failover_state:no-failover<br>master_replid:32cde58052534f54c17c79fe0728a522c19e1377<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:28<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:28<br></code></pre></td></tr></table></figure><blockquote><p>实际情况下要通过配置文件设置主从关系，更改从机配置文件的<code>relicaof &lt;masterip&gt; &lt;masterport&gt;</code>与<code>masterauth &lt;master-password&gt;</code></p></blockquote><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>整个集群中只有主机有读写功能，而从机没有写功能。从机共享主机资源，可以备份数据。</p></li><li><p>主机宕机且不配置哨兵模式时，如果主机宕机退出，从机依然依附原主机。但此时整个集群都不能做写操作！！</p></li><li><p>从机宕机后重连。除非配置文件中设置了主从关系，否则该机器脱离集群！！当然也可通过SLAVEOF进入集群。</p></li></ul><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><p>从机连接到集群后会像主机发送sync同步请求，主机接收后启动后台存盘进程，同时从机所有接收到的用于修改数据集的命令，在后台进程执行完毕后，主机同步所有数据文件到从机。</p><p>==全量复制==：从机接收到数据文件后，将其存盘并加载至内存</p><p>==增量复制==：后续主机会将新的数据依次传递给从机</p><p>只要从机连接到集群，就会自动完成一次<strong>全量复制</strong></p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/11320039-57a77ca2757d0924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp" alt="单哨兵"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>用文字描述一下多哨兵<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><p><img src="https://upload-images.jianshu.io/upload_images/11320039-3f40b17c0412116c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp" alt="多哨兵"></p><h3 id="单哨兵"><a href="#单哨兵" class="headerlink" title="单哨兵"></a>单哨兵</h3><p>创建哨兵配置文件<code>sentinel.conf</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 禁止保护模式(多服务器)</span><br>protected-mode no<br><span class="hljs-meta">#</span><span class="bash"> 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，</span><br><span class="hljs-meta">#</span><span class="bash">192.168.11.128代表监控的主服务器，6379代表端口，1代表只有一个或一个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br>sentinel monitor mymaster 127.0.0.1 6379 1<br><span class="hljs-meta">#</span><span class="bash"> sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span><br>sentinel auth-pass mymaster 123456<br></code></pre></td></tr></table></figure><p>启动哨兵，哨兵启动成功后会更新<code>sentinel.conf</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@Levi bin]$ redis-sentinel sentinel.conf <br>2771847:X 15 Sep 2021 22:04:41.712 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo<br>2771847:X 15 Sep 2021 22:04:41.712 # Redis version=6.2.5, bits=64, commit=00000000, modified=0, pid=2771847, just started<br>2771847:X 15 Sep 2021 22:04:41.712 # Configuration loaded<br>2771847:X 15 Sep 2021 22:04:41.713 * monotonic clock: POSIX clock_gettime<br>                _._                                                  <br>           _.-``__ &#x27;&#x27;-._                                             <br>      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 6.2.5 (00000000/0) 64 bit<br>  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                  <br> (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode<br> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26379<br> |    `-._   `._    /     _.-&#x27;    |     PID: 2771847<br>  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   <br> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  <br> |    `-._`-._        _.-&#x27;_.-&#x27;    |           https://redis.io       <br>  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   <br> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  <br> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  <br>  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   <br>      `-._    `-.__.-&#x27;    _.-&#x27;                                       <br>          `-._        _.-&#x27;                                           <br>              `-.__.-&#x27;                                               <br><br>2771847:X 15 Sep 2021 22:04:41.717 # Sentinel ID is 752d9dbfe066f2ec0206227c0be60f8500478a50<br>2771847:X 15 Sep 2021 22:04:41.717 # +monitor master mymaster 127.0.0.1 6379 quorum 1<br>2771847:X 15 Sep 2021 22:04:41.717 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379#发现了两个从机<br>2771847:X 15 Sep 2021 22:04:41.720 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br><br></code></pre></td></tr></table></figure><p>宕机主机，哨兵确认宕机后会投票选取一个从机为新的主机，相关日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">2771847:X 15 Sep 2021 22:09:49.686 # +sdown master mymaster 127.0.0.1 6379##察觉到主机宕机<br>2771847:X 15 Sep 2021 22:09:49.686 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1##确认宕机<br>2771847:X 15 Sep 2021 22:09:49.686 # +new-epoch 1<br>2771847:X 15 Sep 2021 22:09:49.686 # +try-failover master mymaster 127.0.0.1 6379##开始选举<br>2771847:X 15 Sep 2021 22:09:49.689 # +vote-for-leader 752d9dbfe066f2ec0206227c0be60f8500478a50 1##752d9db号哨兵发起投票<br>2771847:X 15 Sep 2021 22:09:49.689 # +elected-leader master mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:49.689 # +failover-state-select-slave master mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:49.780 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379##投票给127.0.0.1:6381<br>2771847:X 15 Sep 2021 22:09:49.780 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:49.838 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:49.991 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379##确认127.0.0.1:6381为新主机<br>2771847:X 15 Sep 2021 22:09:49.991 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:50.059 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:51.059 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:51.059 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:51.130 # +failover-end master mymaster 127.0.0.1 6379<br>2771847:X 15 Sep 2021 22:09:51.130 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6381##更改127.0.0.1:6381配置，成为新主机<br>2771847:X 15 Sep 2021 22:09:51.130 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6381##更改从机配置文件<br>2771847:X 15 Sep 2021 22:09:51.130 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381<br>2771847:X 15 Sep 2021 22:10:21.132 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381<br></code></pre></td></tr></table></figure><p>即使原主机回来，也只能成为新主机的从机。</p><h3 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Example sentinel.conf</span>  <br><br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel实例运行的端口 默认26379</span>  <br>port 26379  <br>  <br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel的工作目录</span>  <br>dir /tmp  <br>  <br><span class="hljs-meta">#</span><span class="bash"> 哨兵sentinel监控的redis主节点的 ip port</span>   <br><span class="hljs-meta">#</span><span class="bash"> master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符<span class="hljs-string">&quot;.-_&quot;</span>组成。</span>  <br><span class="hljs-meta">#</span><span class="bash"> quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span>  <br><span class="hljs-meta">#</span><span class="bash"> sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>  <br>  sentinel monitor mymaster 127.0.0.1 6379 2  <br>  <br><span class="hljs-meta">#</span><span class="bash"> 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span>  <br><span class="hljs-meta">#</span><span class="bash"> 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span>  <br><span class="hljs-meta">#</span><span class="bash"> sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>  <br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  <br><br><span class="hljs-meta">#</span><span class="bash"> 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span>  <br><span class="hljs-meta">#</span><span class="bash"> sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>  <br>sentinel down-after-milliseconds mymaster 30000  <br>  <br><span class="hljs-meta">#</span><span class="bash"> 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，</span>  <br><span class="hljs-meta">#</span><span class="bash">这个数字越小，完成failover所需的时间就越长，</span><br><span class="hljs-meta">#</span><span class="bash">但是如果这个数字越大，就意味着越多的slave因为failover而不可用。</span><br><span class="hljs-meta">#</span><span class="bash">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="hljs-meta">#</span><span class="bash"> sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br> <br><span class="hljs-meta">#</span><span class="bash"> 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span>   <br><span class="hljs-meta">#</span><span class="bash">1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span>  <br><span class="hljs-meta">#</span><span class="bash">2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span>  <br><span class="hljs-meta">#</span><span class="bash">3.当想要取消一个正在进行的failover所需要的时间。</span>    <br><span class="hljs-meta">#</span><span class="bash">4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span>  <br><span class="hljs-meta">#</span><span class="bash"> 默认三分钟</span>  <br><span class="hljs-meta">#</span><span class="bash"> sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>  <br>sentinel failover-timeout mymaster 180000  <br>  <br><span class="hljs-meta">#</span><span class="bash"> SCRIPTS EXECUTION</span>  <br>  <br><span class="hljs-meta">#</span><span class="bash">配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span>  <br><span class="hljs-meta">#</span><span class="bash">对于脚本的运行结果有以下规则：</span>  <br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span>  <br><span class="hljs-meta">#</span><span class="bash">若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span>  <br><span class="hljs-meta">#</span><span class="bash">如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span>  <br><span class="hljs-meta">#</span><span class="bash">一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span>  <br>  <br><span class="hljs-meta">#</span><span class="bash">通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span>  <br><span class="hljs-meta">#</span><span class="bash">这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span>  <br><span class="hljs-meta">#</span><span class="bash">一个是事件的类型，一个是事件的描述。</span>  <br><span class="hljs-meta">#</span><span class="bash">如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span>   <br><span class="hljs-meta">#</span><span class="bash"> sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>  <br>  sentinel notification-script mymaster /var/redis/notify.sh  <br>  <br><span class="hljs-meta">#</span><span class="bash"> 客户端重新配置主节点参数脚本</span>  <br><span class="hljs-meta">#</span><span class="bash"> 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span>  <br><span class="hljs-meta">#</span><span class="bash"> 以下参数将会在调用脚本时传给脚本:</span>  <br><span class="hljs-meta">#</span><span class="bash"> &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span>  <br><span class="hljs-meta">#</span><span class="bash"> 目前&lt;state&gt;总是“failover”,</span>  <br><span class="hljs-meta">#</span><span class="bash"> &lt;role&gt;是“leader”或者“observer”中的一个。</span>   <br><span class="hljs-meta">#</span><span class="bash"> 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span>  <br><span class="hljs-meta">#</span><span class="bash"> 这个脚本应该是通用的，能被多次调用，不是针对性的。</span>  <br><span class="hljs-meta">#</span><span class="bash"> sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span>  <br> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <br></code></pre></td></tr></table></figure><h1 id="Redis击穿和雪崩"><a href="#Redis击穿和雪崩" class="headerlink" title="Redis击穿和雪崩"></a>Redis击穿和雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://pic.imgdb.cn/item/6142ae792ab3f51d91b28467.jpg" alt="绕过缓存直接攻击数据库"></p><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。</p><p>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><p>==解决方案：==</p><ul><li><strong>缓存空对象</strong></li></ul><p>如果数据库中找不到，就会返回一个空值储存到缓存中，并设置过期时间。在有效期内，所有相同key的请求都能在缓存中找到值。</p><ul><li><strong>布隆过滤器</strong></li></ul><p>布隆过滤器对可能的参数以hash形式储存，其他不合理的请求会被丢弃，从而避免直接对数据库的施压。</p><p>==隐患：==</p><p>但如果大量不同的key都找不到数据，就会导致缓存中存有大量无效的空值，从而降低性能。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>当某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p>==解决方案：==</p><ul><li><strong>设置key永不过期</strong></li></ul><p>这种方式可以说是最可靠的，最安全的但是占空间，内存消耗大，并且不能保持数据最新 这个需要根据具体的业务逻辑来做。但也可以隔段时间便去数据库更新数据，此时要求不会给数据库很大的压力。</p><ul><li><strong>使用互斥锁</strong></li></ul><p>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用某些一定能成功返回值的操作（比如Redis的SETNX）去set一个mutex key（一个特定的key，当成竞争资源），当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法</p><p>站在用户层面，但key失效时用户获取的就是空页面。因此只需要多刷新几次，等待缓存恢复正常就能获取到正常页面了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(key)</span> </span>&#123;<br>    String value = redis.get(key);<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//代表缓存值过期</span><br>        <span class="hljs-comment">//设置3min的超时，防止del操作前程序出误，导致锁一直不能被释放</span><br>        <span class="hljs-keyword">if</span> (redis.setnx(key_mutex, <span class="hljs-number">1</span>, <span class="hljs-number">3</span> * <span class="hljs-number">60</span>) == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">//说明此时获得了锁</span><br>            value = db.get(key);<br>            redis.set(key, value, expire_secs);<span class="hljs-comment">//设置key的存在时间，避免出现key永不过期的现象</span><br>            redis.del(key_mutex);<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//等待一段时间后，持锁线程已经完成load db，故而重试get即可。</span><br>            sleep(<span class="hljs-number">50</span>);<br>            get(key);  <span class="hljs-comment">//重试</span><br>        &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> value;      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>redis.set(key, value, expire_secs)</code>是有讲究的，如果在SETNX和EXPIRE分开操作，但两者之间程序又发生了错误，当前锁又无法释放，key成为了永不过期。所以根本原因还是需要一个原子的操作，在获得锁的同时能够同时设置锁的过期时间。</p></blockquote><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><p><img src="https://pic.imgdb.cn/item/6142b9ea2ab3f51d91c11d63.jpg" alt="缓存失效，大量请求攻击数据库"></p><p>==解决方案：==</p><ul><li><strong>Redis高可用</strong></li></ul><p>有预知地在流量集中爆发的时间段前，扩大缓存集群（如暂停其他服务）来应付集中的请求，以此避免全盘崩溃</p><ul><li><strong>ehcache 缓存 + hystrix 限流&amp;降级</strong></li></ul><p>在缓存失效后，通过加锁或是限制队列长度的方式控制流量，避免数据库被直接打死。</p><ul><li><strong>数据预热</strong></li></ul><p>有预知地让缓存去数据库访问一遍可能会被集中访问的key，在大并发访问之前手动触发加载缓存的预热key。</p><h1 id="Redis应用"><a href="#Redis应用" class="headerlink" title="Redis应用"></a>Redis应用</h1><h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><ul><li>对于具有时效性的业务功能如验证码，订单有效期</li><li>redis分布式集群系统可以用作Session共享</li><li>redis的zset类型可用作实时排行榜</li><li>redis的setnx用作分布式锁</li><li>分布式缓存  </li></ul><h2 id="Redis过期策略及内存淘汰"><a href="#Redis过期策略及内存淘汰" class="headerlink" title="Redis过期策略及内存淘汰"></a>Redis过期策略及内存淘汰</h2><p>Redis对于过期数据或溢出内存后进行淘汰数据的策略可概括为<strong>定期删除+惰性删除</strong></p><p><strong>为什么不用定时删除策略?</strong><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p><h3 id="定期删除和惰性删除"><a href="#定期删除和惰性删除" class="headerlink" title="定期删除和惰性删除"></a>定期删除和惰性删除</h3><p>定期删除，redis默认每个100ms随机抽取key进行检查，如果key过期则删除。但只采用定期删除，可能会导致很多过期key无法被检查到。</p><p>惰性删除，当获取某一key时，如果该key设置了过期时间，再检查是否过期，过期了才会删除。</p><p>但如果有一过期key没有被检查到，也没有被使用上，即绕开了定期删除与惰性删除的机制。这种key就会一直堆积在内存中，就需要引入<strong>内存淘汰机制</strong>。</p><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p>redis.conf中可以配置内存淘汰机制，当内存不足以纳入新的数据时就会触发机制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">maxmemory-policy allkeys-lru<br></code></pre></td></tr></table></figure><ul><li><code>allkeys-lru</code>：在键空间中，优先淘汰最近最少使用的key</li><li><code>noeviction</code>：写入新数据时会报错。</li><li><code>allkeys-random</code>：在键空间中，随机移除某一key</li><li><code>volatile-lru</code>：在设置了过期时间的键空间中，优先淘汰最近最少使用的key</li><li><code>volatile-random</code>：在设置了过期时间的键空间中，随机移除某一key</li><li><code>volatile-ttl</code>：在设置了过期时间的键空间中，优先淘汰TTL设置得更早的key</li></ul><h2 id="Redis与数据库一致性问题"><a href="#Redis与数据库一致性问题" class="headerlink" title="Redis与数据库一致性问题"></a>Redis与数据库一致性问题</h2><p>当数据库和缓存双写，必定会存在不一致的问题。为了解决这一问题，我们可以采用双删+TTL失效来实现，但这也只能保证数据的<strong>最终一致性</strong>。如果对数据有<strong>强一致性</strong>的要求，就不能设置缓存！！！</p><p>数据库和缓存更新，就容易出现缓存和数据库间的数据一致性问题。不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举个例子：</p><ol><li>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中依然为脏数据。</li><li>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li></ol><hr><p>为了解决一致性问题，普遍有以下四种方式（为简述方便，对于每一种方法的两步分别以1，2标识，如写进程A的两步分别为A1，A2）：</p><ol><li>先更新数据库，再更新缓存</li><li>先更新缓存，再更新数据库</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li></ol><p>==<strong>先更新数据库，再更新缓存</strong>==</p><p>对于写进程A，B，执行顺序为A1-B1-B2-A1，这样缓存中的数据还是A的数据，数据出现不一致。</p><p>==<strong>先更新缓存，再更新数据库</strong>==</p><p>对于写进程A，A2在A1后执行失败，数据依旧不一致。</p><p><em>其实，通过更新缓存来同步数据库数据的两种方式都有以下两个问题：</em></p><ol><li><em>对于写操作频繁的场景，缓存的数据时刻都在更新，浪费性能</em></li><li><em>如果真正需要写入缓存的数据是要进入数据库后再演算出来的，那么先更新缓存，所更新的数据也是错误的。</em></li></ol><p><em>那么，通过懒加载的方式（删除缓存）同步数据库数据更佳</em></p><hr><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><blockquote><p>当数据库中的数据更新/删除时选择<strong>删除缓存中的数据</strong>，删除后不更新新数据到缓存中，直到查询的时候没命中缓存，访问数据库后再添加至缓存</p></blockquote><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98a4b375d0444e589b217a94065219aa~tplv-k3u1fbpfcp-watermark.awebp" alt="Redis懒加载缓存.png" style="zoom:50%;" /><p>在懒加载的概念下，我们讨论后两种方式：先删除缓存，再更新数据库/先更新数据库，再删除缓存</p><p>==<strong>先删除缓存，再更新数据库</strong>==</p><ol><li>线程 A 要更新 X = 2（数据库中 X = 1）</li><li>线程 A 先删除缓存</li><li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li><li>线程 A 将新值写入数据库（X = 2）</li><li>线程 B 将旧值写入缓存（X = 1）</li></ol><p>缓存中依然留的是旧值。这还是一个数据库出现的问题，如果在<strong>主从库</strong>的环境下：</p><ol><li>线程 A 更新主库 X = 2（原值 X = 1）</li><li>线程 A 删除缓存</li><li>线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）</li><li>从库「同步」完成（主从库 X = 2）</li><li>线程 B 将「旧值」写入缓存（X = 1）</li></ol><p>为了解决以上两个问题，业界给出了<strong>延迟双删</strong>的答案：</p><h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3><p>1）先删除缓存；</p><p>2）再写数据库；</p><p>3）触发异步写入串行化MQ（也可以采取一种key+version的分布式锁）；</p><p>4）MQ接受再次删除缓存。</p><p>两次删除的目的是防止在1）到 2）的过程中读操作访问缓存，从而把还未更新的数据由存到了缓存中去。延迟删除就保证了此后缓存中的数据是最新的。</p><p><strong>但是！！双删依旧存在问题！！</strong></p><p>1、A删除缓存</p><p>2、B查询数据库获取旧值</p><p>3、B更新了缓存</p><p>4、A更新数据库</p><p>5、A延时删缓存</p><p>这种情况下，1-3步会让删除的旧缓存重新回来了，那么先删除缓存就没有任何意义。</p><p><strong>此外！！如果步骤3要晚于步骤5，以后的读操作读的还是旧缓存！！！（虽然可以加长延时长度来避免）</strong></p><hr><p><strong>==先更新数据库，再删除缓存==</strong></p><p>综上，该方式能应付大多并发请求。为了防止删除缓存程序宕机，可以<strong>设置缓存有效时间</strong>。</p><p>但这样更新数据库到删除缓存的这段时间内，缓存和数据库无法保证一致性。</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>对于==先删除缓存，再更新数据库==，其问题就是没能保证读应该在写之后发生，为此我们可以引用串行MQ来保证读写的顺序执行。</p><blockquote><ol><li>先删缓存，将更新数据库的操作放进有序队列中</li><li>如果缓存查不到，访问数据库和更新缓存的操作都进入有序队列</li></ol></blockquote><p>我们再考虑以下场景：</p><ol><li>线程 A 先删除缓存</li><li>线程 A 要更新 X = 2（数据库中 X = 1），<strong>更新数据库请求进入MQ</strong></li><li>线程 B 读缓存，发现不存在，<strong>读取数据库请求进入MQ</strong></li><li>MQ消费到更新数据库请求，线程 A 将新值写入数据库（X = 2）</li><li>MQ消费到读取数据库请求，线程 B 读取新值（X = 2）</li><li>MQ消费到更新缓存请求，线程 B更新缓存</li></ol><p>可以优化的一点是，当有多个连续更新缓存请求在MQ中，只需要保留最新的更新请求即可。</p><p><strong>但该方案依旧存在问题！！！</strong></p><ol><li>如果数据库更新频繁，缓存一直没有值，这就会导致大量读取数据库请求积压在MQ末端中，如果放行这些请求，数据库的压力会很大。</li><li><em>串行化虽然能保证不会出现数据不一致的问题，但是高并发更新操作场景下，读操作被推迟，严重降低系统吞吐量，影响客户体验。</em></li></ol><hr><h3 id="重发"><a href="#重发" class="headerlink" title="重发"></a>重发</h3><p>==消息队列==</p><p>无论是先还是后操作数据库，两步没有全走完都会出现不一致的后果，为了保证请求能确保被完全执行，我们可以引入<strong>消息队列</strong>，原因有三：</p><ol><li>重发操作不能由业务层发起，这会严重干扰业务进行。同时如果执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。因此我们就需要在另一个服务中完成重发操作</li><li>消息队列能保证队列里的消息在成功被消费之前不会丢失</li><li>消息队列可以保证消息被成功传递，否则还会继续投递</li></ol><p><img src="https://pic1.zhimg.com/80/v2-3b7070cafdc1e61db131c3e203dbe72c_720w.jpg" alt="img"></p><p>==订阅Binlog==</p><p>当然业务层也可以不发起重发操作，因为更新数据库的时候会将信息写入binlog日志中，通过订阅该日志就能获取到key，之后发布删除操作到MQ中。常用的如<strong>阿里的Canal</strong></p><p><img src="https://pic3.zhimg.com/80/v2-c0c4adf727ee3fdb8d1086c369270932_720w.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在保证最终一致性的情况下，可以<strong>采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong>。</p><p>串行化能达到强一致性的，但会降低缓存的作用。</p><h2 id="Redis并发竞争key"><a href="#Redis并发竞争key" class="headerlink" title="Redis并发竞争key"></a>Redis并发竞争key</h2><p>如果多个子系统同时设置一个key，可以：</p><p>(1)如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，<strong>要求顺序</strong><br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">系统A key1 &#123;valueA  3:00&#125;<br>系统B key 1 &#123;valueB  3:05&#125;<br>系统C key 1 &#123;valueC  3:10&#125;<br></code></pre></td></tr></table></figure><p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;Linux安装&quot;&gt;&lt;a href=&quot;#Linux安装&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="后端" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://example.com/2021/09/03/Shiro/"/>
    <id>http://example.com/2021/09/03/Shiro/</id>
    <published>2021-09-03T03:21:26.000Z</published>
    <updated>2021-09-05T02:46:08.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro认证"><a href="#Shiro认证" class="headerlink" title="Shiro认证"></a>Shiro认证</h1><h2 id="1-认证"><a href="#1-认证" class="headerlink" title="1. 认证"></a>1. 认证</h2><p>　　身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。</p><h2 id="2-Shiro-中认证的关键对象"><a href="#2-Shiro-中认证的关键对象" class="headerlink" title="2. Shiro 中认证的关键对象"></a>2. Shiro 中认证的关键对象</h2><ul><li><strong>Subject 主体</strong>：访问系统的用户，主体可以是用户、程序等等，进行认证的都称为主体；</li><li><strong>Principal 身份信息</strong>：是主体（Subject）进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）</li><li><strong>Credential 凭证信息</strong>：是只有主体自己知道的安全信息，如密码、证书等。</li></ul><h2 id="3-认证流程"><a href="#3-认证流程" class="headerlink" title="3. 认证流程"></a>3. 认证流程</h2><p>​     <img src="https://img2020.cnblogs.com/blog/1543609/202105/1543609-20210528140636311-602953237.png" alt="img"></p><h2 id="4-认证开发"><a href="#4-认证开发" class="headerlink" title="4. 认证开发"></a>4. 认证开发</h2><h3 id="4-1-模拟数据库中已存储用户信息【创建-shiro-ini-文件】"><a href="#4-1-模拟数据库中已存储用户信息【创建-shiro-ini-文件】" class="headerlink" title="4.1 模拟数据库中已存储用户信息【创建 shiro.ini 文件】"></a>4.1 模拟数据库中已存储用户信息【创建 shiro.ini 文件】</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[users]</span><br><span class="hljs-attr">wangwu</span>=<span class="hljs-number">123</span><br><span class="hljs-attr">zhangsan</span>=<span class="hljs-number">123456</span><br><span class="hljs-attr">lisi</span>=<span class="hljs-number">789</span><br></code></pre></td></tr></table></figure><h3 id="4-2-开发认证代码"><a href="#4-2-开发认证代码" class="headerlink" title="4.2 开发认证代码"></a>4.2 开发认证代码</h3><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestAuthenticator &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 1. 创建安全管理器</span><br>        DefaultSecurityManager securityManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultSecurityManager()</span>;<br>        <span class="hljs-comment">// 2. 给安全管理器设置 realm 【Realm 需要获取用户认证的数据源信息】</span><br>        securityManager.set<span class="hljs-constructor">Realm(<span class="hljs-params">new</span> IniRealm(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>)</span>);<br>        <span class="hljs-comment">// 3. SecurityUtils 设置安全管理器</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">securityManager</span>)</span>;<br>        <span class="hljs-comment">// 4. 获取关键对象 Subject 主体</span><br>        Subject subject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Subject()</span>;<br>        <span class="hljs-comment">// 5. 创建令牌</span><br>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UsernamePasswordToken(<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)</span>;<br>        <span class="hljs-comment">// 用户认证</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;认证状态: &quot;</span> + subject.is<span class="hljs-constructor">Authenticated()</span>);<br>            subject.login(token);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;认证状态: &quot;</span> + subject.is<span class="hljs-constructor">Authenticated()</span>);<br>        &#125; catch (UnknownAccountException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;认证失败: 用户名不存在~&quot;</span>);<br>        &#125; catch (IncorrectCredentialsException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;认证失败: 密码错误~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DisabledAccountException（帐号被禁用）</li><li>LockedAccountException（帐号被锁定）</li><li>ExcessiveAttemptsException（登录失败次数过多）</li><li>ExpiredCredentialsException（凭证过期）</li></ul><h3 id="4-3-自定义-Realm"><a href="#4-3-自定义-Realm" class="headerlink" title="4.3 自定义 Realm"></a>4.3 自定义 Realm</h3><p>　　上边的程序使用的是 Shiro 自带的 IniRealm，IniRealm 从 shiro.ini 配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义 Realm。</p><h4 id="1）Shiro-自定义-Realm"><a href="#1）Shiro-自定义-Realm" class="headerlink" title="1）Shiro 自定义 Realm"></a>1）Shiro 自定义 Realm</h4><p>​     <img src="https://img2020.cnblogs.com/blog/1543609/202105/1543609-20210528143123698-1681567939.png" alt="img"></p><h4 id="2）根据认证源码使用的是-SimpleAccountRealm-【只保留认证和授权这两部分代码】"><a href="#2）根据认证源码使用的是-SimpleAccountRealm-【只保留认证和授权这两部分代码】" class="headerlink" title="2）根据认证源码使用的是 SimpleAccountRealm 【只保留认证和授权这两部分代码】"></a>2）根据认证源码使用的是 SimpleAccountRealm 【只保留认证和授权这两部分代码】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleAccountRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br>        <span class="hljs-comment">//.......省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        UsernamePasswordToken upToken = (UsernamePasswordToken) token;<br>        SimpleAccount account = getUser(upToken.getUsername());<br><br>        <span class="hljs-keyword">if</span> (account != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (account.isLocked()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedAccountException(<span class="hljs-string">&quot;Account [&quot;</span> + account + <span class="hljs-string">&quot;] is locked.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (account.isCredentialsExpired()) &#123;<br>                String msg = <span class="hljs-string">&quot;The credentials for account [&quot;</span> + account + <span class="hljs-string">&quot;] are expired&quot;</span>;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExpiredCredentialsException(msg);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> account;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        String username = getUsername(principals);<br>        USERS_LOCK.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.users.get(username);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            USERS_LOCK.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="3）自定义-Realm"><a href="#3）自定义-Realm" class="headerlink" title="3）自定义 Realm"></a>3）自定义 Realm</h4><p>　由于 <code>Realm </code>相当于 Datasource 数据源，SecurityManager 进行安全认证需要通过 Realm 获取用户身份数据，所以可以自定义 Realm 获取用户身份的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-comment">// 授权</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 认证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        String principal = (String) token.getPrincipal();<br>        System.out.println(<span class="hljs-string">&quot;principal = &quot;</span> + principal);<br>        <span class="hljs-comment">//根据身份信息使用jdbc mybatis查询相关数据库</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xiaochen&quot;</span>.equalsIgnoreCase(principal)) &#123;<br>            <span class="hljs-comment">// 参数1：返回数据库中的用户名  参数2：返回数据库中的正确密码  参数3：提供当前的 realm 名字，this.getName()</span><br>            SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-keyword">this</span>.getName());<br>            <span class="hljs-keyword">return</span> simpleAuthenticationInfo;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）使用自定义-Realm-进行认证"><a href="#4）使用自定义-Realm-进行认证" class="headerlink" title="4）使用自定义 Realm 进行认证"></a>4）使用自定义 Realm 进行认证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCustomerRealm</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.创建安全管理器</span><br>        DefaultSecurityManager defaultSecurityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager();<br><br>        <span class="hljs-comment">// 2.给安全管理器设置 realm 【数据库中获取用户名和密码】</span><br>        defaultSecurityManager.setRealm(<span class="hljs-keyword">new</span> CustomerRealm());<br><br>        <span class="hljs-comment">// 3.SecurityUtils 设置安全管理器</span><br>        SecurityUtils.setSecurityManager(defaultSecurityManager);<br><br>        <span class="hljs-comment">// 4.获取用户登录的主体</span><br>        Subject subject = SecurityUtils.getSubject();<br><br>        AuthenticationToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            subject.login(token);<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;用户名不正确&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;用户密码不正确&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MD5-Salt"><a href="#MD5-Salt" class="headerlink" title="MD5+Salt"></a>MD5+Salt</h2><h3 id="为什么需要MD5与盐"><a href="#为什么需要MD5与盐" class="headerlink" title="为什么需要MD5与盐"></a>为什么需要MD5与盐</h3><p>在TestCustomerRealm中的AuthenticationToken代表的是用户登录信息，在Shiro的认证过程中会与Realm的AuthenticationInfo（即数据库身份信息）相比对，如果不做任何加密处理。数据库信息与用户登录信息特别是密码完全一致，这样如果数据库泄露了，对应的用户信息就会受到极大威胁。</p><p>因而数据库并不会直接存有用户明文密码，而是在用户注册时将明文密码经过一系列加密算法获得的匿名密码存入数据库。当用户登录时会在业务层以相同算法算取匿名密码，再与数据库比对。MD5，Salt就是常用的加密算法。</p><blockquote><p>注意的是，Shiro默认情况下是通过AuthenticatingRealm.class下的assertCredentialsMatch方法实现用户信息与数据库信息比对的，且比对方法为Strings.equals()。如果采用加密算法，数据库匿名密码与用户明文密码肯定对不上，因而我们需要更改默认比对方式。</p></blockquote><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>因为是由Realm携带数据库信息，通过Realm的改造来更改默认比对方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置 realm 使用的 hash 凭证匹配器</span><br>HashedCredentialsMatcher credentialsMatcher = <span class="hljs-keyword">new</span> HashedCredentialsMatcher();<br>credentialsMatcher.setHashAlgorithmName(<span class="hljs-string">&quot;md5&quot;</span>); <span class="hljs-comment">// 设置使用MD5算法</span><br><span class="hljs-comment">// 2. 给安全管理器设置 realm 【Realm 需要获取用户认证的数据源信息】</span><br>CustomRealm customRealm = <span class="hljs-keyword">new</span> CustomRealm();<br>customRealm.setCredentialsMatcher(credentialsMatcher);<br>securityManager.setRealm(customerMD5Realm);<br></code></pre></td></tr></table></figure><p>这里还只是MD5，如果要加盐，不需要更改Realm，只需要再把带回来的AuthenticationInfo加上盐值就行了，因为Shiro会自动把盐值加在明文密码前再进行MD5计算的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken authenticationToken)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>    String principal = (String)authenticationToken.getPrincipal();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;xry&quot;</span>.equals(principal))&#123;<br>        <span class="hljs-comment">// 参数1：返回数据库中的用户名  参数2：加盐后的匿名密码 参数3：注册时的随机盐 参数4：提供当前的 realm 名字，this.getName()</span><br>        SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(<br>            <span class="hljs-string">&quot;xry&quot;</span>,<span class="hljs-string">&quot;8a83592a02263bfe6752b2b5b03a4799&quot;</span>,ByteSource.Util.bytes(<span class="hljs-string">&quot;X0*7ps&quot;</span>),<span class="hljs-keyword">this</span>.getName());<br>        <span class="hljs-keyword">return</span> simpleAuthenticationInfo;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><p>更深层次地，经过MD5和Salt后通过Hash散列再多次散列计算后就能得到更为复杂的密码。</p><p>需要对HashedCredentialsMatcher设置散列次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">credentialsMatcher.setHashIterations(<span class="hljs-number">1024</span>);     <span class="hljs-comment">// 需要散列多少次</span><br></code></pre></td></tr></table></figure><h1 id="Shiro授权"><a href="#Shiro授权" class="headerlink" title="Shiro授权"></a>Shiro授权</h1><h2 id="1-授权"><a href="#1-授权" class="headerlink" title="1. 授权"></a>1. 授权</h2><p>　　授权即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。</p><h2 id="2-关键对象"><a href="#2-关键对象" class="headerlink" title="2. 关键对象"></a>2. 关键对象</h2><p>　　授权可简单理解为 who 对 what（which）进行 How 操作；</p><p>　　Who，即主体（Subject），主体需要访问系统中的资源；</p><p>　　What，即资源（Resource），如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括资源类型和资源实例，比如商品信息为资源类型，类型为 t01 的商品为资源实例，编号 001 的商品也属于资源实例；</p><p>　　How，权限 / 许可（Permission），规定了主体对资源的操作许可， 权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为 001 用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。</p><h2 id="3-授权流程"><a href="#3-授权流程" class="headerlink" title="3. 授权流程"></a>3. 授权流程</h2><p>   <img src="https://img2020.cnblogs.com/blog/1543609/202105/1543609-20210528163831516-1252473309.png" alt="img"></p><h2 id="4-授权方式"><a href="#4-授权方式" class="headerlink" title="4. 授权方式"></a>4. 授权方式</h2><ul><li>基于角色的访问控制【RBAC 基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(subject.hasRole(<span class="hljs-string">&quot;admin&quot;</span>))&#123;<br>   <span class="hljs-comment">//操作什么资源</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>基于资源的访问控制【RBAC 基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(subject.isPermission(<span class="hljs-string">&quot;user:update:01&quot;</span>))&#123; <span class="hljs-comment">//资源实例</span><br>  <span class="hljs-comment">//对01用户进行修改</span><br>&#125;<br><span class="hljs-keyword">if</span>(subject.isPermission(<span class="hljs-string">&quot;user:update:*&quot;</span>))&#123;  <span class="hljs-comment">//资源类型</span><br>  <span class="hljs-comment">//对01用户进行修改</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-权限字符串"><a href="#5-权限字符串" class="headerlink" title="5. 权限字符串"></a>5. 权限字符串</h2><p>　　权限字符串的规则是【<strong>资源标识符：操作：资源实例标识符】</strong>意思是对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用 * 通配符。</p><p>例子：</p><ul><li>用户创建权限：user : create，或 user : create : *</li><li>用户修改实例001的权限：user : update : 001</li><li>用户实例001的所有权限：user : *：001</li></ul><h2 id="6-开发授权代码"><a href="#6-开发授权代码" class="headerlink" title="6. 开发授权代码"></a>6. 开发授权代码</h2><h3 id="自定义-Realm-代码实现"><a href="#自定义-Realm-代码实现" class="headerlink" title="自定义 Realm 代码实现"></a>自定义 Realm 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerMD5Realm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 一个主体可以有多个身份，参数是集合 principals；但是只有一个主身份PrimaryPrincipal；</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;<br>        String principal = (String) principalCollection.getPrimaryPrincipal();<br>        System.out.println(<span class="hljs-string">&quot;principal:&quot;</span>+principal);<br><br>        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<br>        simpleAuthorizationInfo.addRoles(Arrays.asList(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>));<br>        simpleAuthorizationInfo.addStringPermissions(Arrays.asList(<span class="hljs-string">&quot;user:update:*&quot;</span>,<span class="hljs-string">&quot;admin:*:*&quot;</span>,<span class="hljs-string">&quot;developer:*:01&quot;</span>));<br>        <span class="hljs-keyword">return</span> simpleAuthorizationInfo;<br>    &#125;<br>    <span class="hljs-comment">// 认证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        String principal = (String) token.getPrincipal();<br>        System.out.println(<span class="hljs-string">&quot;principal = &quot;</span> + principal);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="授权处理"><a href="#授权处理" class="headerlink" title="授权处理"></a>授权处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCustomerMD5Authenticator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 创建安全管理器</span><br>        DefaultSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager();<br><br>        <span class="hljs-comment">// 2. 给安全管理器设置 realm 【Realm 需要获取用户认证的数据源信息】</span><br>        CustomerMD5Realm customerMD5Realm = <span class="hljs-keyword">new</span> CustomerMD5Realm();<br>        <span class="hljs-comment">// 设置 realm 使用的 hash 凭证匹配器</span><br>        HashedCredentialsMatcher credentialsMatcher = <span class="hljs-keyword">new</span> HashedCredentialsMatcher();<br>        credentialsMatcher.setHashAlgorithmName(<span class="hljs-string">&quot;md5&quot;</span>); <span class="hljs-comment">// 设置使用的 Hash 算法</span><br>        credentialsMatcher.setHashIterations(<span class="hljs-number">1024</span>);     <span class="hljs-comment">// 需要散列多少次</span><br>        customerMD5Realm.setCredentialsMatcher(credentialsMatcher);<br>        securityManager.setRealm(customerMD5Realm);<br><br>        <span class="hljs-comment">// 3. SecurityUtils 设置安全管理器</span><br>        SecurityUtils.setSecurityManager(securityManager);<br><br>        <span class="hljs-comment">// 4. 获取关键对象 Subject 主体</span><br>        Subject subject = SecurityUtils.getSubject();<br><br>        <span class="hljs-comment">// 5. 创建令牌</span><br>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;xiaochen&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-comment">// 用户认证</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;认证状态: &quot;</span> + subject.isAuthenticated());<br>            subject.login(token);<br>            System.out.println(<span class="hljs-string">&quot;认证状态: &quot;</span> + subject.isAuthenticated());<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;认证失败: 用户名不存在~&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;认证失败: 密码错误~&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 授权</span><br>        <span class="hljs-comment">//hasRole，hasAllRoles等授权f都会触发Realm的doGetAuthorizationInfo。对于多参数授权方法还会多次触发Realm</span><br>        <span class="hljs-keyword">if</span> (subject.isAuthenticated()) &#123;<br>            <span class="hljs-comment">//基于角色权限控制</span><br>            System.out.println(subject.hasRole(<span class="hljs-string">&quot;super&quot;</span>));　　<span class="hljs-comment">// 走授权流程</span><br>            <span class="hljs-comment">// 基于多角色权限控制</span><br>            System.out.println(subject.hasAllRoles(Arrays.asList(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>)));　　<span class="hljs-comment">// 走授权流程</span><br>            <span class="hljs-comment">// 是否具有其中一个角色</span><br>            <span class="hljs-keyword">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;super&quot;</span>));　　<span class="hljs-comment">// 走授权流程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">boolean</span> aBoolean : booleans) &#123;<br>                System.out.println(aBoolean);<br>            &#125;<br>            <span class="hljs-comment">// 基于权限字符串的访问控制 资源标识符:操作:资源类型</span><br>            System.out.println(subject.isPermitted(<span class="hljs-string">&quot;user:update:01&quot;</span>));　　<span class="hljs-comment">// 走授权流程</span><br>            <span class="hljs-comment">// 分别具有哪些权限</span><br>            <span class="hljs-keyword">boolean</span>[] permitted = subject.isPermitted(<span class="hljs-string">&quot;user:*:01&quot;</span>, <span class="hljs-string">&quot;order:*:02&quot;</span>);　　<span class="hljs-comment">// 走授权流程</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">boolean</span> b : permitted) &#123;<br>                System.out.println(b);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shiro认证&quot;&gt;&lt;a href=&quot;#Shiro认证&quot; class=&quot;headerlink&quot; title=&quot;Shiro认证&quot;&gt;&lt;/a&gt;Shiro认证&lt;/h1&gt;&lt;h2 id=&quot;1-认证&quot;&gt;&lt;a href=&quot;#1-认证&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="后端" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2021/08/10/Docker/"/>
    <id>http://example.com/2021/08/10/Docker/</id>
    <published>2021-08-10T13:59:01.000Z</published>
    <updated>2021-08-24T11:07:52.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p><img src="https://www.mopsky.com/wp-content/uploads/2019/04/beepress9-1554682434.png" alt="Docker工作流程"></p><table class="reference"> <tbody><tr><th width="20%">概念</th><th>说明</th></tr>  <tr>   <td><p>Docker 镜像(Images)</p></td>   <td><p>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 </p></td>  </tr>  <tr>   <td><p>Docker 容器(Container)</p></td>   <td><p>容器是独立运行的一个或一组应用，是镜像运行时的实体。</p></td>  </tr>  <tr>   <td><p>Docker 客户端(Client)</p></td>   <td><p>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener noreferrer">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</p></td>  </tr>  <tr>   <td><p>Docker 主机(Host)</p></td>   <td><p>一个物理或者虚拟的机器用于执行 Docker  守护进程和容器。</p></td>  </tr>  <tr>   <td><p>Docker Registry</p></td>   <td><p>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。</p><p>Docker Hub(<a href="https://hub.docker.com" target="_blank" rel="noopener noreferrer">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</p>  <p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <span class="marked">&lt;仓库名&gt;:&lt;标签&gt;</span> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</p></td> </tr>  <tr>   <td><p>Docker Machine</p></td>   <td><p>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</p></td>  </tr> </tbody></table>## docker run<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>docker:</strong> Docker 的二进制执行文件。</li><li><strong>run:</strong> 与前面的 docker 组合来运行一个容器。</li><li><strong>ubuntu:15.10</strong> 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li><li><strong>/bin/echo “Hello world”:</strong> 在启动的容器里执行的命令</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -i -t ubuntu:15.10 /bin/bash<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li><li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互</li></ul></blockquote><p>输入后会直接进入到ubuntu15.10的交互界面中，即装了Ubuntu镜像的容器。</p><blockquote><p>如果通过<code>exit</code>退出容器后，该容器也会停止。而<code>Ctrl+P+Q</code>退出则不会停止容器。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>-d：</strong>让容器在后台运行，执行命令为**-c**所跟内容</li></ul></blockquote><p>注意的是：不会进入容器的交互界面，因此也无法看到循环输出。如果想查看输出，<code>docker logs 2b1b7a428627（容器ID）</code>可以在外部查看容器输出</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull tomcat<br></code></pre></td></tr></table></figure><blockquote><p>本地需要先拉取镜像，同一镜像可能会有不同版本，使用<code>docker search tomcat</code>可在dockerhub中找到所有镜像</p><p>当然也可以直接去<a href="https://hub.docker.com/">Docker Hub</a>官网搜索</p></blockquote><p><img src="https://pic.imgdb.cn/item/6112a1a35132923bf822cf75.jpg" alt="查找tomcat镜像"></p><img src="https://pic.imgdb.cn/item/6112a2e45132923bf8256c07.jpg" alt="复制命令即可拉取" style="zoom: 80%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps -a<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/6112a4765132923bf828ce00.jpg"></p><p>查看所有容器。<code>docker ps -a -q</code>则只查看容器ID</p><blockquote><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running 或 Up（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。<strong>也可以通过 <code>--name CustomName</code>来自定义容器名</strong>，Names在许多命令中可以替换&lt;容器 ID&gt;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop &lt;容器 ID&gt;#停止容器<br>docker restart &lt;容器 ID&gt;#重启容器<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach &lt;容器 ID&gt;#进入后台容器，但是exit退出后会随之停止容器<br>docker exec &lt;容器 ID&gt;#进入后台容器，exit后不会停止容器<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm -f &lt;容器 ID&gt;#删除容器<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs -f &lt;容器 ID&gt;#查看容器输出日志<br>docker top &lt;容器 ID&gt;#查看容器内部运行进程<br>docker inspect &lt;容器 ID&gt;#查看记录容器配置信息和状态的JSON文件<br></code></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/611380715132923bf84b573e.jpg" alt="本地镜像"></p><blockquote><ul><li><strong>REPOSITORY：</strong>表示镜像的仓库源</li><li><strong>TAG：</strong>镜像的标签</li><li><strong>IMAGE ID：</strong>镜像ID</li><li><strong>CREATED：</strong>镜像创建时间</li><li><strong>SIZE：</strong>镜像大小</li></ul></blockquote><p>因为同一个仓库源可以有多个TAG，代表不同版本。所以使用 <code>REPOSITORY:TAG</code> 来定义不同的镜像，不加TAG则默认为latest。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull ubuntu:13.10<br>docker search httpd<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi hello-world#删除镜像<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag &lt;镜像 ID&gt; runoob/centos:dev #为镜像再设置标签<br></code></pre></td></tr></table></figure><h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -P training/webapp python app.py<br></code></pre></td></tr></table></figure><p>运行一个简易Web容器，本地不存在Docker会自动获取并下载。查看端口映射情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@levi:~$ docker ps<br>CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES<br>fce072cc88ce    training/webapp     &quot;python app.py&quot;    ...     0.0.0.0:32768-&gt;5000/tcp   grave_hopper<br></code></pre></td></tr></table></figure><p>访问服务器的32768端口就可以映射到该容器，容器中运行app.py，故而可看到“Hello World”输出，访问之前记得开放安全组的32768端口。</p><blockquote><ul><li><strong>-P :**是容器内部端口</strong>随机**映射到主机的高端口。</li><li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li></ul></blockquote><h4 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 5001:5000 training/webapp python app.py #5001映射到5000<br>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py#通过访问 127.0.0.1:5001 来访问容器的 5000 端口。<br>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py#默认绑定tcp,也可以绑定udp<br></code></pre></td></tr></table></figure><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create -d bridge test-net<br></code></pre></td></tr></table></figure><p>创建新网络，<code>-d</code>指明网络类型为bridge，还有一种为overlay</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network ls #可以列出所有网络<br></code></pre></td></tr></table></figure><hr><p>运行两个容器并连接到test-net网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -itd --name test1 --network test-net ubuntu /bin/bash<br>docker run -itd --name test2 --network test-net ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>进入其中一个容器，可以通过ping指令连接到其他容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it test1 /bin/bash<br>ping test2<br></code></pre></td></tr></table></figure><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>容器在运行中生成的数据会随着容器的删除随之消失，为了做到数据持久化，即把容器的数据同步到本地，为此Docker提供了数据卷(Data Volume)。此外，也可以将数据写入镜像中并commit，这样再创建容器的时候就会读到这些数据了。</p><h3 id="先导"><a href="#先导" class="headerlink" title="先导"></a>先导</h3><p>1）一个数据卷是一个特别指定的目录，该目录利用容器的UFS文件系统可以为容器提供一些稳定的特性或者数据共享。数据卷可以在多个容器之间共享。</p><p>2）创建数据卷，只要在docker run命令后面跟上-v参数即可创建一个数据卷，当然也可以跟多个-v参数来创建多个数据卷，当创建好带有数据卷的容器后，就可以在其他容器中通过**–volumes-froms**参数来挂载该数据卷了，而不管该容器是否运行。也可以在Dockerfile中通过VOLUME指令来增加一个或者多个数据卷。</p><p>3）如果有一些数据想在多个容器间共享，或者想在一些临时性的容器中使用该数据，那么最好的方案就是你创建一个<strong>数据卷容器</strong>，然后在该临时性的容器中挂载该数据卷容器的数据。这样，即使删除了刚开始的第一个数据卷容器或者中间层的数据卷容器，只要有其他容器使用数据卷，数据卷都不会被删除的。</p><p>4）不能使用docker export、save、cp等命令来备份数据卷的内容，因为数据卷是存在于<strong>镜像之外</strong>的。备份方法: 创建一个新容器，挂载数据卷容器，同时挂载一个本地目录，然后把远程数据卷容器的数据卷通过备份命令备份到映射的本地目录里面。</p><p>5）可以把一个<strong>本地主机的目录当做数据卷</strong>挂载在容器上，同样是在docker run后面跟-v参数，不过-v后面跟的不再是单独的目录了，它是<code>-v [host-dir]:[container-dir]:[rw|ro]</code>这样格式的，其中host-dir是一个绝对路径的地址，如果host-dir不存在，则docker会创建一个新的数据卷，如果host-dir存在，但是指向的是一个不存在的目录，则docker也会创建该目录，然后使用该目录做数据源。</p><h3 id="构建数据卷"><a href="#构建数据卷" class="headerlink" title="构建数据卷"></a>构建数据卷</h3><h4 id="只指定容器内路径"><a href="#只指定容器内路径" class="headerlink" title="只指定容器内路径"></a>只指定容器内路径</h4><p>在docker run创建容器的时候，可以通过-v来指定容器挂载的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name LeviVolume -v /home ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>在容器外通过<code>docker inspect LeviVolume</code>便可找到数据卷的挂载信息。其中Source就是本机的数据卷路径。</p><p><img src="https://pic.imgdb.cn/item/611f519c4907e2d39c3e8ebb.jpg"></p><h5 id="匿名挂载-amp-具名挂载"><a href="#匿名挂载-amp-具名挂载" class="headerlink" title="匿名挂载&amp;具名挂载"></a>匿名挂载&amp;具名挂载</h5><p>如上，<code>-v /home</code>就是匿名挂载，该卷是没有自定义卷名的。系统分配的是<code>f645b8ff</code>。</p><p>我们也可以通过具名挂载<code>-v UbuntuVolume:/home</code>来指定该卷名为UbuntuVolume。</p><blockquote><p>匿名挂载和具名挂载仅是卷名的区别，但值得留意的是，只指定容器内路径创建数据卷，该卷的Source都会放在<code>/var/lib/docker/volumes/&lt;卷名&gt;/_data</code>。</p></blockquote><h4 id="指定本地和容器内路径"><a href="#指定本地和容器内路径" class="headerlink" title="指定本地和容器内路径"></a>指定本地和容器内路径</h4><p>可以指定本机目录/home/HomeFile作为数据卷,设置可读写权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name LeviVolume -v /home/HomeFile:/home:rw ubuntu /bin/bash<br></code></pre></td></tr></table></figure><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>可以专门生成一个存放数据卷的容器，其他需要共享数据的容器可以直接挂载在该容器的下面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -v /var/volume1 -v /var/volume2 --name LeviVolume ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>其他容器就可以挂载在LeviVolume下，这会继承LeviVolume的两个数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --rm --volumes-from LeviVolume --name Sub_Container ubuntu /bin/bash<br></code></pre></td></tr></table></figure><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker login #登入DockerHub<br></code></pre></td></tr></table></figure><p>登入之后除了可以重dockerhub中pull镜像，search镜像外，还能通过push到dockerhub上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker push &lt;username&gt;/ubuntu:18.04<br></code></pre></td></tr></table></figure><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>我们可以通过DockerFile自定义镜像，从而推到DockerHub上以供他人使用</p><h3 id="制定镜像"><a href="#制定镜像" class="headerlink" title="制定镜像"></a>制定镜像</h3><ol><li>创建Dockerfile文件，填写指令</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;这是一个本地构建的nginx镜像&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></code></pre></td></tr></table></figure><ol start="2"><li>FROM和RUN</li></ol><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN &lt;命令行命令&gt;# &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。<br>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]#等价于 RUN ./test.php dev offline<br></code></pre></td></tr></table></figure><blockquote><p>注意的是，Dockerfile中每一行指令都会新建一层，因此能同时执行的命令都用<code>&amp;&amp;</code>连接命令，以免造成镜像膨胀过大</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> yum install wget</span><br><span class="hljs-keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="bash"> tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> yum install wget \</span><br><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="bash">    &amp;&amp; tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><ol start="3"><li>构建镜像</li></ol></blockquote><p>在Dockerfile的目录下，执行创建动作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t nginx:v3 .# .为上下文路径<br></code></pre></td></tr></table></figure><blockquote><p>由于docker的运行模式是C/S，docker引擎是S。实际的构建过程中是在docker引擎下完成的，因此我们可能需要吧本机的一些文件打包给docker引擎。如果没有指明上下文路径，则默认为Dockerfile所在位置</p><p>因此，上下文路径下要尽量干净，否则会因为文件过多而造成过程迟缓。</p></blockquote><blockquote><p>Dockerfile名字可以自定义，但是此时需要加上<code>-f &lt;DockerfileName&gt;</code></p></blockquote><h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;<br></code></pre></td></tr></table></figure><p>**[–chown=<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则</p><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;<br></code></pre></td></tr></table></figure><p>ADD和COPY功能一样，官方推荐COPY。只是ADD再传输tar压缩文件时，压缩格式为 gzip, bzip2 以及 xz 的情况下，会<strong>自动复制并解压</strong>到 &lt;目标路径&gt;。但是在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效</p><h4 id="CMD-amp-ENTRYPOINT"><a href="#CMD-amp-ENTRYPOINT" class="headerlink" title="CMD &amp; ENTRYPOINT"></a>CMD &amp; ENTRYPOINT</h4><p>相较于RUN，CMD&amp; ENTRYPOINT是在<code>docker run</code>时运行，而RUN是在<code>docker build</code>。</p><p>CMD与ENTRYPOINT的作用一致，都是在执行镜像后再紧接着执行该命令。如<code>CMD /bin/bash</code>，docker run后直接执行/bin/bash来启动bash终端，从而允许人机交互。又如<code>CMD [&quot;ls&quot;,&quot;-a&quot;]</code>,docker run后直接执行ls -a。</p><blockquote><p>注意，CMD和ENTRYPOINT都是为新容器开启一个进程，所以不是以<code>docker run ubuntu /bin/bash</code>形式执行镜像的情况下，我们要加上CMD或ENTRYPOINT来保证容器中有进程。<strong>否则该容器会被自动回收。</strong></p></blockquote><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMD &lt;shell 命令&gt; <br>CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] <br>CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] #和ENTRYPOINT同时存在才有意义<br></code></pre></td></tr></table></figure><p>CMD为启动容器指定的默认运行程序，程序运行结束后容器也随之结束。所以，如果Dockerfile中存在多个CMD指令，仅有最有一个生效（即<strong>只有最后的CMD对应的层会在docker build时添加到镜像中，但所有CMD都会执行一遍</strong>。生效和执行是两个概念！！）</p><p>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><blockquote><p>CMD [“ls”,”-a”]会被<code>docker run &lt;自定义的镜像名&gt; ls -a -l</code>覆盖，即执行ls -al。但是<code>docker run &lt;自定义镜像名&gt; -l</code>时会报错，因为-l不会覆盖ls -a。</p></blockquote><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ENTRYPOINT [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]<br></code></pre></td></tr></table></figure><p>docker run命令行参数不会覆盖ENTRYPOINT，而是将命令行参数作为参数送给ENTRYPOINT</p><blockquote><p>ENTRYPOINT [“ls”,”-a”]在<code>docker run &lt;自定义镜像名&gt; -l</code>时不会报错，而是将其追加到ENTRYPOINT之后执行ls -al</p></blockquote><hr><p>当ENTRYPOINT和CMD同时出现时，可以达到缺省值的效果，配合<code>CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code>使用可以为ENTRYPOINT指定默认参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>当docker run不传参数<code>docker run nginx:test</code>时，容器执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>当docker run传入参数<code>docker run nginx:test -c /etc/nginx/new.conf</code>，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/new.conf<br></code></pre></td></tr></table></figure><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> [&lt;key&gt;=&lt;value&gt;]+<br></code></pre></td></tr></table></figure><p>示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 <code>$NODE_VERSION</code> 引用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]<br></code></pre></td></tr></table></figure><p>与ENV作用一致，只是其作用域仅在Dockerfile内，经过docker build后便会消失。</p><p>docker build时可以通过 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。如果忘记挂载数据卷，会自动加载VOLUME。</p><blockquote><p>此方式是匿名挂载，&lt;路径1&gt;就是容器内的Destination。</p></blockquote><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><p>将容器的端口暴露出来，这样在运行随机端口映射<code>docker run -P</code> 时，也只会随机选取暴露的端口使用。</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="bash"> &lt;工作目录路径&gt;</span><br></code></pre></td></tr></table></figure><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在，但工作目录必须提前创建好。</p><p>制定工作目录后，该镜像对应容器会直接进入WORKDIR，进入容器后使用<code>pwd</code>可以看到当前目录。</p><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">USER</span> &lt;用户名&gt;[:&lt;用户组&gt;]<br></code></pre></td></tr></table></figure><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></code></pre></td></tr></table></figure><p>为镜像添加一些元数据如作者等信息。</p><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h2 id=&quot;Docker架构&quot;&gt;&lt;a href=&quot;#Docker架构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.4搭建Gitlab并上传项目</title>
    <link href="http://example.com/2021/06/04/Ubuntu20-4%E6%90%AD%E5%BB%BAGitlab%E5%B9%B6%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/06/04/Ubuntu20-4%E6%90%AD%E5%BB%BAGitlab%E5%B9%B6%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-06-04T12:33:03.000Z</published>
    <updated>2021-10-30T03:12:18.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里云学生白嫖2C4G服务器"><a href="#阿里云学生白嫖2C4G服务器" class="headerlink" title="阿里云学生白嫖2C4G服务器"></a>阿里云学生白嫖2C4G服务器</h1><p>在这里：<a href="https://developer.aliyun.com/adc/student/">阿里云高校学生计划 (aliyun.com)</a>，早上八点之前可零元购两个月的ECS，我便用来学习Gitlab+Gitlab Runner+Devops等等</p><h1 id="GitLab的安装与登入"><a href="#GitLab的安装与登入" class="headerlink" title="GitLab的安装与登入"></a>GitLab的安装与登入</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>进入阿里云服务器控制台，找到实例，我们可以看到自己服务器的详细信息如下：</p><p><img src="https://pic.imgdb.cn/item/60ba20278355f7f7188875e6.jpg" alt="云服务器管理控制台"></p><p>我们利用SecureCRT远程连接公网IP，linux服务器的默认用户名为root，初次创建服务器需要通过<strong>重置实例密码</strong>生成。我们能SSH连接服务器是因为默认在安全组上开放了22号端口。</p><h2 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1593046">Ubuntu19.1 中 GitLab 的安装配置与卸载</a></p><ul><li><strong>开启防火墙</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ufw enable<br>ufw status <span class="hljs-regexp">//</span>查看防火墙状态，应该只有OpenSSH服务是打开的<br></code></pre></td></tr></table></figure><p>接下来我们添加几个端口：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ufw</span> <span class="hljs-literal">allow</span> http<br><span class="hljs-attribute">ufw</span> <span class="hljs-literal">allow</span> https<br><span class="hljs-attribute">ufw</span> <span class="hljs-literal">allow</span> OpenSSH<br></code></pre></td></tr></table></figure><ul><li><strong>安装依赖项</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">apt update <span class="hljs-regexp">//</span>刷新本地包索引<br>apt install ca-certificates curl openssh-server postfix <span class="hljs-regexp">//</span>安装依赖项，提供邮箱通知服务<br></code></pre></td></tr></table></figure><p>接下来会出现以下画面：</p><p><img src="https://pic.imgdb.cn/item/60ba23a88355f7f718cbe0b4.jpg" alt="一直回车即可"></p><p>可能会让你设置一个邮箱：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-symbol">levi@</span>ubuntu-gitlab.com <span class="hljs-comment">//我设置成了这个,随便设置的,后面可以改，可以选择回车跳过</span><br></code></pre></td></tr></table></figure><p>打开HTTP和SSH端口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -m tcp -<span class="hljs-selector-tag">p</span> tcp --dport <span class="hljs-number">22</span> -j ACCEPT<br>iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -m tcp -<span class="hljs-selector-tag">p</span> tcp --dport <span class="hljs-number">80</span> -j ACCEPT<br></code></pre></td></tr></table></figure><blockquote><p>可能会在安装依赖项的时候出现以下问题：</p><p><img src="https://pic.imgdb.cn/item/60ba24638355f7f718db6d2d.jpg"></p><p>只需要换源即可，因为我们用的是阿里云，服务器里就已经自动换成了阿里云镜像了。</p></blockquote><ul><li><strong>安装Gitlab</strong></li></ul><p>官方下载地址太慢了，这里我们换源：</p><p>1、首先信任 GitLab 的 GPG 公钥:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">curl https:<span class="hljs-comment">//packages.gitlab.com/gpg.key 2&gt; /dev/null | sudo apt-key add - &amp;&gt;/dev/null</span><br></code></pre></td></tr></table></figure><p>2、打开vi：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">vi /etc/apt/sources.list.d/gitlab-ce.list<br></code></pre></td></tr></table></figure><p>3、将下面的内容粘贴进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">deb https:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main  //粘贴至文本中，按Esc键，键入:，最后输入wq保存并退出。</span><br></code></pre></td></tr></table></figure><p>4、安装 gitlab-ce:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">apt-get update<br>apt-get install gitlab-ce<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/60ba25048355f7f718e8dc40.jpg" alt="gitlab安装成功"></p><p> 5、打开 sshd 和 postfix 服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">service sshd start<br>service postfix start<br></code></pre></td></tr></table></figure><p>6、更新配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">gitlab-ctl reconfigure<br></code></pre></td></tr></table></figure><ul><li><strong>配置GitLab</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/gi</span>tlab/gitlab.rb<br></code></pre></td></tr></table></figure><p>找到<code>external_url = &#39;http://git.example.com&#39;</code>并将其修改成<code>external_url = &#39;http://公网ip:4399&#39;</code></p><p>公网IP就是服务器中的公网ip，而不是私网IP，因为我们本机是访问不了私网IP的。4399就是访问端口，可以自由配置，如果只填IP的话，端口默认为8080。</p><blockquote><p>建议配置一个自定的端口，但一定要求是没有被占用的端口，可以事先通过<code>lsof -i:&lt;port&gt;</code>来查看port是否被占用。</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gitlab-ctl reconfigure</span><br><span class="hljs-attribute">gitlab-ctl restart</span><br></code></pre></td></tr></table></figure><p>重启gitlab服务，可以注意看restart后有没有启动unicorn服务，如果没有将很可能出现502错误。（我就是这个问题）</p><ul><li><strong>阿里云安全组添加端口</strong></li></ul><p>来到阿里云安全组配置，进入配置规则：</p><p><img src="https://pic.imgdb.cn/item/60ba27b88355f7f7181b489e.jpg"></p><p>手动添加4399端口，源直接填0.0.0.0/0，这是保证我们使用IP:PORT登入的时候不会出现</p><p><img src="https://pic.imgdb.cn/item/60ba28258355f7f718228d7a.jpg" alt="没有添加端口所致"></p><blockquote><p>同时我们也要添加<code>80端口</code>，这是为TCP开放的。</p></blockquote><p>如果添加了80端口和4399端口安全组也无法直接登入，需要查看是否为防火墙问题：<a href="https://blog.csdn.net/qq_27645299/article/details/103742081">阿里云服务器 80 端口设置了安全组还是无法访问</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --add-port=80/tcp --permanent<br>firewall-cmd --add-port=4399/tcp --permanent<br></code></pre></td></tr></table></figure><p>添加好80和4399端口后保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>查看是否添加成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --list-ports<br></code></pre></td></tr></table></figure><h2 id="登入Gitlab"><a href="#登入Gitlab" class="headerlink" title="登入Gitlab"></a>登入Gitlab</h2><p>在地址栏输入<code>公网ip:4399</code>可直接访问GitLab，如果成功进入则会先让你设置密码。之后就能正常登入使用了，默认登入账户是root</p><p><img src="https://pic.imgdb.cn/item/60ba29278355f7f718331354.jpg" alt="也可以注册"></p><h1 id="502错误排查"><a href="#502错误排查" class="headerlink" title="502错误排查"></a>502错误排查</h1><h2 id="8080与unicorn默认端口冲突"><a href="#8080与unicorn默认端口冲突" class="headerlink" title="8080与unicorn默认端口冲突"></a>8080与unicorn默认端口冲突</h2><p>如果配置gitlab时使用的是8080默认端口，而且unicorn也开启了，就会出现两者端口冲突的现象。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/gi</span>tlab/gitlab.rb<br></code></pre></td></tr></table></figure><p>按下<code>esc</code>进入命令模式，利用<code>/</code>查询制定字符串，按回车确定，n向下翻动，N向上翻动。</p><p>找到以下两处配置，取消注释，并修改端口：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">nicorn[<span class="hljs-string">&#x27;port&#x27;</span>] = <span class="hljs-number">8888</span><br><br>gitlab_workhorse[<span class="hljs-string">&#x27;auth_backend&#x27;</span>] = <span class="hljs-string">&quot;http://localhost:8888&quot;</span> <br><br>//unicorn[<span class="hljs-string">&#x27;port&#x27;</span>]与gitlab_workhorse[<span class="hljs-string">&#x27;auth_backend&#x27;</span>]的端口必须相同<br></code></pre></td></tr></table></figure><p>保存并重启</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">gitlab-ctl reconfigure</span><br><span class="hljs-attribute">gitlab-ctl restart</span><br></code></pre></td></tr></table></figure><h2 id="服务器防火墙未开启端口"><a href="#服务器防火墙未开启端口" class="headerlink" title="服务器防火墙未开启端口"></a>服务器防火墙未开启端口</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ufw</span> <span class="hljs-literal">allow</span> <span class="hljs-number">4399</span><br></code></pre></td></tr></table></figure><p>将gitlab服务的端口添加进去，需要删除就输入<code>ufw delete allow 4399</code></p><h2 id="等待时长过短"><a href="#等待时长过短" class="headerlink" title="等待时长过短"></a>等待时长过短</h2><p>这种情况适用于等待较长时间后出现502界面的。</p><p>依旧打开gitlab配置文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/gi</span>tlab/gitlab.rb<br></code></pre></td></tr></table></figure><p>找到以下两项并修改如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">gitlab_rails[<span class="hljs-string">&#x27;webhook_timeout&#x27;</span>] = <span class="hljs-number">90</span><br>gitlab_rails[<span class="hljs-string">&#x27;graphql_timeout&#x27;</span>] = <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>更新配置并启动。</p><h2 id="GitLab还未完全启动-内存不足"><a href="#GitLab还未完全启动-内存不足" class="headerlink" title="GitLab还未完全启动/内存不足"></a>GitLab还未完全启动/内存不足</h2><p>GItLab启动所需内存空间较大，理论最低要求4G的内存空间，如果低于则无法正常启动。</p><p>同样的，GitLab启动需要一段时间，首次启动需要等待1-2分钟才能完全启动。通过<code>free -m</code>可以查看free空间大小，通过不断查询发现free空间不断减小，说明gitlab正在启动中。</p><h2 id="未开启unicorn"><a href="#未开启unicorn" class="headerlink" title="未开启unicorn"></a>未开启unicorn</h2><p>我就是这个错误，因为我的502是瞬间就刷出来的，而且即使是多等待gitlab启动几分钟后也无济于事。</p><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>试了以上方法都不行，我stackflow上找到灵感，输入<code>lsof -i:4399</code>发现gitlab正在占用，没有问题</p><p><img src="https://pic.imgdb.cn/item/60ba2eae8355f7f7188bc692.jpg"></p><p>输入<code>lsof -i:8888</code>发现没有结果，也就说明8888没有被unicorn占用！！！因而我怀疑是否开启了unicorn服务。</p><p>输入命令<code>gitlab-ctl status</code>发现没有unicorn这一项，于是发现了问题来源。</p><p>依然是打开gitlab配置文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">vim <span class="hljs-regexp">/etc/gi</span>tlab/gitlab.rb<br><span class="hljs-comment">//找到并修改以下两项，取消注释</span><br>unicorn[<span class="hljs-string">&#x27;enable&#x27;</span>] = <span class="hljs-keyword">true</span><br>puma[<span class="hljs-string">&#x27;enable&#x27;</span>] = <span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p>保存并重启gitlab后，我们发现unicorn出现了。再次输入IP:4399终于成功登入了！！！！！</p><p>再次查看端口占用情况：</p><p><img src="https://pic.imgdb.cn/item/60ba30b18355f7f718ae9455.jpg" alt="unicorn端口分配成功成功"></p><h1 id="Gitlab初使用"><a href="#Gitlab初使用" class="headerlink" title="Gitlab初使用"></a>Gitlab初使用</h1><h2 id="添加SSH-Key"><a href="#添加SSH-Key" class="headerlink" title="添加SSH Key"></a>添加SSH Key</h2><p>本机安装过git的，在user/.ssh/id_rsa中存有密钥，将其配置到gitlab的SSH KEY中即可。</p><h2 id="下拉项目和上传项目"><a href="#下拉项目和上传项目" class="headerlink" title="下拉项目和上传项目"></a>下拉项目和上传项目</h2><p><a href="https://zhuanlan.zhihu.com/p/80115683">公司使用Gitlab管理项目实践指南 - 知乎 (zhihu.com)</a></p><h1 id="GitLab-CI-Docker-SpringBoot"><a href="#GitLab-CI-Docker-SpringBoot" class="headerlink" title="GitLab CI+Docker+SpringBoot"></a>GitLab CI+Docker+SpringBoot</h1><p>博客参考：<a href="https://blog.csdn.net/weixin_45631876/article/details/108187469?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.highlightwordscore&spm=1001.2101.3001.4242.2">GitLab Ci+docker持续化部署SpringBoot项目_Manaphy Chen的博客-CSDN博客</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gitlab-runner register #注册runner，s<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阿里云学生白嫖2C4G服务器&quot;&gt;&lt;a href=&quot;#阿里云学生白嫖2C4G服务器&quot; class=&quot;headerlink&quot; title=&quot;阿里云学生白嫖2C4G服务器&quot;&gt;&lt;/a&gt;阿里云学生白嫖2C4G服务器&lt;/h1&gt;&lt;p&gt;在这里：&lt;a href=&quot;https://d</summary>
      
    
    
    
    
    <category term="坑啊！" scheme="http://example.com/tags/%E5%9D%91%E5%95%8A%EF%BC%81/"/>
    
  </entry>
  
  <entry>
    <title>Java中import与package的原理讲解</title>
    <link href="http://example.com/2021/05/13/Java%E4%B8%ADimport%E4%B8%8Epackage%E7%9A%84%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://example.com/2021/05/13/Java%E4%B8%ADimport%E4%B8%8Epackage%E7%9A%84%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/</id>
    <published>2021-05-13T08:23:34.000Z</published>
    <updated>2021-05-13T08:27:46.926Z</updated>
    
    <content type="html"><![CDATA[<p>在说package、import机制前我们先来了解下java的CLASSPATH。</p><p>CLASSPATH顾名思义就是class的路径，当我们在系统中运行某个java程序时，它就会告诉系统在这些地方寻找这个class文件</p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435491.png" alt="img"></p><p>CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar; 这是我们java默认环境变量设置。</p><p>“.”的意思是在当前这个文件夹找；%JAVA_HOME%\lib是在java安装路径的lib文件夹找；%JAVA_HOME%\lib\tools.jar是在java安装路径的lib文件夹的tools压缩包中找。</p><p>现在让我们来测试下吧：</p><p>在C:\DOM中新建HelloWorld.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//: HelloWorld.java</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    System.out.println(“Hello World!”);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435492.png" alt="img"></p><p>首先javac HelloWorld.java，系统会在这个目录中找到HelloWorld.java文件，编译出HelloWorld.class文件。Java HelloWorld，系统会先调用CLASSPATH路径，我们设置了“.”这个目录，所以会在当前目录中找到HelloWorld.class。运行成功。</p><p>**换个地方运行这个程序</p><p>我们在C盘运行java HelloWorld**</p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435493.png" alt="img"></p><p>系统会现在CLASSPATH路径寻找HelloWorld.class。但是在”.”（现在是C盘）找不到这个文件。<br>我们现在把C:\DOM路径加入到CLASSPATH</p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435494.png" alt="img"></p><p>为了更新系统环境变量我们需要重新启动dos窗口</p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435495.png" alt="img"></p><p>系统会在CLASSPATH中找到C:\DOM这个路径，再找到HelloWorld.class这个文件。运行成功。<br>现在我们明白了CLASSPATH的作用了^^</p><p>关于PACKAGE</p><p>我们来改写这个程序,加入package</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//: HelloWorld.java</span><br> <span class="hljs-keyword">package</span> a.b;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    System.out.println(“Hello Wolrd!”);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435496.png" alt="img"></p><p>编译成功，但是不能运行。</p><p>系统在找到HelloWorld.class时就会读取到package a.b;这个信息，这个告诉系统这个HelloWorld.class是要放在a文件夹的b文件夹中。但是现在我们的HelloWorld.class是在DOM这个文件夹。文件路径和package不能对应，无法运行。</p><p>现在我们来新建a/b这个两个文件夹，然后把HelloWorld.class复制到b文件夹中。然后再运行java HelloWorld</p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435497.png" alt="img"></p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435498.png" alt="img"></p><p>对不起！还是没有运行成功。系统在CLASSPATH中寻找HelloWorld.class文件，但是这个文件被隐藏在a文件夹中的b文件夹。<br>我们来试试java a.b.HelloWorld</p><p><img src="https://img.jbzj.com/file_images/article/202001/202001171435499.png" alt="img"></p><p>运行成功了，系统在CLASSPATH中的“.”文件夹找到a文件夹，然后b文件夹，找到HelloWorld.class文件。<br>现在明白package的作用了，它是一定要符合从CLASSPATH出发的目录结构的。</p><p>关于IMPORT</p><p>Import的作用是当你调用另一个class的时候，告诉系统，要找哪里才能找到这个class。</p><p>我们在C:\DOM的目录下写一个调用a\b\HelloWorld.class的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//: TestHelloWorld.java</span><br><span class="hljs-keyword">import</span> a.b.HelloWorld;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHelloWorld</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    HelloWorld hw=<span class="hljs-keyword">new</span> HelloWorld();<br>    hw.main(args);  <span class="hljs-comment">//调用HelloWorld中的main()函数，args是引数，会打印出HelloWorld!</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img.jbzj.com/file_images/article/202001/2020011714354910.png" alt="img"></p><p>编译运行成功！</p><p>编译：系统在个这个文件夹中找到TestHelloWorld.java文件，检查import a.b.HelloWorld; 找CLASSPATH中找到a\b\HelloWorld.class。编译通过完成！</p><p>运行：系统现在CLASSPATH中找到TestHelloWorld.class，然后读取import a.b.HelloWorld; 导入HelloWorld.class，运行成功！</p><p>到此为止，你应该明白package 和 import的作用了。</p><blockquote><p>转载自：<a href="https://www.jb51.net/article/178705.htm">https://www.jb51.net/article/178705.htm</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在说package、import机制前我们先来了解下java的CLASSPATH。&lt;/p&gt;
&lt;p&gt;CLASSPATH顾名思义就是class的路径，当我们在系统中运行某个java程序时，它就会告诉系统在这些地方寻找这个class文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http</summary>
      
    
    
    
    
    <category term="JAVA!" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://example.com/2021/04/23/SpringBoot/"/>
    <id>http://example.com/2021/04/23/SpringBoot/</id>
    <published>2021-04-23T13:57:44.000Z</published>
    <updated>2021-08-10T08:13:08.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个SpringBoot程序"><a href="#第一个SpringBoot程序" class="headerlink" title="第一个SpringBoot程序"></a>第一个SpringBoot程序</h1><p>SpringBoot英文官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features">Spring Boot Features</a></p><p>SpringBoot中文文档：<a href="http://felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/pages/boot-documentation.html#boot-documentation">SpringBoot中文文档</a></p><p><img src="https://img.imgdb.cn/item/60854d58d1a9ae528fe44209.jpg" alt="创建新项目选择Spring Initializr"></p><p><img src="https://img.imgdb.cn/item/60854dbdd1a9ae528fe72752.jpg" alt="如图设置Group，Artifact和Java Version"></p><p><img src="https://img.imgdb.cn/item/60854e00d1a9ae528fe91f1c.jpg" alt="这里选择的是各个依赖和插件，可以过后补选"></p><p>一直点到Finish后就会生成一个配置好类似如下的SpringBoot项目。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">-- undefined</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-- pom.xml</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-- SpringBoot.iml</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-- .idea</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-- .mvn</span><br><span class="hljs-string">    </span>|<span class="hljs-string">-- src</span><br><span class="hljs-string">        </span>|<span class="hljs-string">-- main</span><br><span class="hljs-string">        </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- java</span><br><span class="hljs-string">        </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- com</span><br><span class="hljs-string">        </span>|<span class="hljs-string">   </span>|<span class="hljs-string">       </span>|<span class="hljs-string">-- theo</span><br><span class="hljs-string">        </span>|<span class="hljs-string">   </span>|<span class="hljs-string">           </span>|<span class="hljs-string">-- TheoApplication.java</span><br><span class="hljs-string">        </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- resources</span><br><span class="hljs-string">        </span>|<span class="hljs-string">       </span>|<span class="hljs-string">-- application.properties</span><br><span class="hljs-string">        </span>|<span class="hljs-string">       </span>|<span class="hljs-string">-- static</span><br><span class="hljs-string">        </span>|<span class="hljs-string">       </span>|<span class="hljs-string">-- templates</span><br><span class="hljs-string">        </span>|<span class="hljs-string">-- test</span><br><span class="hljs-string">            </span>|<span class="hljs-string">-- java</span><br><span class="hljs-string">                </span>|<span class="hljs-string">-- com</span><br><span class="hljs-string">                    </span>|<span class="hljs-string">-- theo</span><br><span class="hljs-string">                        </span>|<span class="hljs-string">-- TheoApplicationTests.java</span><br></code></pre></td></tr></table></figure><h2 id="TheoApplication-java"><a href="#TheoApplication-java" class="headerlink" title="TheoApplication.java"></a>TheoApplication.java</h2><p>这个就是该SpringBoot的项目启动文件，运行后就相当于启动了一个SpringBoot项目，不像SSM框架需要配置并启动Tomcat。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.theo;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TheoApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(TheoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code> SpringApplication.run()</code>就是启动SpringBoot组件，因为SpringBoot中集合了Tomcat，所以启动后也会启动Tomcat。</p><h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><p>这里就是SpringBoot的配置文件，不过用的都是<code>application.yml</code>。至于yml的优势以后讲解。</p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>同样也是在这里配置依赖和插件，不过有点不同的是配置依赖将不需要配置版本号，因为不同版本的SpringBoot会配置好大量依赖的版本。如果要导入某一插件，只需要导入对应的启动器即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>        <br></code></pre></td></tr></table></figure><p>至于每个依赖对应的启动器是什么，在<code>spring-boot-autoconfigure-》Meta-INF-》spring.factories</code>中能够查到，当然百度是个好东西。</p><h2 id="创建Controller层"><a href="#创建Controller层" class="headerlink" title="创建Controller层"></a>创建Controller层</h2><p><strong>一定要注意Controller层乃至Dao、Service、pojo都需要和SpringBoot启动文件<code>TheoApplication.java</code>在同一级目录下！！！！！</strong></p><p>创建<code>Controller.HelloController.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行启动文件，搜索<code>localhost:8080/hello</code>即可访问到控制器并获得返回值。</p><h1 id="Application-yml"><a href="#Application-yml" class="headerlink" title="Application.yml"></a>Application.yml</h1><p><code>.yml</code>语法格式和<code>.properties</code>有很大不同。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">key:</span> <span class="hljs-string">value</span><br><span class="hljs-comment">#对象</span><br><span class="hljs-attr">student:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">theo</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">20</span><br><span class="hljs-comment">#另一种写法</span><br><span class="hljs-attr">student:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">theo</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">20</span>&#125;<br><br><span class="hljs-comment">#数组</span><br><span class="hljs-attr">pets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span><br><span class="hljs-comment">#另一种写法</span><br><span class="hljs-attr">pets:</span> [<span class="hljs-string">cat</span>,<span class="hljs-string">dog</span>,<span class="hljs-string">pig</span>]<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">key</span>=<span class="hljs-string">value</span><br><span class="hljs-comment">#对象</span><br><span class="hljs-meta">student.name</span>=<span class="hljs-string">theo</span><br><span class="hljs-meta">student.age</span>=<span class="hljs-string">20</span><br><br><span class="hljs-comment">#数组</span><br><span class="hljs-meta">pets[0]</span>=<span class="hljs-string">cat</span><br><span class="hljs-meta">pets[1]</span>=<span class="hljs-string">dog</span><br><span class="hljs-meta">pets[2]</span>=<span class="hljs-string">pig</span><br></code></pre></td></tr></table></figure><p>能发现yml在写数组、map、对象方面能省上很多力气。</p><h2 id="通过yml实现JavaBean注入"><a href="#通过yml实现JavaBean注入" class="headerlink" title="通过yml实现JavaBean注入"></a>通过yml实现JavaBean注入</h2><p>创建<code>pojo.User.java</code>,并配置好构造器等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    List&lt;Integer&gt; list;<br>    Map&lt;String,String&gt; map;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果按照Spring的配置Bean方法,应该注解如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><span class="hljs-meta">@Value(&quot;theo&quot;)</span><br>    String name;<br>    <span class="hljs-meta">@Value(&quot;20&quot;)</span><br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Value(&quot;[1,2,3]&quot;)</span><br>    List&lt;Integer&gt; list;<br>    <span class="hljs-meta">@Value(&quot;&#123;name: theo,age: 3&#125;&quot;)</span><br>    Map&lt;String,String&gt; map;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Component的意思是将该JavaBean注册到Spring容器中，之后在Controller层通过@Autowired就可以直接从IOC中获取Bean了。</p><p>当然，我们不会这么用。倘若需要更改Bean的属性值就需要更改源代码，这样我们就需要了解yml配置JavaBean。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">User:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">theo</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">list:</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-attr">map:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">theo</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>写好yml后，更改JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;User&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>    List&lt;Integer&gt; list;<br>    Map&lt;String,String&gt; map;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就会从yml中找到User的配置并注入，再注册到IOC中。</p><blockquote><p>注意初次使用@ConfiguraProperties会在上方报红：<strong>Spring Boot Configuring the Annotation Processor not Configured</strong></p><p>这个并不影响程序正常运行，为了解决这个问题，可以在pom.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在yml配置中，普通字符串可以不用加单双引号。但如果字符串中含有转义字符如<code>\n</code>，加上双引号就会令转义字符生效即输出换行，但如果加上单引号就会将转义字符当作普通字串输出。</p></blockquote><h2 id="SpringBoot测试类"><a href="#SpringBoot测试类" class="headerlink" title="SpringBoot测试类"></a>SpringBoot测试类</h2><p><code>java.com.theo.TheoApplicationTests</code>是一个测试类，但要非常注意一点在SpringBoot测试类中@Test不是导的普通Junit包。而是需要导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果使用普通Junit将无法正常运行，在这次测试中就无法获取到User实例</p><p>我们编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.theo;<br><br><span class="hljs-keyword">import</span> com.theo.pojo.User;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TheoApplicationTests</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    User user;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><p>yml配置文件的值还能是动态值，即通过表达式生成值。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">theo$&#123;random.uuid&#125;</span><span class="hljs-comment">#生成随机uuid</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">20</span><span class="hljs-string">$&#123;random.int&#125;</span><span class="hljs-comment">#生成随机int</span><br>  <span class="hljs-attr">list:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">1</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">2</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">map:</span> <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tzq$&#123;user.name:DEFAULT&#125;</span><span class="hljs-comment">#类似三目运算符，如果存在user.name属性就取user.name的值，否则取后面的值。可以视作默认值</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="通过properties实现注入"><a href="#通过properties实现注入" class="headerlink" title="通过properties实现注入"></a>通过properties实现注入</h2><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！但当然properties也能实现注入。</p><blockquote><p>注意一点：properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p><p>settings–&gt;FileEncodings 中配置；</p><p><img src="https://img.imgdb.cn/item/60857df8d1a9ae528fcd43eb.jpg"></p></blockquote><h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>在实际开发中可能会有多个SpringBoot环境相互切换，比如测试环境和开发环境中用到的数据库会不同，那么如何在不同环境中自由切换呢？</p><h2 id="配置文件的位置"><a href="#配置文件的位置" class="headerlink" title="配置文件的位置"></a>配置文件的位置</h2><blockquote><p>file: ./config/application.yml                                                                        classpath: ./config/application.yml</p><p>file: ./application.yml                                                                                    classpath: ./application.yml</p></blockquote><p><code>file</code>指的是项目根目录SpringBoot，可以在根目录下创建config再写配置文件也可以直接写配置文件。</p><p><code>classpath</code>一般指的是<code>resource</code>目录，可以在其下创建config再写配置文件也可以直接写配置文件。</p><p>如果以上多个位置上都配置了文件，他们之间有如下优先级：<br><code>file:./config/ &gt; file:./ &gt; classpath:./config &gt; classpath:./</code></p><h2 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h2><p>如果在同一位置上有多套环境，可以手动切换环境。</p><h3 id="多环境-多文件"><a href="#多环境-多文件" class="headerlink" title="多环境-多文件"></a>多环境-多文件</h3><p>创建配置文件<code>application.yml、application-test.tml、application-dev.yml</code>分别配置端口<code>server.port: 8081、server.port: 8082、server.port: 8083</code></p><p>因为<strong>SpringBoot默认启动application.yml</strong>，因而在该配置文件切换环境。添加配置即可将环境切换成<code>application-test.yml</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">profiles:</span><br><span class="hljs-attr">active:</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure><h3 id="多环境-单文件"><a href="#多环境-单文件" class="headerlink" title="多环境-单文件"></a>多环境-单文件</h3><p>这种方式是.yml文件独有的，将多套环境同时写在一个配置文件中，环境之间用<code>---</code>分割</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-attr">spring:</span><br><span class="hljs-attr">profiles:</span><br><span class="hljs-attr">active:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br><span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br><span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><blockquote><p>这种方式已经被淘汰了，已经不推荐使用了</p></blockquote><h1 id="静态资源导入"><a href="#静态资源导入" class="headerlink" title="静态资源导入"></a>静态资源导入</h1><h2 id="默认静态资源路径"><a href="#默认静态资源路径" class="headerlink" title="默认静态资源路径"></a>默认静态资源路径</h2><p>IDEA双击SHIFT，搜寻类<code>WebMvcAutoConfiguration.class</code>。找到方法<code>addResourceHandlers(ResourceHandlerRegistry registry)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.addResourceHandlers(registry);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();<br>        <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>        <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>            registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>            <span class="hljs-keyword">if</span> (servletContext != <span class="hljs-keyword">null</span>) &#123;<br>                registration.addResourceLocations(<span class="hljs-keyword">new</span> Resource[]&#123;<span class="hljs-keyword">new</span> ServletContextResource(servletContext, <span class="hljs-string">&quot;/&quot;</span>)&#125;);<br>            &#125;<br><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法就会指导SpringBoot如何去寻找静态资源，下面逐步解析下这个方法：</p><blockquote><ul><li>在第一个if判断，说明如果在配置文件配置了静态资源路径就会按照配置的路径寻找资源。比如：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">classpath:/theo_static/**</span><br></code></pre></td></tr></table></figure><p>这样就会去<code>resources.theo_static</code>找静态资源(.html等等)，当然这样完全不推荐！！！因为SpringBoot会默认指定静态资源的路径</p><ul><li><code>this.addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;);</code><br>这段代码说明你可以通过Maven导入webjar静态资源，系统会去<code>***.jar/META-INF/resources/webjars/</code>下寻找静态资源。这种方法也不常用，一般用于导入JQuery.js等资源。</li><li>再往下两行，<code>registration.addResourceLocations(this.resourceProperties.getStaticLocations());</code>则会指引SpringBoot去默认路径寻找静态资源。点开getStaticLocations()，逐渐追溯到变量<code>String[] staticLocations</code>。它由<code>CLASSPATH_RESOURCE_LOCATIONS</code>所定义，其内容为<br><code>&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;</code></li><li>这样我们就找到了系统默认的静态资源路径，即resouces下的resources、static、public文件夹以及添加Web框架后的META-INF/resources文件夹。</li></ul></blockquote><p>综上，我们以后添加静态资源的时候，就随着系统指定的路径添加即可。这样的话我们直接访问localhost:8080/xxx.html就能访问到资源了。</p><p>当然，如果三个文件夹中有同名的静态资源，其之间有<strong>访问优先级</strong>：<code>resources &gt; static &gt; public</code></p><h2 id="classpath：指的是什么？"><a href="#classpath：指的是什么？" class="headerlink" title="classpath：指的是什么？"></a>classpath：指的是什么？</h2><p>这里有篇博客比较详细说明了classpath的指代：<a href="https://blog.csdn.net/qq_33393542/article/details/80322141?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.baidujs">(1条消息) java项目中的classpath到底指向的哪里_不仅仅是说说而已的博客-CSDN博客_classpath</a></p><p>classpath具体指的是什么，需要经过编译后到资源管理器中找到项目根目录中的<code>.classpath</code>文件，一般如下：</p><p><img src="https://img.imgdb.cn/item/6086c0ded1a9ae528fe392f2.jpg" alt=".classpath"></p><p>这就很明白了，classpath指的就是（kind=”src”）所指定的文件，<strong>这里classpath: /resources/就是src/resources或者resource/resources</strong></p><h2 id="制定首页"><a href="#制定首页" class="headerlink" title="制定首页"></a>制定首页</h2><p>访问<code>localhost:8080/</code>得到的内容就是首页内容，之前的默认静态资源路径没有localhost:8080/，这是因为SpringBoot寻找首页是通过另一个方法<code>getWelcomePage()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Resource <span class="hljs-title">getWelcomePage</span><span class="hljs-params">()</span> </span>&#123;<br>    String[] var1 = <span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations();<br>    <span class="hljs-keyword">int</span> var2 = var1.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var3 = <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>        String location = var1[var3];<br>        Resource indexHtml = <span class="hljs-keyword">this</span>.getIndexHtml(location);<br>        <span class="hljs-keyword">if</span> (indexHtml != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> indexHtml;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法也会先获取默认静态资源路径，然后将他和index.html拼接形成首页的完整访问路径。因此我们只需要在三个静态资源文件夹下创建index.html即可作为首页内容。</p><h2 id="静态资源前缀"><a href="#静态资源前缀" class="headerlink" title="静态资源前缀"></a>静态资源前缀</h2><p>在默认情况下，访问静态资源可以直接输入localhost:8080/xxx，但如果涉及到拦截器需要过滤出一条指定路径下的静态资源，就可以加上静态资源前缀：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/res/**</span><br></code></pre></td></tr></table></figure><p>此时需要输入localhost:8080/res/xxx才能访问静态资源。</p><h1 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h1><p>注意到resources/templates，这个文件下的资源是无法被客户端直接访问的，有点类似于WEB-INF下的资源。如果要访问，就需要通过控制器跳转。在SpringMVC中，控制器可以直接return一个字符串，这是因为有视图解析器帮忙拼接路径。SpringBoot中也有一个类似的角色：<strong>Thymeleaf模板引擎</strong>。</p><h2 id="导入thymeleaf"><a href="#导入thymeleaf" class="headerlink" title="导入thymeleaf"></a>导入thymeleaf</h2><p>按照教程安装插件EditStarters：<a href="https://blog.csdn.net/qq_38138069/article/details/102528587">IntelliJ IDEA中如何再次调出springboot的依赖窗口，随时可以根据喜好导入和移除插件</a></p><p>调出以来窗口后，选择Thymeleaf Engines后插入。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>双击SHIFT，搜索<code>ThymeleafProperties</code>，发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;<br></code></pre></td></tr></table></figure><p>这就是视图解析器里的前后缀，但注意只为拼接成<code>.html</code>,因此最好放在templates的文件都以html结尾。</p><h2 id="Thymeleaf语法"><a href="#Thymeleaf语法" class="headerlink" title="Thymeleaf语法"></a>Thymeleaf语法</h2><h1 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h1><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=8">请配合视频食用</a></p><p>在Spring5中，@Configuratio的作用是利用JavaConfig将<strong>注册配置类</strong>装配到IOC中，同时该类下的方法通过@Bean就能将方法“装配”到IOC中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span></span>&#123;<br>    <span class="hljs-meta">@Bean</span><span class="hljs-comment">//方法名作为id,返回类型作为class来装配到IOC,return的new()则相当于Bean注入.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">TZQ</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;谭志强&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在测试类中获取这个Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">JavaConfigTest</span><span class="hljs-params">()</span> </span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringMVCConfig.class);<br>    User tzq = (User) context.getBean(<span class="hljs-string">&quot;TZQ&quot;</span>);<br>    System.out.println(tzq);<br>&#125;<br></code></pre></td></tr></table></figure><p>在SpringBoot2中,@Configuration新增了一个特性:<code>@Configuration(proxyBeanMethods = true)</code>—-组件依赖问题</p><p>如果在注册配置类中有多个组件注册方法，且都装配到了IOC中。这时有一个注册方法需要用到另一个注册方法（即需要用到后一个注册方法所对应的Bean），那么调用的Bean是否是IOC容器中的Bean呢？</p><p><strong>proxyBeanMethods = true</strong>，则答案为是。因为这种情况下Bean的作用域就是单例模式，即IOC容器中一个id只对应唯一的Bean，无论调用多少次注册方法，装配的Bean都一样。那么这样有什么意义呢？前一个Bean会形成对后一个Bean的<strong>组件依赖</strong>。</p><p><strong>proxyBeanMethods = false</strong>，在这种情况下，每次调用都会产生不同的Bean并覆盖之前存在的Bean。前一个Bean调用另一个注册方法后得到的Bean将不同于后一个注册方法生成的Bean，只有后一个Bean才是真正IOC中的Bean。那么将<strong>不存在组件依赖</strong></p><blockquote><p>因为true的情况下，每一次调用注册方法都会询问IOC中是否已存在对应的Bean，这会影响项目启动速度。相比之下false的情况会跳过询问，项目启动速度大幅提升。</p></blockquote><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>在注册配置类上通过<code>@Import(&#123;User.class,DBHelper.class&#125;)</code>可以自动装配这些类型的组件，<strong>组件id就是全类名</strong>。</p><blockquote><p>注意，使用的类都必须要有<strong>无参构造器</strong>！！！</p></blockquote><h2 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h2><p><strong>@ConditionalonBean(name = “User”)**可以使用在注册方法上，调用该方法时就会去判断IOC容器中是否存在id为User的组件，如果存在则执行该方法然后装配对应组件。相反的</strong>@ConditionalOnMissingBean(name = “User”)**则会判断是否不存在id为User的组件。</p><blockquote><p>值得注意的是，如果<strong>注解用在了注册配置类上</strong>，一旦判断不通过，该注册配置类下的所有注册方法都将失效。</p></blockquote><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p><strong>@ImportResource(“classpath:beans.xml”)</strong> 使用在注册配置类上，它可以将<strong>classpath:beans.xml</strong>中的<code>&lt;bean&gt;...&lt;/bean&gt;</code>都转移到注册配置类中，这样就能省取一一搬运到类中再用@Bean装配</p><h1 id="Rest请求源码分析"><a href="#Rest请求源码分析" class="headerlink" title="Rest请求源码分析"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=26">Rest请求源码分析</a></h1><p>在SpringMVC中我们提到过RestFul风格可以做到通过同一个URL，以不同请求方式就可访问到不通的控制器。</p><p>以表单发起请求为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;post请求&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;get请求&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意表单只能以POST和GET方式发起请求，那就意味着最多设置两个控制器分别响应。可是控制器还能配置如PostMappping和DeleteMapping等，那么如何改变表单的请求发起方式呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;delete&quot;</span>&gt;</span> //通过隐藏域传递参数_method，值为DELETE<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;delete请求&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么这个参数是要传给谁呢？答案是<strong>HiddenHttpMethodFilter</strong>，由他来分析请求的具体方法。搜索HiddenHttpMethodFilter.class找到方法<strong>doFilterInternal</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    HttpServletRequest requestToUse = request;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.exception&quot;</span>) == <span class="hljs-keyword">null</span>)&#123;<br>        String paramValue = request.getParameter(<span class="hljs-keyword">this</span>.methodParam);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;<br>            String method = paramValue.toUpperCase(Locale.ENGLISH);<br>            <span class="hljs-keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;<br>                requestToUse = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    filterChain.doFilter((ServletRequest)requestToUse, response);<br>&#125;<br></code></pre></td></tr></table></figure><p>在if判断中，会先判定是否是以POST方式发起的请求再判定请求是否有效。因此<strong>表单的method必须是POST而不是GET！！</strong>，满足后将隐藏域<code>_method</code>的值赋给paramValue，一律转为大写后得到method（值为DELETE）。这时查看DELETE是否被兼容了（ALLOWED_METHODS中有PUT、DELETE、PATCH），兼容就重新包装请求，请求方式就变为了DELETE。这个请求就会被DeleteMapping响应了。</p><p>了解原理之后，我们还需要开启Rest服务才能达到目的。查看<code>WebMvcAutoConfigration.java</code>,找到以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">    prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span><br><span class="hljs-meta">    name = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">    matchIfMissing = false</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OrderedHiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrderedHiddenHttpMethodFilter();<br>&#125;<br></code></pre></td></tr></table></figure><p>先追溯<code>HiddenHttpMethodFilter.class</code>发现没有配置@Bean，说明没有装配到IOC中，那么满足条件，执行其下语句。</p><p>注意<code>@ConditionalOnProperty</code>，这个是查看配置文件中是否存在指定属性，存在才会满足该注解，否则就取默认值<code>matchIfMissing = false</code>。显然配置文件中并没有配置spring.mvc.hiddenmethod.filter.enabled，那么Rest服务就不会开启。前往application.yml添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">hiddenmethod:</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>至此我们就可以做到访问同一个URL，却能分别对应到不同控制器了。</p><blockquote><p>以上内容只是针对表单请求，如果其他软件（Postman）可以直接发送DELETE、PUT请求，就只需要开启Rest服务即可。</p></blockquote><h1 id="搭建一个自己的后台管理系统"><a href="#搭建一个自己的后台管理系统" class="headerlink" title="搭建一个自己的后台管理系统"></a>搭建一个自己的后台管理系统</h1><p>我们可以在<a href="https://www.php.cn/xiazai/code/bootstrap">Bootstrap</a>或Laiyu中下载后台模板或者组件，将静态资源文件夹如css、js、images、front复制到static文件夹之下。将html的一些基础页面放到template目录下。这样就能基本的套用这套模板了。详细可看视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=44">模板套用至SpringBoot</a>，视频中所用模板下载：[AdminEx .rar](/download/AdminEx .rar)</p><p>打开网站可能会不如视频中的流畅，这是因为一些文件中通过链接引用了网络资源，这样每次加载就需要先去请求网络资源，要么先将该资源下载至本地，要么就将该链接引用删除。这里我们删去css/style.css中的第一行import</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-attribute">http</span>://fonts.googleapis.com/css?family=Open+<span class="hljs-attribute">Sans</span>:<span class="hljs-number">400%</span><span class="hljs-number">2</span>C300%<span class="hljs-number">2</span>C300italic%<span class="hljs-number">2</span>C400italic%<span class="hljs-number">2</span>C600%<span class="hljs-number">2</span>C600italic%<span class="hljs-number">2</span>C700%<span class="hljs-number">2</span>C700italic%<span class="hljs-number">2</span>C800%<span class="hljs-number">2</span>C800italic);<br></code></pre></td></tr></table></figure><h2 id="公共页抽取"><a href="#公共页抽取" class="headerlink" title="公共页抽取"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=45">公共页抽取</a></h2><p>可以看到一个后台管理界面中，有一些固定部分如左侧导航栏，顶部信息栏，而其余部分是随着不同请求返回不同结果</p><p><img src="https://pic.imgdb.cn/item/6094f9e3d1a9ae528fe365b5.jpg"></p><p>对于这些公共内容，我们可以抽取到一个commom.html中，然后给每一组件冠以唯一id，这样在具体界面直接引用该组件就行。</p><p>我们利用元素审查，分别选中左侧导航栏与顶部信息栏，找到对应的代码段</p><p><img src="https://pic.imgdb.cn/item/6094fbd8d1a9ae528ff554a2.jpg" alt="ctrl+shift+C快速打开审查元素"></p><p>通过这种方式我们就可以将这些公共代码段复制到common.html中，但注意除了这些显示的组件每个界面的样式也是一致的，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--common--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/style.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/style-responsive.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;</span><br><span class="hljs-comment">&lt;!--[if lt IE 9]&gt;</span><br><span class="hljs-comment">&lt;script src=&quot;js/html5shiv.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-comment">&lt;script src=&quot;js/respond.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-comment">&lt;![endif]--&gt;</span><br><br><span class="hljs-comment">&lt;!-- Placed js at the end of the document so the pages load faster --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-1.10.2.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-ui-1.9.2.custom.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery-migrate-1.2.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/bootstrap.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/modernizr.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/jquery.nicescroll.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--common scripts for all pages--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/scripts.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为了以后调试方便，我们把所有href和src都替换成Thymeleaf样式，如<code>&lt;link th:href=&quot;@&#123;/css/style.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;</code></p><p>但注意要提前添加xml约束<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code>。最终完成情况：<a href="/download/common.html">common.html</a></p><p>可能注意到既然是以组件的形式插入到其他页面中去，我们就要把一些标签以<code>&lt;div&gt;...&lt;/div&gt;</code>的闭合标签框起来，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonscript&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/jquery-1.10.2.min.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/jquery-ui-1.9.2.custom.min.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/jquery-migrate-1.2.1.min.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/bootstrap.min.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/modernizr.min.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/jquery.nicescroll.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--common scripts for all pages--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/js/scripts.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就相当于把这些js文件打包成了一个组件，在index.html中需要添加组件时只需要在合适位置使用以下之一即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">#1   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span> = <span class="hljs-string">&quot;common :: #commonscript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>#2   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;common :: #commonscript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一种方式会将<code>&lt;div th:replace = &quot;common :: #commonscript&quot;&gt;&lt;/div&gt;</code> 全部删去，然后把整个组件加上（包括组件的div闭合标签）；然而第二种方式将会保留<code>&lt;div th:include=&quot;common :: #commonscript&quot;&gt;&lt;/div&gt;</code>的div标签，标签的包含内容用组件内容填充（不包括div闭合标签）。</p><p>这部分知识还有部分没有涉及，如id=“commonscript”可以替换成th:fragment=”commonscript”，那么引用组件方式也会有些许不同。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器与过滤器类似，我们在SSM整合的时候曾配置过过滤器用来解决乱码问题，但他是直接在配置文件中配置的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Spring中我们提到，除了配置文件直接配置，我们还能通过JavaConfig配置组件到IOC容器中，这种方式将会在SpringBoot中广泛使用，因为一个JavaConfig类继承了WebMvcConfigurer接口，就能一致通过addXXX()方法来配置你想要的组件了。</p><p>以这种方式，我们创建：<code>Config/AdminWebConfig.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminWebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> LoginInterceptor())<span class="hljs-comment">//添加的拦截器</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<span class="hljs-comment">//拦截器拦截路径，即所有资源路径都要经过拦截器</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/css/**&quot;</span>, <span class="hljs-string">&quot;/fonts/**&quot;</span>, <span class="hljs-string">&quot;/images/**&quot;</span>, <span class="hljs-string">&quot;/js/**&quot;</span>);<br>        <span class="hljs-comment">//拦截器的放行路径，这里需要放行登录请求和所有静态资源，避免登入页缺失渲染</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>覆写WebMvcConfigurer中的默认方法可以不用在方法名上添加@Bean，如果你需要添加独有的组件就必须添加注解@Bean，因为只有被IOC接管的组件才会在项目中生效。</p><p>以上只是写了拦截器的拦截路径和放行路径，具体拦截的处理还没有定义。我们写一个<code>Interceptor/LoginInterceptor.java</code>保证未登入的用户会被强制登入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-comment">/*方法执行前*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.info(<span class="hljs-string">&quot;preHandler拦截了&#123;&#125;&quot;</span>,request.getRequestURI());<span class="hljs-comment">//控制台打印信息</span><br>        HttpSession session = request.getSession();<br>        Object loginUser = session.getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == loginUser) &#123;<span class="hljs-comment">//查询到用户之前没有登陆过</span><br>            session.setAttribute(<span class="hljs-string">&quot;loginError&quot;</span>,<span class="hljs-string">&quot;请先登入&quot;</span>);<span class="hljs-comment">//将提示信息发送到Session,在前端就可以展示了</span><br>            response.sendRedirect(<span class="hljs-string">&quot;/&quot;</span>);<span class="hljs-comment">//重定向到登入页</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*方法执行后*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;<br><br>    <span class="hljs-comment">/*页面渲染后*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h1><p>导入JDBC场景</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>数据库驱动是需要额外导入的,因为SpringBoot不知道你会连接哪个数据库，同时也要注意数据库版本要和数据驱动的版本对应，这里以MySQL为例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ctrl+左击访问版本仲裁，知道了SpringBoot托管的mysql驱动版本为8.0.23，查询本机Mysql版本为5.7.24。官方文档说明：Connector/J 8.0 provides compatibility with all the functionality of MySQL 5.5, 5.6, 5.7, and 8.0，也就是说8.0的驱动可以兼容所有版本的MySQL数据库。</p><p>接下来需要在pom.xml中配置数据库信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">datasource:</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/matlab</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">tzq1635886602</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-string">//8.0+的数据库驱动需要加上cj</span><br></code></pre></td></tr></table></figure><h2 id="配置版Mybatis"><a href="#配置版Mybatis" class="headerlink" title="配置版Mybatis"></a>配置版Mybatis</h2><p>创建<code>com.theo.Mapper.AccountMapper.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountMapper</span> </span>&#123;<br>    <span class="hljs-function">Account <span class="hljs-title">queryAccount</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Mapper注解表示将该接口类+配置类注入到IOC容器中，也就是说服务层如果要取用Mapper将不需要利用事先的MybatisUtils.getsession()以及sqlsession.getMapper(Account.class)来获取接口类的实例了，因为SpringBoot自动做了这一步，然后我们只需要通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>AccountMapper accountMapper;<br></code></pre></td></tr></table></figure><p>即可直接从容器中获取，accountMapper就可直接调用所有接口方法。</p><blockquote><p>这种方式可能IDEA会报错：Could not autowire. No beans of ‘AccountMapper’ type found.</p><p>这是编译器的问题，不用管。</p></blockquote><p>接下来创建<code>resources.Mybatis.Mapper.AccountMapper.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.theo.Mapper.AccountMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryAccount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Account&quot;</span>&gt;</span><br>        SELECT * FROM matlab.patient where username = #&#123;username&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的映射AccountMapper中的接口方法。此后我们在application.yml中配置Mybatis的配置信息，以此代替mybatis-config.xml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:Mybatis/Mapper/*.xml</span><br>  <span class="hljs-attr">typeAliasesPackage:</span> <span class="hljs-string">com.theo.pojo</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>当然你也可以存在mybatis-config.xml，其中填上别名，mapper映射地址等等，但同时要加上配置<code>config-location: classpath:Mybatis/mybatis-config.xml</code>，这样的话就一定要删除configuration这一配置！！！！两者不能共存！！！！！！！！</p></blockquote><h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一个SpringBoot程序&quot;&gt;&lt;a href=&quot;#第一个SpringBoot程序&quot; class=&quot;headerlink&quot; title=&quot;第一个SpringBoot程序&quot;&gt;&lt;/a&gt;第一个SpringBoot程序&lt;/h1&gt;&lt;p&gt;SpringBoot英文官方文档：&lt;</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://example.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://example.com/2021/03/31/SpringMVC/"/>
    <id>http://example.com/2021/03/31/SpringMVC/</id>
    <published>2021-03-31T01:45:04.000Z</published>
    <updated>2021-05-03T09:40:47.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h1><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><ul><li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li><li>是将业务逻辑、数据、显示分离的方法来组织代码。</li><li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li><li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li></ul><p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p><p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p><p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p><p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p><h2 id="为什么SpringMVC"><a href="#为什么SpringMVC" class="headerlink" title="为什么SpringMVC"></a>为什么SpringMVC</h2><p>如果使用Servlet开发过JavaWeb项目，就能明白这种开发方式的功能局限性与低复用性，也就是说每添加一个功能就需要新增一个Servlet，同时还要配备好相应的环境。为了降低代码与环境的耦合度，SpringMVC应运而生。</p><p>当然，连接前后端脱离不开Servlet。SpringMVC本质也是围绕<strong>DispatcherServlet</strong>设计的。而DispatcherServlet负责将前端请求分发给对应控制器（Controller类，业务逻辑处理则是类中的各个方法）。相比于原先前端请求寻找Servlet，并在Servlet的doPost()完成业务逻辑处理，解耦程度已经有了大幅提升。</p><p><img src="https://img.imgdb.cn/item/606806fb8322e6675ce4462d.jpg" alt="SpringMVC初略流程"></p><p>SpringMVC的作用原理可以和Servlet的工作原理比较，可以发现以下不同：</p><ul><li><p>Servlet是通过url可以直接找到处理该请求的控制器，通过注释<code>@WebServlet</code>或者映射<code>&lt;servlet-mapping&gt;</code>配置路径。而SpringMVC是将所有请求统一定位到DispatcherServlet，再由DispatcherServlet负责找到控制器。</p></li><li><p>Servlet返回前端页面有四种响应方法，其中主要是重定向或跳转，为前端页面传值通过转发的<code>request.setAttribute()</code>，再由前端jsp文件的<code>request.getAttribute()</code>获取值。而SpringMVC把需要传的值和响应结果全部装在ModelAndView中，再由视图解析器处理并最后返回给用户。</p></li></ul><h2 id="SpringMVC实践"><a href="#SpringMVC实践" class="headerlink" title="SpringMVC实践"></a>SpringMVC实践</h2><p>源码下载：<a href="/download/SpringMVC-Hello.rar">SpringMVC-Hello.rar</a>    视频教学：<a href="https://www.bilibili.com/video/BV1aE41167Tu?p=6">第一个SpingMVC</a>    配套学习笔记：<a href="https://mp.weixin.qq.com/s/8ddT6FD0Y4f3XdbEz0aqpQ">狂神说SpringMVC02：第一个MVC程序</a></p><p>新建maven父项目SpringMVC，在pom.xml中配置好以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>又新建maven子项目SpringMVC-Hello，添加web框架支持生成Web目录。在IDEA中配置好Tomcat服务器并注意添加好Artifacts。<strong>因为这个Web项目是由Maven管理的，所以一定要手动在File 》 Project Structure中为本项目手动添加lib目录，并将jar包全部导入该目录下（点击<code>+</code>导入），否则会导致404问题</strong></p><img src="https://img.imgdb.cn/item/6067e4708322e6675cc3545f.jpg" style="zoom:50%;" /><ul><li><strong>配置web.xml，注册DispatcherServlet</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--1.注册DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span><br>    <span class="hljs-comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里仅是注册了DispatcherServlet，内部逻辑通过<code>&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;</code>定义。</p><ul><li><strong>初始化DispatcherServlet</strong></li></ul><p>在<code>main.resource.springmvc-servlet.xml</code>中配置以下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--添加处理映射器和处理器适配器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--配置视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置请求与处理器的对应关系--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.Controller.HelloController&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>简单来说：<code>HandlerMapping</code>会将URL对应到<code>id=&quot;/hello&quot;</code>，<code>HandlerAdapter</code>会适配对应的处理器<code>class=&quot;com.theo.Controller.HelloController&quot;</code>。总的来说，这两个的作用就是找到处理请求的处理器。</p><ul><li><strong>编写控制器</strong></li></ul><p>控制器继承Controller接口，需要返回ModelAndView，这里我们先不调用Moudle层。创建<code>com.theo.Controller.HelloController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>        <span class="hljs-comment">//业务代码</span><br>        modelAndView.addObject(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;HelloSpringMVC&quot;</span>);<br>        <span class="hljs-comment">//视图跳转</span><br>        modelAndView.setViewName(<span class="hljs-string">&quot;Welcome&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个控制器需要交付给SpringIoC容器的，以后每写一个控制器就要注意配置一个Bean。就像每一个Servlet都要配置路径一样。</p><p>ModelAndView两个功能，装入业务处理结果和指示跳转页面。<code>modelAndView.addObject(&quot;message&quot;, &quot;HelloSpringMVC&quot;)</code>不用多说，到时可以在jsp中通过<code>$&#123;message&#125;</code>直接获取。值得注意的是视图跳转并没有用页面的绝对路径，因为生成绝对路径这件事在视图解析器做了。</p><p>回到<code>springmvc-servlet.xml</code>配置的视图解析器，配置的两个属性分别是拼接前缀和拼接后缀，这是用来将<code>Welcome</code>拼接成<code>/WEB-INF/jsp/Welcome.jsp</code>,这样就能精确返回页面给用户了。</p><ul><li><strong>编写返回页面</strong></li></ul><p>创建返回页面：<code>web/WEB-INF/jsp/Welcome.jsp</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>$&#123;message&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><p>启动Tomcat，访问<a href="http://localhost:8080/SpringMVC_Hello_war_exploded/hello%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%9C%60HelloSpringMVC%60">http://localhost:8080/SpringMVC_Hello_war_exploded/hello即可获得结果`HelloSpringMVC`</a></p><h2 id="SpringMVC执行原理详解"><a href="#SpringMVC执行原理详解" class="headerlink" title="SpringMVC执行原理详解"></a>SpringMVC执行原理详解</h2><p>理清楚SpringMVC的执行流程后，我们再细作剖析SpringMVC的执行原理：</p><ol><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p><p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello%EF%BC%8C%E5%A6%82%E4%B8%8Aurl%E6%8B%86%E5%88%86%E6%88%90%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A">http://localhost:8080/SpringMVC/hello，如上url拆分成三部分：</a></p><p><a href="http://localhost:8080服务器域名；SpringMVC部署在服务器上的web站点；hello表示控制器">http://localhost:8080服务器域名；SpringMVC部署在服务器上的web站点；hello表示控制器</a></p></li><li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p></li><li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，例子中解析出需要找到hello对应的控制器。</p></li><li><p>HandlerExecution将解析后的信息传递给DispatcherServle等。</p></li><li><p>HandlerAdapter按照hello找到对应的控制器。</p></li><li><p>Handler让具体的Controller执行。</p></li><li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p></li><li><p>HandlerAdapter将视图逻辑名或模型（ModelAndView）传递给DispatcherServlet。</p></li><li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p></li><li><p>视图解析器将解析后的逻辑视图名传给DispatcherServlet。</p></li><li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p></li><li><p>最终视图呈现给用户。</p></li></ol><p><img src="https://img.imgdb.cn/item/606807968322e6675ce53ee1.jpg"></p><h1 id="注解开发SpringMVC"><a href="#注解开发SpringMVC" class="headerlink" title="注解开发SpringMVC"></a><a href="https://www.bilibili.com/video/BV1aE41167Tu?p=7">注解开发SpringMVC</a></h1><p>在编写控制器部分我们提到了：每写一个控制器就要注意配置一个Bean。就像每一个Servlet都要配置路径一样。</p><p>使用注解将不再需要亲自到配置文件中装配Bean了，类似于Servlet中用到的@WebServlet</p><p>新建Moudel：<a href="/download/SpirngMVC-annotation.rar">SpringMVC-annotation</a>，添加web支持以及手动导入lib的jar包！！！</p><p>由于Maven可能存在资源过滤的问题，我们将该Moudel的pom.xml配置完善</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>配置web.xml，注册DispatcherServlet</strong></li></ul><p>和配置版一样没有区别。这里解释下*<em>/ 和 /\</em> 的区别**</p><p>&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回的jsp视图再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</p><ul><li><strong>初始化DispatcherServlet</strong></li></ul><p>在<code>main.resources.sprinmvc-servlet</code>下额外添加context和mvc的约束。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.theo.Controller&quot;</span>/&gt;</span><br>   <span class="hljs-comment">&lt;!-- 让SpringMVC不处理静态资源如:.js .css .mp3 .mp4 .html--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span> /&gt;</span><br>   <span class="hljs-comment">&lt;!-- 自动配置好HandlerMapping和HandlerAdapter--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以发现这里Controller没有装配到SpringIoC中。</p><blockquote><p>注意，之后的**控制器用了@RequestMapping及其衍生注解后，将不再需要配置<code>&lt;mvc:default-servlet-handler /&gt;</code>和<code>&lt;mvc:annotation-driven /&gt;</code>**。因为这两个的工作就是根据请求找到处理器，而@RequestMapping就能直接在处理器上标注好了需要处理的请求。</p></blockquote><ul><li><strong>编写Controller</strong></li></ul><p>编写一个Java控制类：<code>com.theo.Controller.HelloController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-comment">//这是Spring中@Component的衍生注解!!!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hellocontroller</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;HelloSpringMVC&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/nihao&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">nihao</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;你好SpringMVC&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>@Controller是为了让Spring IOC容器初始化时自动扫描到，当然前提是配置好了自动扫描包的路径。</p></li><li><p>@RequestMapping是为了映射请求路径，这里因为只有方法上都有映射所以访问时应该是/hello；</p></li><li><p>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</p></li><li><p>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/<strong>hello</strong>.jsp。</p></li></ol><p>很明显地注意到，注解下的Controller并没有显式地返回ModelAndView，而是不同方法返回了返回页面的字符串。其实暗地下@Controller帮我们创建了ModelAndView并打包好了，底层的逻辑还是一样的。</p><p>还有一点。通过注解我们将原本的一个类就是一个控制器完全简化成了<strong>一个方法就是一个控制器</strong>。这里就很简便的创造出了两个控制器，分别对应处理/hello和/nihao两个请求</p><blockquote><p>还有一点很重要!!方法的参数设置不单单只有Model，设置其他基本类型参数也能接受，而且是直接从网页请求中获取！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/sum&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;获取结果为a+b=&quot;</span>+(a+b));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>访问页面<a href="http://localhost:8080/SpirngMVC_annotation_war_exploded/sum?a=1&amp;b=2%EF%BC%8C%E5%9C%A8%E8%AF%B7%E6%B1%82%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0a=1%EF%BC%8Cb=2%E3%80%82%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BB%93%E6%9E%9Ca+b=3%E3%80%82">http://localhost:8080/SpirngMVC_annotation_war_exploded/sum?a=1&amp;b=2，在请求中传递参数a=1，b=2。返回页面会出现结果a+b=3。</a></p><p>相比于Servlet，这将省去<code>int a = request.getParameter(&quot;a&quot;)</code>的步骤！！！处理表单提交的请求时非常管用！！！</p></blockquote><ul><li><strong>编写返回页面</strong></li></ul><p>和配置版一样，简单通过<code>$&#123;message&#125;</code>获取信息就可。用户输入/hello和/nihao能获得不同字符串。</p><h1 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h1><p>像前面的URL<a href="http://localhost:8080/SpirngMVC_annotation_war_exploded/sum?a=1&amp;b=2%EF%BC%8C%E8%BF%99%E7%A7%8DGET%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%BC%9A%E5%BE%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%8C%E8%80%8C%E4%B8%94%E4%BC%A0%E5%8F%82%E5%A6%82%E6%9E%9C%E6%AF%94%E8%BE%83%E5%A4%9A%EF%BC%8C%E6%95%B4%E4%B8%AAURL%E5%B0%B1%E4%BC%9A%E5%BE%88%E5%86%97%E9%95%BF%E3%80%82%E4%BD%BF%E7%94%A8RestFul%E9%A3%8E%E6%A0%BC%E5%90%8E%E8%BF%99%E6%9D%A1URL%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%94%B9%E4%B8%BAhttp://localhost:8080/SpirngMVC_annotation_war_exploded/sum/1/2">http://localhost:8080/SpirngMVC_annotation_war_exploded/sum?a=1&amp;b=2，这种GET请求方式会很不安全，而且传参如果比较多，整个URL就会很冗长。使用RestFul风格后这条URL就可以改为http://localhost:8080/SpirngMVC_annotation_war_exploded/sum/1/2</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/sum/&#123;a&#125;/&#123;b&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> a,<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> b, Model model)</span> </span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;a+b=&quot;</span>+(a+b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就算应用了RestFul风格，之前的GET请求方式将无法找到这个控制器。</p><p>RestFul风格还有别的玩法，通过改变@ResquestMapping实现只接受GET/POST/DELETE/PUT/PATCH请求。</p><blockquote><p>@GetMapping()    @PostMapping()    @DeleteMapping()    @PutMapping()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sum/&#123;a&#125;/&#123;b&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sum_get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> a,<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> b, Model model)</span> </span>&#123;...&#125;<br><span class="hljs-meta">@PostMapping(&quot;/sum/&#123;a&#125;/&#123;b&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sum_post</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> a,<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> b, Model model)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这样即使是访问同一地址，使用不同的请求方式也会调用不同的控制器，从而实现同一地址的复用。</p><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><h2 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h2><p>在控制器中,我们直接<code>return &quot;Welcome&quot;</code>,视图解析器就会帮我们拼接成目标页面，这相当于一种转发，因为你可以发现地址栏是不变的<br>但是如果不打算转发到一个jsp页面，就不能通过视图解析器。</p><blockquote><p><code>return “forward:/sum/1/1”</code>：以这种形式就能转发到另一个控制器，而不会被视图解析器拼接了。</p><p><code>reuturn &quot;redirect:/Welcome.jsp&quot;</code>：这种形式就是重定向到一个页面，也不会通过视图解析器的拼接。</p></blockquote><h2 id="接收请求参数"><a href="#接收请求参数" class="headerlink" title="接收请求参数"></a>接收请求参数</h2><h4 id="RequestParam-请求参数"><a href="#RequestParam-请求参数" class="headerlink" title="@RequestParam(请求参数)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=29">@RequestParam(请求参数)</a></h4><p>控制器方法可以设置参数，然后前端在请求中设置参数值，后端就能获取参数了。但是如果前端请求的属性名与控制器方法的属性名不一致，就会报500错误。这样的话，前后端光是在参数名这一方面就需要严格把控，前后端很难分离。</p><p>我们可以在后端制定标准，严格限制前端请求的参数名必须一致，因为后端总与数据库连接，以数据库为准的参数名可以大量减少数据库方面的调试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/UserName&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">username</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String name,Model model)</span> </span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样前端请求必须通过<code>.../UserName?username=TZQ</code>来传递参数，否则报400错误。</p><p>如果我们的项目连接了数据库，有一个实体类User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端通过表单提交的方式发送请求，我们当然可以在方法中设置三个接收参数并一一配置@RequestParam。但我们也可以只设置一个接收参数<code>User user</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/User&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">(User user,Model model)</span> </span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>, user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式要特别注意表单中设置的属性名也要和实体类的属性名相对应，否则无法自动装配成User对象。</p><h4 id="PathVariable-路径变量"><a href="#PathVariable-路径变量" class="headerlink" title="@PathVariable(路径变量)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=29">@PathVariable(路径变量)</a></h4><p>这种注解常搭配RestFul风格使用</p><h4 id="RequestHeader-请求头"><a href="#RequestHeader-请求头" class="headerlink" title="@RequestHeader(请求头)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=29">@RequestHeader(请求头)</a></h4><p>打开F12可以发现除了设置的参数，默认添加的请求头也可以获取。请求头也是一个个键值对形成的集合，我们想获取User-Agent或是Content-type就可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/request&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String agent)</span> </span>&#123;<br>    System.out.println(agent);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.51</p></blockquote><h4 id="CookieValue-Cookie值"><a href="#CookieValue-Cookie值" class="headerlink" title="@CookieValue(Cookie值)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=29">@CookieValue(Cookie值)</a></h4><p>如果浏览器有我们预先给的Cookie，因为每次请求都会带上该Cookie，我们就可以接收该Cookie值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/cookie&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookie</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;Idea-5e3b9fc0&quot;)</span> String cookie)</span> </span>&#123;<br>    System.out.println(cookie);<span class="hljs-comment">//IDEA默认会设置Cookie</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>4ca7a654-6a60-4884-a1eb-7004e64dc8be</p></blockquote><h4 id="RequestBody-请求体"><a href="#RequestBody-请求体" class="headerlink" title="@RequestBody(请求体)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=29">@RequestBody(请求体)</a></h4><p>因为只有POST方式才有请求体，我们通过表单提交POST请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/user_post&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">user_post</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String body)</span> </span>&#123;<br>    System.out.println(body);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>username=tzq&amp;password=123456789</p></blockquote><h4 id="RequestAttribute-请求域"><a href="#RequestAttribute-请求域" class="headerlink" title="@RequestAttribute(请求域)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=30">@RequestAttribute(请求域)</a></h4><p>这种多用于跳转页面后获取请求域带来的值，比如@RequestMapping(“/before”)的控制器要转发到@RequestMapping(“/after”)的控制器，before控制器先设置HttpServletRequest request并放入键值对，随后通过return ”forword: /after“，after控制器便可以用@RequestAttribute(“key”) String key获取键值对。</p><h4 id="MatrixVariable-矩阵变量"><a href="#MatrixVariable-矩阵变量" class="headerlink" title="@MatrixVariable(矩阵变量)"></a><a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=31">@MatrixVariable(矩阵变量)</a></h4><p>你可能会见到这样的请求：localhost:8080/user;age=20;name=tzq。分号隔离的就是矩阵变量。</p><p>矩阵变量很少用，建议看视频。</p><h2 id="数据回显三种方式"><a href="#数据回显三种方式" class="headerlink" title="数据回显三种方式"></a>数据回显三种方式</h2><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p>使用配置版SpringMVC写控制器时需要返回ModelAndView，可以返回去回顾下。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>使用注解版SpringMVC写控制器是用Model来装返回结果的，这种方式比较常用。</p><h3 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h3><p>继承了LinkMap。没屁用，有时间我再回来补充。</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>在注解版SpringMVC中，可以通过@ResponseBody指示控制器返回的字符串不通过视图解析器，这样也就没必要添加参数Model了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span></span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">123</span>,<span class="hljs-string">&quot;谭志强&quot;</span>);<br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>这种回显方式因为是直接将字符串放回到页面上，不经过视图解析器的转发，所以不会走<code>web.xml</code>配置的过滤器。这样就仍然会出现中文乱码的问题。</p><h2 id="解决乱码"><a href="#解决乱码" class="headerlink" title="解决乱码"></a>解决乱码</h2><p>Servlet解决乱码是会设置一层过滤器专门处理请求和响应的中文乱码问题，在Spring中可以在<code>web.xml</code>配置文件设置这种过滤器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一定要注意<code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code>，如果单写<code>/</code>是不能过滤所有页面的!!!!</p><h2 id="为什么有些资源不通过过滤器？"><a href="#为什么有些资源不通过过滤器？" class="headerlink" title="为什么有些资源不通过过滤器？"></a>为什么有些资源不通过过滤器？</h2><ul><li><code>/</code>与<code>/*</code>有什么区别？为什么乱码过滤器设置<code>/*</code>而注册DispatcherServlet时设置<code>/</code>？个人理解如下：</li></ul><p>如果我们访问网页<a href="http://localhost:8080/SpirngMVC_annotation_war_exploded/user%EF%BC%8C%E8%BF%99%E6%97%B6DispatcherServlet%E6%97%A0%E8%AE%BA%E9%85%8D%E7%BD%AE%60/%60%E8%BF%98%E6%98%AF%60/*%60%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E9%83%BD%E4%BC%9A%E8%BF%9B%E5%85%A5DispatcherServlet%E3%80%82%E4%B9%8B%E5%90%8E%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E8%BF%9B%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8E%EF%BC%8C%E7%94%B1%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%E8%BD%AC%E5%8F%91%E5%88%B0%E5%8F%A6%E4%B8%80%E9%A1%B5%E9%9D%A2http://localhost:8080/SpirngMVC_annotation_war_exploded/WEB-INF/jsp/Welcome.jsp%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E8%BF%98%E4%BC%9A%E5%B0%9D%E8%AF%95%E8%B5%B0%E4%B8%80%E9%81%8DDispathcerServlet%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E6%97%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E6%98%AF%60/*%60%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E5%B0%B1%E8%BF%98%E4%BC%9A%E8%BF%9B%E5%85%A5DispatcherServlet%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BC%9A%E8%BF%94%E5%9B%9E%E7%BB%99%E5%89%8D%E7%AB%AF%E4%BA%86%E3%80%82">http://localhost:8080/SpirngMVC_annotation_war_exploded/user，这时DispatcherServlet无论配置`/`还是`/*`，这个请求都会进入DispatcherServlet。之后这个请求进入控制器后，由视图解析器转发到另一页面http://localhost:8080/SpirngMVC_annotation_war_exploded/WEB-INF/jsp/Welcome.jsp，这个请求还会尝试走一遍DispathcerServlet过滤器，如果这时配置的是`/*`，那么这个页面就还会进入DispatcherServlet，而不会返回给前端了。</a></p><p>同样的，对于乱码过滤器，他是要求所有请求都不产生乱码问题，因而这里必须配置<code>/*</code>!!!!!</p><blockquote><p>总结来说，如果请求是由前端通过地址栏发过来的，他将通过所有过滤器，如果控制器做出了转发或重定向的处理，新请求会通过<code>/*</code>的过滤器。而return返回就类似于PrintWriter()，既不是转发也不是重定向，这样就不会走任何过滤器（包括乱码过滤器）。所以return返回就会产生乱码</p></blockquote><h3 id="return返回的乱码解决方法"><a href="#return返回的乱码解决方法" class="headerlink" title="return返回的乱码解决方法"></a>return返回的乱码解决方法</h3><ul><li><strong>对单处理器解决乱码</strong></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@ResponseBody<br>@RequestMapping(<span class="hljs-keyword">value</span>=&quot;/user&quot;,produces=&quot;application/json;charset=utf-8&quot;)<br><span class="hljs-built_in">public</span> String <span class="hljs-keyword">user</span>()&#123;<br>    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(<span class="hljs-number">123</span>,&quot;谭志强&quot;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>.toString();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>匹配解决乱码</strong></li></ul><p>在<code>springmvc-servlet.xml</code>中添加配置，这能解决所有处理器的return返回的乱码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;failOnEmptyBeans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是SpringMVC&quot;&gt;&lt;a href=&quot;#什么是SpringMVC&quot; class=&quot;headerlink&quot; title=&quot;什么是SpringMVC&quot;&gt;&lt;/a&gt;什么是SpringMVC&lt;/h1&gt;&lt;h2 id=&quot;什么是MVC&quot;&gt;&lt;a href=&quot;#什么是MVC&quot;</summary>
      
    
    
    
    
    <category term="SSM框架" scheme="http://example.com/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring5</title>
    <link href="http://example.com/2021/03/22/Spring5/"/>
    <id>http://example.com/2021/03/22/Spring5/</id>
    <published>2021-03-22T01:20:08.000Z</published>
    <updated>2021-05-03T07:09:39.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h2><p><strong>控制反转IoC(inversion of Control)，是一种设计思想，DI（依赖注入）是实现IoC的一种方式。</strong></p><p>在没有IoC的程序中，对象的创建与对象之间的关系完全是由背后的程序控制，控制反转后会将对象的创建转移给用户。</p><p>之前在MyBatis的学习中，采用XML方式配置Bean，Bean的定义信息和实现是分离的，然而采用注解可以将实现整合到Bean中，这样就达到了零配置的目的。</p><h2 id="IOC代码实现"><a href="#IOC代码实现" class="headerlink" title="IOC代码实现"></a>IOC代码实现</h2><p>源码下载：<a href="/download/Spring-ioc.rar">Spring-ioc.rar</a></p><h3 id="非IOC思想"><a href="#非IOC思想" class="headerlink" title="非IOC思想"></a>非IOC思想</h3><p>先在<code>com.theo.dao</code>下创建<code>UserDao</code>接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应<code>com.theo.ropo</code>下创建<code>User</code>的JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次不同于MyBatis的以配置文件方式实现接口类方法，我们创建实现类<code>UserDaoimpl</code>在<code>dao</code>包下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoimpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">GetUser</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start GetUser&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在测试类中：以传统方式我们需要<code>UserDao user = new UserDaoimpl();</code>后才能调用<code>GetUser()</code>。这或许看起来很合理，因为我们都一直是这么做的。但试想顾客要改变需求，我们需要新增<code>UserDaoimpl2</code>，然后在测试类中重新new对象再调用方法。<strong>这就造成了需要频繁更动测试类代码，主要是因为要new对象</strong>。</p><p>Spring的Bean容器可以在配置文件帮你实例化各种类，然后测试类中就只需要从容器中取对象即可。</p><h3 id="bean-xml"><a href="#bean-xml" class="headerlink" title="bean.xml"></a>bean.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>resource</code>下新建<code>bean.xml</code>(名字随意)，先填写以上配置内容，说明该配置文件下的Bean都会存放在Spring容器中。</p><p>通过<code>&lt;bean&gt;</code>标签可以实例化<strong>各种类</strong>(不只是JavaBean，还可以是Dao层的实现类等等)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tzq&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234567&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserDaoimpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.dao.UserDaoimpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserDaoimpl1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.dao.UserDaoimpl1&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><code>id</code>就是实例化类的对象名，<code>class</code>就是需要实例化的类名，需要填写全限域名。等于说一个bean标签就做了<code>UserDao UserDaoimpl = new UserDaoimpl();</code>这么一件事。</p><blockquote><p>对于没有变量的类，bean标签只需要指明id和class即可。对于有变量的类，需要通过property标签一一赋值,特殊的：如果变量类型也是类，则需要通过<code>ref=&quot;id&quot;</code>来赋值，其中<code>id</code>就是已经被实例化的类，如<code>UserDaoimpl</code>。</p></blockquote><p>配置完bean标签后，我们来看下相比传统方法，我们如何调用<code>GetUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br>UserDao userDaoimpl = (UserDao) context.getBean(<span class="hljs-string">&quot;UserDaoimpl&quot;</span>);<br>userDaoimpl.GetUser();<br></code></pre></td></tr></table></figure><p>第一步是获取Bean容器，其中有各种已经实例化好的对象。第二步通过id直接获取对象，默认返回Object，需要强转类型。</p><p>可能现在并不能看出这种方式能有什么特别优秀的地方，如果项目中再新添Controller层（用来调用Dao层方法），这样测试类中只需要拿Controller层的对象，然后如果用户需要使用<code>UserDaoimpl2</code>的功能，就只需要在<code>bean.xml</code>的Controller的bean标签中修改ref值。这样测试类中的代码完全不需要动！！！</p><p>这样就展现出了与传统方法不同的点，也就是IoC的基本思想：<strong>对象由Spring来创建，管理，装配！</strong></p><h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><ul><li><strong>别名</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserDaoimpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.dao.UserDaoimpl&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;UserDao&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>通过取别名，<code>getBean()</code>就能通过别名来取，可以去多个别名，之间用逗号分隔。</p><ul><li><strong>import</strong></li></ul><p>如果多人开发不同类，分别写了不同<code>bean.xml</code>，整合这些配置文件时只需要在主配置文件<code>applicationContext.xml</code>中<code>&lt;import resource=&quot;bean.xml&quot;&gt;</code>，同时创建Bean容器时改成<code>applicationContext.xml</code>即可获取所有子配置文件中的对象了。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>我们创建一个拥有各种类型的属性的JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    Address address;<span class="hljs-comment">//含有属性String Country;String Province;</span><br>    String[] books;<br>    List&lt;String&gt; hobbies;<br>    Map&lt;String,String&gt; card;<br>    Properties info;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意一定要配有Setter方法和无参的构造方法，因为依赖注入是通过无参构造对象，Setter方法注入属性值</strong></p><h3 id="Set注入"><a href="#Set注入" class="headerlink" title="Set注入"></a>Set注入</h3><p>这样对应不同的类型有不同的注入方式，<strong>Set注入</strong>参照以下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;China&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;province&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JiangXi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        普通注入，属性类型为基本类型--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;TZQ&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--        Bean注入，属性类型为Java类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--        数组注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>红楼梦<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>金瓶梅<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        List注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>看电影<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        Map注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234567890&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;招商银行卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0987654321&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--        properties注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>201909<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>123@qq.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>如果实体类的属性没有配置Setter方法，配置属性是依靠有参构造方法实现的，Set注入将无法使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;China&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JiangXi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="c命名-p命名空间注入"><a href="#c命名-p命名空间注入" class="headerlink" title="c命名/p命名空间注入"></a>c命名/p命名空间注入</h3><ul><li><strong>c命名空间</strong></li></ul><p>先在beans标签头部导入xml约束。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:c=&quot;http://www.springframework.org/schema/c&quot;<br></code></pre></td></tr></table></figure><p>c命名空间适用于简单的属性注入：如基本类型，<strong>要求JavaBean中有无参构造方法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Address&quot;</span> <span class="hljs-attr">c:country</span>=<span class="hljs-string">&quot;China&quot;</span> <span class="hljs-attr">c:province</span>=<span class="hljs-string">&quot;SiChuan&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>p命名空间</strong></li></ul><p>先在beans标签头部导入xml约束。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">xmlns:</span>p=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span><br></code></pre></td></tr></table></figure><p>p命名空间适用于简单的属性注入，<strong>但必须要求JavaBean中有无参，有参构造方法！！</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Address&quot;</span> <span class="hljs-attr">p:country</span>=<span class="hljs-string">&quot;China&quot;</span> <span class="hljs-attr">p:province</span>=<span class="hljs-string">&quot;SiChuan&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><h3 id="单例模式-默认模式"><a href="#单例模式-默认模式" class="headerlink" title="单例模式(默认模式)"></a>单例模式(默认模式)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Address&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;China&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;province&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JiangXi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样重复通过<code>getBean()</code>获取的对象都是同一个对象。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Address&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;China&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;province&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JiangXi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样每次通过<code>getBean()</code>获取的对象都是不同对象，可能出现浪费资源的现象！！</p><h2 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a>Bean自动装配</h2><p>Spring会根据上下文，自动为Bean装配属性值。</p><p>以之前装配<code>Student</code>的<code>address</code>为例，原先是通过<code>&lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;</code>注入，因为上下文是有已经装配好的<code>address</code>对象的，我们就可以让Spring自动去寻找并自动装配。</p><ul><li><strong>byName</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>    ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>自动装配的原理是利用了Student类中的Setter方法，对于address属性有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.address = address;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么Spring就会在Bean配置文件中寻找有没有id=”address“的对象，有则自动注入。<strong>但是如果id取名为了addressTan或其他，这种自动装配就不起作用了！</strong></p></blockquote><ul><li><strong>byType</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.pojo.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>    ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这种会在上下文查找Address类的对象，<strong>但是如果有多个同类对象，这种方法就不生效</strong></p></blockquote><p>通过自动装配后，就不需要写<code>&lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;</code>了。</p><h2 id="注解实现自动装配"><a href="#注解实现自动装配" class="headerlink" title="注解实现自动装配"></a>注解实现自动装配</h2><ul><li>导入xml约束</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<span class="hljs-comment">&lt;!--导入beans头标签内--&gt;</span><br><br>http://www.springframework.org/schema/context<br>https://www.springframework.org/schema/context/spring-context.xsd <span class="hljs-comment">&lt;!--这两个加入到xsi:schemaLocation的值中--&gt;</span><br></code></pre></td></tr></table></figure><ul><li>配置注解的支持</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure><ul><li>@Autowired</li></ul><p><strong>@Autowired</strong>注解要添加在需要装配的实体类属性上,或该属性的Setter方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>Address address;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.address = address;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意@Autowired默认通过byType装配，如果有多个同类型的Bean存在，就无法装配。这时再添加注解**@Qualifier(value=”xxx”)**去帮忙指定配置掉一个<code>id=&quot;xxx&quot;</code>的Bean,相当于byName的Autowired。</p><ul><li>@Resource</li></ul><p>@Resource注解无需配置Spring即可使用，它会先通过byType查询，如果找到多个同类型的Bean就会从中找出id=“属性名”的，如果也没找到就会报错。有点像byName与byType的聚合。</p><h1 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a><a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=14">Spring注解开发</a></h1><ol><li>使用注解需要在<code>applicationContext.xml</code>导入context的xml约束，同上。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">                           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>指定需要扫描的包，该包下的注解才能生效</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.theo.pojo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><p>在<code>pojo</code>下新建实体类<code>User.class</code>，设置属性<code>public String name = &quot;TZQ&quot;;</code>。在类上添加注解<code>@Component</code>，之后类旁就会出现Spring Bean装配成功的绿叶图标。</p><p><strong>注意自动装配给该Bean分配的<code>id=“user”</code>，在测试类通过<code>context.getBean()</code>填入类名的小写<code>user</code>!!!!</strong></p><h2 id="注入Bean"><a href="#注入Bean" class="headerlink" title="注入Bean"></a>注入Bean</h2><p>通过xml注入是通过<code>&lt;property&gt;</code>来注入的，注解只需要<code>@Value()</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;TZQ&quot;)</span><span class="hljs-comment">//相当于&lt;property name=&quot;name&quot; value=&quot;TZQ&quot;/&gt;</span><br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>但你会发现，这种会把代码写死。如果需要更改值就需要更改代码，而不是更改配置文件了。<strong>除非非常简单的注入或者不涉及更改值的注解(@Autowired)，否则不建议使用。</strong></p><h2 id="衍生注解"><a href="#衍生注解" class="headerlink" title="衍生注解"></a>衍生注解</h2><p>@Component有多个衍生注解，对于Web应用的MVC三层都有其独特的注解，但功能一样！！</p><ul><li>dao层：【@Repository】</li><li>service层：【@Service】</li><li>controller层：【@Controller】</li></ul><blockquote><p>这三个注解都实现了将被注解的类装配到IoC容器，前提是在<code>applicationContext.xml</code>中加上扫描包路径！！</p></blockquote><h2 id="JavaConfig代替配置文件"><a href="#JavaConfig代替配置文件" class="headerlink" title="JavaConfig代替配置文件"></a>JavaConfig代替配置文件</h2><blockquote><p>使用JavaConfig可以完全删除<code>applicationContext.xml</code>，装配Bean的任务全权由JavaConfig负责</p></blockquote><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>新建<code>com.theo.javaconfig.JavaConfig.class</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><span class="hljs-comment">//相当于&lt;bean id=&quot;GetUser&quot; class=&quot;com.theo.pojo.User&quot;&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">GetUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Configuration</code>表明该<strong>配置类</strong>会被Spring托管（也会将该类作为Bean装配到IoC容器中）。</p><p><code>@Bean</code>说明会把下面的方法装配成Bean放到IoC容器中！！<strong>方法名就是id，返回值类型就是class</strong>。获取该Bean有些许不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">JavaConfigTest</span><span class="hljs-params">()</span> </span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);<br>    User GetUser = (User) context.getBean(<span class="hljs-string">&quot;GetUser&quot;</span>);<br>    System.out.println(GetUser.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说，<code>@Bean</code>装配了一个方法，但你从容器取出来的是一个Bean(返回类的对象)，可以换一种角度来看，<strong>User没有装配到IoC容器中，而是GetUser自己实例化了User类再放到IoC容器中。这样想的话，User类就不用使用注解<code>@Component</code>了。</strong></p><p>但是JavaConfig也能发现一些缺点：</p><ul><li>User没有装配到IoC容器，这样就意味着Spring不会去管理User了</li><li><strong>JavaConfig只负责装配，但并不负责注入属性！！当需要注入时还是需要到User属性上使用<code>@Value()</code>的。</strong>你也可以设置有参构造方法，new的时候添上属性值，但这个方法不推荐。</li></ul><blockquote><p><strong>如果你觉得GetUser作为id不适应，你也可以通过<code>@Bean(&quot;user&quot;)</code>来改变id。</strong></p></blockquote><h3 id="ComponentScan-“com-theo-pojo”-Component"><a href="#ComponentScan-“com-theo-pojo”-Component" class="headerlink" title="@ComponentScan(“com.theo.pojo”)+@Component"></a>@ComponentScan(“com.theo.pojo”)+@Component</h3><p><strong>那如果不使用@Bean，想像按照xml方式一样将User装配到IoC容器中呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.theo.pojo&quot;)</span><span class="hljs-comment">//相当于在applicationContext.xml中添加扫描包路径了</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;<br><span class="hljs-comment">//    @Bean</span><br><span class="hljs-comment">//    public User GetUser() &#123;</span><br><span class="hljs-comment">//        return new User(&quot;nihao&quot;);</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们再重新在User上添加注释<code>@Component</code>，User就被装配到IoC容器中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">JavaConfigTest</span><span class="hljs-params">()</span> </span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);<br>    User user = (User) context.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>    System.out.println(user.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>照样能打印出内容。</p><blockquote><p>综上，使用JavaConfig装配Bean有以下两种方式：</p><ul><li>只使用@Bean，通过getBean()来实例化User</li><li>使用@ComponentScan(“com.theo.pojo”)+@Component，这样就直接将User装配到IoC</li></ul><p>以上两种方式的效果都一样，也可以一起用，只是User会被实例化两次，但留在IoC的只是同一个对象，因为默认使用单例模式，故而getBean(“user”)和getBean(“GetUser”)获取的对象都是同一个，打印的hashcode()都一样。</p></blockquote><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><a href="https://www.bilibili.com/video/BV1HZ4y1p7F1?p=13">动态代理</a></h2><p>实现动态代理的步骤</p><ul><li>创建接口，定义目标类要完成的功能</li><li>创建目标类以实现接口</li><li>创建InvocationHandler接口的实现类，在invoke方法中完成代理类要做的功能：1.调用目标方法 2.添加功能</li><li>使用Proxy类的静态方法，创建代理对象，并把返回值强转为<strong>接口类型</strong>。</li></ul><h2 id="场景呈现"><a href="#场景呈现" class="headerlink" title="场景呈现"></a>场景呈现</h2><p><img src="https://img.imgdb.cn/item/605e92718322e6675cfcc268.jpg" alt="租客租房"></p><p>Client租房的时候如果不能直接与Host联系，就需要找到中介。首先，中介必须要提供Host提供的服务如：出租，允许租客看房等等。那么Host就要先通过一个接口来具体实现这些服务，中介就利用<strong>反射机制</strong>来调用这些服务（method.invoke），但中介也可以自己收取些小费，最后一同将服务提供给租客。</p><p>因而这一整套租房流程只按照实线流程进行，中途Host从没有参与。之后Host如要增添服务，只需要在功能接口增添并在目标类具体实现即可，那么代理就会自动拥有这些服务。</p><h2 id="代码实现流程"><a href="#代码实现流程" class="headerlink" title="代码实现流程"></a>代码实现流程</h2><p>源码下载: <a href="/download/Spring-proxy.rar">Spring-proxy.rar</a></p><ul><li><strong>定义功能接口</strong></li></ul><p>首先Host只允许租房和看房的服务，在<code>com.theo.Service</code>下创建<code>Rent</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> date)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>目标类实现接口</strong></li></ul><p>实例化一个Host，因为不同房主的租房规则不一样，我们就需要具体实现这些接口，在<code>com.theo.Factory</code>创建<code>Host</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Host</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了目标类Host：房东要租房&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> date)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了目标类Host:房东允许你在&quot;</span>+date+<span class="hljs-string">&quot;看房&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>定义代理要提供的服务</strong></li></ul><p>InvocationHandler接口的实现类就是中介要实现的服务，附加收费和提供目标类服务都在invoke中实现。在<code>com.theo.Handler</code>下创建<code>RentHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RentHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object target = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RentHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = method.invoke(target, args);<span class="hljs-comment">//执行目标类服务</span><br><br>        System.out.println(<span class="hljs-string">&quot;中介收取费用$20&quot;</span>);<span class="hljs-comment">//代理的额外服务</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为执行目标服务是通过反射机制实现的，这样我们就需要获取目标类的Class，再利用Class的method域来调用目标类的具体服务。</p><p>通过反射的知识，我们知道<code>invoke(target,args)</code>是要传入具体对象(Host)的，考虑到具体情况会有多个Host，我们就不在这一层指定好Host，而是通过有参构造方法让真正的的代理传入需要代理的具体对象(Host1/Host2…)，这样应用面更广。</p><ul><li><strong>创建代理对象</strong></li></ul><p>之前的<code>RentHandler</code>并不是真正的代理，只是定义了一个代理需要做的事，你可以看作是中介公司，在这里的中介都要遵从公司定义的规则：1.提供Host的服务 2.收取中介费用$20</p><p>接下来我们创建一个实实在在的中介，在<code>com.theo.Proxy</code>下创建<code>agency</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">agency</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Rent factory = <span class="hljs-keyword">new</span> Host();<br>        InvocationHandler handler = <span class="hljs-keyword">new</span> RentHandler(factory);<br>        Rent proxyInstance = (Rent) Proxy.newProxyInstance(factory.getClass().getClassLoader(), factory.getClass().getInterfaces(), handler);<br>        <br>        proxyInstance.rent();<br>        proxyInstance.check(<span class="hljs-number">20210815</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先明确我们要代理的对象是Host，将其创建出来：<code>Rent factory = new Host();</code>。其后传入代理对象到中介公司，让中介公司知道Host提供的服务有哪些：<code>InvocationHandler handler = new RentHandler(factory);</code>。之后通过这个中介公司创建出一个中介：<code>Rent proxyInstance = (Rent) Proxy.newProxyInstance(factory.getClass().getClassLoader(), factory.getClass().getInterfaces(), handler);</code>，注意这里的三个参数都是固定的，如果要换一个目标类，只需要改成<code>new Host1()</code>。最后代理就能直接调用服务了。</p><blockquote><p>代理调用服务：<strong>proxyInstance你就可以直接想成是Host的对象，就可以直接调用Host实现的接口。</strong></p><p>代码底层实现的原理：实际上proxyInstance.check(20210815)会去调用RentHandler的invoke方法：<code>check</code>就是参数method；<code>20210815</code>就是参数args，再利用反射机制，<code>method.invoke(target, args)</code>就是<code>new Host().check(20210815)</code>。</p><p>目标服务执行完后就是中介方自己添加的服务了。</p></blockquote><ul><li><strong>执行agency</strong></li></ul><p>运行agency.class得到结果:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">执行了目标类Host：房东要租房<br>中介收取费用$20<br>执行了目标类Host:房东允许你在<span class="hljs-number">20210815</span>看房<br>中介收取费用$20<br></code></pre></td></tr></table></figure><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>源码下载：<a href="/download/Spring-AOP.rar">Spring-AOP.rar</a></p><h2 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h2><p><img src="https://img.imgdb.cn/item/605ea6018322e6675c06a313.jpg" alt="AOP"></p><p>通常情况下我们都是纵向开发，就像之前的租客与房主的例子，写完房主的相关逻辑代码后，租客就可以直接调用了，如果房主的某一服务需要做细微的调改，比如租房的金额增加，那么房主的相关代码就要做更改。这相当于更改了底层代码。如果中间加了个中介，加钱的事由中介负责，那么房主的代码就无需更改。</p><p><strong>这就是面向切面编程的雏形：不更改业务逻辑的情况下，细微调整服务逻辑。</strong></p><p>不知道有没有注意到动态代理的一个问题：通过代理调用目标类哪种方法，代理额外做的工作都相同，即收取$20费用。如果代理租房业务收取30，而代理看房业务只收20呢？这就是AOP要解决的问题了。</p><h2 id="自定义类实现AOP"><a href="#自定义类实现AOP" class="headerlink" title="自定义类实现AOP"></a>自定义类实现AOP</h2><p>现在<code>pom.xml</code>中导入依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为实现以上的不同收费方式，在<code>com.theo.Advice</code>下新建<code>fares</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">fares</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Advice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent_fare</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;中介收取租房费用$30&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check_fare</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;中介收取查房费用$10&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以查房服务为例，当调用目标类的方法check()时，我们需要切入一个方法check_fare()。因此，在check()中制造切点(applicationContext.xml中配置)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;host&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.Factory.Host&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fares&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.Advise.fares&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;check_pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.theo.Factory.Host.check(int))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rent_pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.theo.Factory.Host.rent(..))&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;fares&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;check_fare&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;check_pointcut&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;rent_fare&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;rent_pointcut&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先导入xml约束<code>xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</code>以及<code>xsi:schemaLocation</code></p><h3 id="切点"><a href="#切点" class="headerlink" title="切点"></a>切点</h3><p><code>&lt;aop:pointcut id=&quot;check_pointcut&quot; expression=&quot;execution(* com.theo.Factory.Host.check(int))&quot;/&gt;</code></p><blockquote><p>这就是一个切点，表明将会在这个点插入方法，说白了切点就是一个方法。</p><p><code>id=&quot;check_pointcut&quot;</code>指明切入点的名称，<code>expression=&quot;execution()&quot;</code>指示切入点的具体位置</p></blockquote><h4 id="execution表达式"><a href="#execution表达式" class="headerlink" title="execution表达式"></a><a href="https://www.cnblogs.com/gdwkong/p/8660027.html">execution表达式</a></h4><blockquote><p>execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)</p><p>除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。</p></blockquote><p>在上面的例子中，第一个<code>*</code>表示匹配所有返回类型，第二部分<code>com.theo.Factory.Host.check</code>表明切点在这个方法中，以后执行该方法时就会附加上切面方法。第三部分<code>check(int)</code>精准匹配到参数为int类型的方法，这可以用来区分重载方法；如果想囊括所有重载方法，int就可以用<code>..</code>替代。</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符  *****"></a>通配符  *****</h4><p>如果我想在目标类中所有方法中加入相同切点，就需要使用<code>com.theo.Factory.Host.*(..)</code>。同样的，使用<code>com.theo.Factory.*.*(..)</code>就是在所有目标类的所有方法中加入同一切点。</p><blockquote><p><code>com.theo.Factory.*.*</code>和<code>com.theo.Factory..*</code>同一作用，表示包、子孙包下的所有类</p></blockquote><h3 id="切面与通知"><a href="#切面与通知" class="headerlink" title="切面与通知"></a>切面与通知</h3><p>如上，<code>com.theo.Advise.fares</code>就是一个<strong>切面</strong>，面上有多个方法<code>rent_fare()</code>、<code>check_fare()</code>，每一方法称为<strong>通知</strong></p><h4 id="标记切面"><a href="#标记切面" class="headerlink" title="标记切面"></a>标记切面</h4><p>先将切面实例化并交予IoC容器，再标记为切面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fares&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.Advise.fares&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;fares&quot;</span>&gt;</span><br>    //通知 Advice<br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="在切点上接入通知"><a href="#在切点上接入通知" class="headerlink" title="在切点上接入通知"></a>在切点上接入通知</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;check_fare&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;check_pointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;rent_fare&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;rent_pointcut&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之前创建了<code>check_pointcut</code>和<code>rent_pointcut</code>两个切点，分别接入<code>check_fare</code>和<code>rent_fare</code>两个通知，这样执行<code>Host.check(int date)</code>会附加执行<code>fares.check_pointcut()</code>，<code>Host.rent()</code>同理。</p><blockquote><p>&lt;aop:before  是指在执行完目标类方法前再执行通知。&lt;aop:after   是指在执行完目标类方法后再执行通知</p></blockquote><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>编写测试类，以<code>getBean(&quot;host&quot;)</code>获取Host对象，执行<code>host.check(20210815)</code>执行结果：</p><blockquote><p>中介收取查房费用$10<br>执行了目标类Host:房东允许你在20210815看房</p></blockquote><h2 id="Spring-API实现AOP"><a href="#Spring-API实现AOP" class="headerlink" title="Spring API实现AOP"></a><a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=20">Spring API实现AOP</a></h2><p>Spring API常见切面有<strong>日志</strong>和验证。创建<code>com.theo.Advice.log</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method    反射的目标类方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objects   参数,也就是args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 目标对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前日志:执行了方法&quot;</span>+method.getName()+<span class="hljs-string">&quot;;目标类:&quot;</span>+o.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里选择<strong>前日志</strong>，它会在目标类方法执行前打印日志。我们打算对所有方法都加入日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.Advice.log&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;all_pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.theo.Factory.Host.*(..))&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;all_pointcut&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="注解实现AOP"><a href="#注解实现AOP" class="headerlink" title="注解实现AOP"></a>注解实现AOP</h2><p>注解实现是基于自定义类实现改进的。也需要经历<strong>标记切面、创建切点、接入通知</strong>。</p><p>创建<code>com.theo.Advice.Annotation</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotation</span> </span>&#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.theo.Factory.Host.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before_annotation</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===目标类方法执行开始====&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;execution(* com.theo.Factory.Host.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after_annotation</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;===目标类方法执行完成===&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Aspect</code>表明该类为一切面，等价于：<code>&lt;aop:aspect ref=&quot;fares&quot;&gt;</code></p><p><code>@Before(&quot;execution(* com.theo.Factory.Host.*(..))&quot;)</code>创建切点，同时声明执行先后。等价于：<code>&lt;aop:before method=&quot;check_fare&quot; pointcut-ref=&quot;check_pointcut&quot;/&gt;</code></p><p>最后需要在applicationContext.xml开启注解支持和Bean装配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.Advice.Annotation&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>至此，注解实现完成。</p><h1 id="Mybatis-Spring"><a href="#Mybatis-Spring" class="headerlink" title="Mybatis-Spring"></a>Mybatis-Spring</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h1&gt;&lt;h2 id=&quot;IOC本质&quot;&gt;&lt;a href=&quot;#IOC本质&quot; class=&quot;headerlink&quot; title=&quot;IOC本质&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="SSM框架" scheme="http://example.com/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://example.com/2021/03/16/MyBatis/"/>
    <id>http://example.com/2021/03/16/MyBatis/</id>
    <published>2021-03-16T14:08:09.000Z</published>
    <updated>2021-03-28T02:33:35.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis实现简单JavaWeb"><a href="#MyBatis实现简单JavaWeb" class="headerlink" title="MyBatis实现简单JavaWeb"></a><a href="https://www.bilibili.com/video/BV1NE411Q7Nx?p=2">MyBatis实现简单JavaWeb</a></h1><p>MyBatis能很好地简化MVC中的模型层与控制层，下面我将会用MyBatis的新概念与Servlet+JDBC的概念做比对。一步步构建一个最简单的JavaWeb应用。</p><h2 id="Maven创建项目"><a href="#Maven创建项目" class="headerlink" title="Maven创建项目"></a>Maven创建项目</h2><p>IDEA建立新项目时使用Maven创建，普通的Maven项目即可。创建成功后在主目录<code>add framework support</code>中添加<code>Web Aplication</code>，然后在pom.xml中添加依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>IDEA会自动通过依赖来导入jar包，如果没有反应就在右侧栏的Maven选项中更新Maven。</p><p><strong>同时添加以下：（用来告诉Mybatis去哪寻找配置文件，后面会解释）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="创建子项目"><a href="#创建子项目" class="headerlink" title="创建子项目"></a>创建子项目</h2><p>在主目录下新建<code>Moudle</code>，同样选择Maven创建。生成mybatis-theo项目，结构目录和父项目一致。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">E:\IntelliJ IDEA 2020.2\mabatis<br>├─mabatis.iml<br>├─pom.xml<br>├─src<br>├─.idea<br>├─mybatis-theo<br>|<span class="hljs-string">      ├─pom.xml</span><br>|<span class="hljs-string">      ├─src</span><br>|<span class="hljs-string">      </span>|<span class="hljs-string">  ├─test</span><br>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  ├─java</span><br>|<span class="hljs-string">      </span>|<span class="hljs-string">  ├─main</span><br>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  ├─resources</span><br>|<span class="hljs-string">      </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  ├─java</span><br></code></pre></td></tr></table></figure><ul><li><strong>pom.xml</strong></li></ul><p>继承了父项目的pom.xml的全部内容，子项目的pom.xml只会用来配置一些与该项目有关的特殊配置。</p><ul><li><strong>src.main.resources</strong></li></ul><p>存放<code>mybatis-config.xml</code>，官方规定的名字，按标准来。其中的内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tzq******&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显然这和我们的Druid连接池很像，该配置文件用来连接数据库的。</p><p><strong>IDEA连接数据库MySQL</strong></p><p>右侧栏的DataBase按钮里点击添加，选择MySQL。之后在Advanced里找到<code>serverTimezone</code>，设值为<code>GMT</code>。然后再<code>Gernal</code>中填入数据库的账号密码，点击<code>Test Connection</code>，连接成功后就能在IDEA上操作数据库了。再次点击DataBase就可以看到库中的表了。</p><p><strong>配置映射路径</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/theo/dao/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是用来告诉sqlSession去哪个配置文件寻找映射的，后面会解释。</p><ul><li><strong>src.main.java</strong></li></ul><p>这里用来存放整个工程的代码，一般情况下会有以下几个包：<code>Dao</code>、<code>entity</code>、<code>utils</code>。每个包实现的功能和Servlet+JDBC这种方式十分相似。</p><ul><li><strong>src.test.java</strong></li></ul><p>用来存放测试文件，测试成功后再放到main文件中。这是一种良好习惯。</p><h2 id="实现Moudle层"><a href="#实现Moudle层" class="headerlink" title="实现Moudle层"></a>实现Moudle层</h2><h3 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h3><p>定义实体类，属性值一定要和数据库中的属性值相同！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>再插入Setter，Getter，toString，Structure方法，使之形成一个JavaBean类。</p><blockquote><p><strong>一定要注意生成Structure方法时要有无参的构造方法</strong>：之后通过reslutType返回实例时是先通过无参构造方法生成实例，再通过Getter&amp;Setter填充属性的！！！！</p></blockquote><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><p>创建<code>com.theo.utils</code>包，按照以往知识可知这里实现的是连接数据库相关的功能，比如之前的：创建连接池、获取链接、关闭连接、提交回滚事务等，而现在是创建sqlSession及相关功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>            InputStream inputStream = Resources.getResourceAsStream(resource);<br>             sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和创建Druid连接池一样，使用IO流更为方便，只不过这里的<code>mybatis-config.xml</code>代替了之前的<code>database.properties</code>。SqlSession与JDBC的连接完全不一样，获取的SqlSession将直接接触Dao层的接口类，总之，utils层初步完成。</p><blockquote><p>**sqlSession.openSession(true)**设置事务自动提交，之后DML操作就不需要再<code>sqlSession.commit()</code>了</p></blockquote><h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h3><p>创建<code>com.theo.dao</code>包，同样的这里实现的是对数据库信息的CRUD（增删查改）功能。以获取全部信息为例，对应SELECT语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同于以往做法（创建<code>com.theo.dao.impl</code>包，其中创建<code>UserDaoimpl</code>类来具体实现接口：创建小车，填充SQL语句，返回结果），这回在<code>com.theo.dao</code>包下创建<code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.theo.dao.UserDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.theo.entity.User&quot;</span>&gt;</span><br>        SELECT * FROM admin ;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>用配置文件实现接口方法</strong></li></ul><p><code>namespace=&quot;com.theo.dao.UserDao&quot;</code>说明这组映射都是实现接口<code>UserDao</code>的，如果接口的方法涉及SELECT语句，就像选用select标签，<code>id=&quot;getUserList&quot;</code>指明该映射实现的方法名，<code>resultType=&quot;com.theo.entity.User&quot;</code>表明方法的返回类型，虽然明着是<code>List&lt;User&gt;</code>，但本质还是一个个<code>User</code>。标签里填写的就是SQL语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Admin&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;Admin&gt; admins = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Dbutils.begin();<br>            admins = queryRunner.query(Dbutils.getConnection(), <span class="hljs-string">&quot;SELECT * FROM admin;&quot;</span>, <span class="hljs-keyword">new</span> BeanListHandler&lt;Admin&gt;(Admin.class));<br>            Dbutils.submit();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>            Dbutils.rollback();<br>        &#125;<br>        <span class="hljs-keyword">return</span> admins;<br>&#125;<br></code></pre></td></tr></table></figure><p>与传统方法对比，该方法省去了除填充SQL语句外的一切代码，如获取链接，提交/回滚等等。<strong>最重要的是：实现了SQL与java代码的完全分离，如果要更改SQL，只需要更改配置文件。只有在添加删减接口方法时才会去碰java代码。</strong></p><ul><li><strong>与<code>mybatis-config.xml</code>的联系</strong></li></ul><p>之前提到过需要在<code>mybatis-config.xml</code>添加<code>&lt;mappers&gt;&lt;mapper resource=&quot;com/theo/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;</code>，因为创建的SqlSession只配备了<code>mybatis-config.xml</code>的信息，同时SqlSession需要与Dao对接，即调用接口中的方法<code>getUserList</code>， 就需要通过这个路径找到接口配置文件，也就相当于找到接口实现方法，进而Utils和Dao联系了起来。（以往是通过在Dao调用<code>Utils.function()</code>来联系起来的）。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在<code>src.test.java</code>下创建<code>com.theo.dao.UserDaoTest.java</code>,这也是一个行为习惯，测试哪个Dao接口就对称的建立DaoTest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        SqlSession sqlSession = MyBatisUtils.getSqlSession();<br><br>        UserDao userDao = sqlSession.getMapper(UserDao.class);<br>        List&lt;User&gt; userList = userDao.getUserList();<br><br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UserDao userDao = sqlSession.getMapper(UserDao.class);</code>可以看出SqlSession的强大之处，直接返回一个接口实现类。</p><blockquote><p><code>SqlSession.getMapper(Class)</code>会先访问<code>mybatis-config.xml</code>中的<code>&lt;mappers&gt;</code>，找到Dao层的<code>DaoMapper.xml</code>就相当于具有了里面所有的映射方法，但<code>DaoMapper.xml</code>中可能会有多个<code>&lt;mapper&gt;</code>，那么设置<code>UserDao.class</code>就能对应<code>&lt;mapper namespace=&quot;com.theo.UserDao&quot;&gt;</code>。这样的多重对应后<strong>返回一个接口实现类的实例</strong><code>userDao</code>，就可以直接调用所有接口方法了。</p></blockquote><p>至此，一个基于MyBatis的查询功能完成。<a href="/download/mybatis.rar">工程源码下载</a></p><h1 id="MyBatis配置优化"><a href="#MyBatis配置优化" class="headerlink" title="MyBatis配置优化"></a>MyBatis配置优化</h1><h2 id="核心配置文件-mybatis-config-xml"><a href="#核心配置文件-mybatis-config-xml" class="headerlink" title="核心配置文件(mybatis-config.xml)"></a>核心配置文件(mybatis-config.xml)</h2><h3 id="环境配置-lt-environments"><a href="#环境配置-lt-environments" class="headerlink" title="环境配置(&lt;environments)"></a>环境配置(&lt;environments)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--默认的事务管理器是JDBC--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--默认以连接池形式处理事务--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tzq1635886602&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis可以同时配置多个环境，但SqlSessionFactory只能选择一种环境，即默认环境<code>development</code>。这样我们可以先将不同数据库的环境配置好，然后需要切换数据库时直接更改<code>default</code>值就行。</p><h3 id="外部配置文件-properties"><a href="#外部配置文件-properties" class="headerlink" title="外部配置文件(.properties)"></a>外部配置文件(.properties)</h3><p><code>com.theo.resource</code>下新建<code>database.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">tzq1635886602</span><br></code></pre></td></tr></table></figure><p>在环境配置中加入引用，环境配置中就可以用引用方式代替.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;database.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="内部配置-lt-properties"><a href="#内部配置-lt-properties" class="headerlink" title="内部配置(&lt;properties)"></a>内部配置(&lt;properties)</h3><p>除了获取外部配置,在可以在内部补充:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;database.properties&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tzq1635886602&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样在环境配置中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>环境配置先加载外部配置文件，然后再加载内部配置，如果重复则会覆盖原先的键值对</strong></p><h3 id="别名-lt-typeAliases"><a href="#别名-lt-typeAliases" class="headerlink" title="别名(&lt;typeAliases)"></a>别名(&lt;typeAliases)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.theo.entity&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对<strong>实体类包</strong>注解，之后MyBatis会在包名下面搜索需要的JavaBean(<code>User.class</code>)，然后在<code>Mapper.xml</code>实现接口类方法时,返回类型由<code>resultType=&quot;com.theo.entity.User&quot;</code>改为<code>resultType=&quot;User&quot;</code>，也就是从绝对路径改写成相对路径。</p><h3 id="注解别名-Alias"><a href="#注解别名-Alias" class="headerlink" title="注解别名(@Alias)"></a>注解别名(@Alias)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;Admin&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>将<strong>实体类</strong>改名，这样<code>resultType=&quot;User&quot;</code>也可以换做<code>resultType=&quot;Admin&quot;</code>。但没什么用，不建议。</p><h3 id="映射器-lt-mappers"><a href="#映射器-lt-mappers" class="headerlink" title="映射器(&lt;mappers)"></a>映射器(&lt;mappers)</h3><p>MapperRegister:注册绑定我们的Mapper文件，之前提到过SqlSession要找到映射的接口类，进而生成其实现类实例。</p><h4 id="使用resource绑定Mapper配置文件"><a href="#使用resource绑定Mapper配置文件" class="headerlink" title="使用resource绑定Mapper配置文件"></a>使用resource绑定Mapper配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/theo/dao/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用class绑定接口类"><a href="#使用class绑定接口类" class="headerlink" title="使用class绑定接口类"></a>使用class绑定接口类</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.theo.dao.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>接口类(UserMapper.class)必须和其Mapper配置文件(UserMapper.xml)同名</li><li>接口类与其Mapper配置文件必须在同一包下</li></ul><h4 id="使用package绑定包"><a href="#使用package绑定包" class="headerlink" title="使用package绑定包"></a>使用package绑定包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.theo.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>接口类(UserMapper.class)必须和其Mapper配置文件(UserMapper.xml)同名</li><li>接口类与其Mapper配置文件必须在同一包下</li></ul><blockquote><p>注意这里的同一个包并没有限制得那么死，并不是说UserMapper.class和UserMapper.xml都在<code>java.com.theo.dao</code>下，实际开发更多用的是把Mapper配置文件放在<code>resource.com.theo.dao</code>下，包的路径一样生成的target目录中class和xml就会在同一包下。</p><p><img src="https://img.imgdb.cn/item/6055921a524f85ce29ada6c1.jpg" alt="class和xml分开存储"></p></blockquote><h1 id="ResultMap结果集映射"><a href="#ResultMap结果集映射" class="headerlink" title="ResultMap结果集映射"></a>ResultMap结果集映射</h1><p>在创建实体类时我们强调过实体类的属性名必须和数据库的列名完全一致，因为MyBatis处理SQL语句时会自动用上<strong>类型处理器</strong>（可以理解为QueryRunner中的BeanHandler），比如语句<code>SELECT id,username,password FROM admin;</code>，类型处理器会去寻找实体类中的对应属性并一一填充进去，包装成一个实例。但如果实体类中属性名为<code>pwd</code>，从数据库返回的<code>password</code>无法装入，那么最后形成的实例中<code>password</code>的值为空。</p><p>为了解决实体类属性名设定的局限性，ResultMap结果集就出现了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span><br>    SELECT id,username,password FROM admin ;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>原先返回resultType，现在返回resultMap，resultMap对应了type。</p><p>ResulMap做的事情就是把数据库返回的列名矫正成实体类的属性值，这样包装成实体类实例时就能一一对应并填充上了。<strong>当然，如果列明和属性值一样，就不需要做映射了</strong></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>如果一个数据库操作出现了异常，控制台输出错误栈时该SQL将会重点突出。</p><ul><li><strong>STDOUT_LOGGING</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在核心配置文件中配置好日志后，运行查询所有数据的函数，控制台输出日志：</p><p><img src="https://ftp.bmp.ovh/imgs/2021/03/7e9c16704f00fce8.jpg" alt="标准日志输出"></p><ul><li><strong>LOG4J</strong></li></ul><p>向pom.xml导入Maven依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在resource下创建log4j.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># priority  :debug&lt;info&lt;warn&lt;error</span><br><span class="hljs-comment">#you cannot specify every priority with different file for log4j </span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">debug,stdout,info,debug,warn,error </span><br> <br><span class="hljs-comment">#console</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender </span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout </span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>= <span class="hljs-string">[%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n</span><br><span class="hljs-comment">#info log</span><br><span class="hljs-meta">log4j.logger.info</span>=<span class="hljs-string">info</span><br><span class="hljs-meta">log4j.appender.info</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender </span><br><span class="hljs-meta">log4j.appender.info.DatePattern</span>=<span class="hljs-string">&#x27;_&#x27;yyyy-MM-dd&#x27;.log&#x27;</span><br><span class="hljs-meta">log4j.appender.info.File</span>=<span class="hljs-string">./log/info.log</span><br><span class="hljs-meta">log4j.appender.info.Append</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">log4j.appender.info.Threshold</span>=<span class="hljs-string">INFO</span><br><span class="hljs-meta">log4j.appender.info.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout </span><br><span class="hljs-meta">log4j.appender.info.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="hljs-comment">#debug log</span><br><span class="hljs-meta">log4j.logger.debug</span>=<span class="hljs-string">debug</span><br><span class="hljs-meta">log4j.appender.debug</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender </span><br><span class="hljs-meta">log4j.appender.debug.DatePattern</span>=<span class="hljs-string">&#x27;_&#x27;yyyy-MM-dd&#x27;.log&#x27;</span><br><span class="hljs-meta">log4j.appender.debug.File</span>=<span class="hljs-string">./log/debug.log</span><br><span class="hljs-meta">log4j.appender.debug.Append</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">log4j.appender.debug.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.debug.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout </span><br><span class="hljs-meta">log4j.appender.debug.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="hljs-comment">#warn log</span><br><span class="hljs-meta">log4j.logger.warn</span>=<span class="hljs-string">warn</span><br><span class="hljs-meta">log4j.appender.warn</span>=<span class="hljs-string">org.apache.log4j.DailyRollingFileAppender </span><br><span class="hljs-meta">log4j.appender.warn.DatePattern</span>=<span class="hljs-string">&#x27;_&#x27;yyyy-MM-dd&#x27;.log&#x27;</span><br><span class="hljs-meta">log4j.appender.warn.File</span>=<span class="hljs-string">./log/warn.log</span><br><span class="hljs-meta">log4j.appender.warn.Append</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">log4j.appender.warn.Threshold</span>=<span class="hljs-string">WARN</span><br><span class="hljs-meta">log4j.appender.warn.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout </span><br><span class="hljs-meta">log4j.appender.warn.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="hljs-comment">#error</span><br><span class="hljs-meta">log4j.logger.error</span>=<span class="hljs-string">error</span><br><span class="hljs-meta">log4j.appender.error</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><br><span class="hljs-meta">log4j.appender.error.DatePattern</span>=<span class="hljs-string">&#x27;_&#x27;yyyy-MM-dd&#x27;.log&#x27;</span><br><span class="hljs-meta">log4j.appender.error.File</span> = <span class="hljs-string">./log/error.log </span><br><span class="hljs-meta">log4j.appender.error.Append</span> = <span class="hljs-string">true</span><br><span class="hljs-meta">log4j.appender.error.Threshold</span> = <span class="hljs-string">ERROR </span><br><span class="hljs-meta">log4j.appender.error.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.error.layout.ConversionPattern</span> = <span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br></code></pre></td></tr></table></figure><h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><p>对于没有特殊要求，注解开发可以简化接口方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select * from admin&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-meta">@Select(&quot;select * from admin where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就不需要在Mapper配置文件中添加&lt;select 映射了，但也要注意在核心配置文件中就不能映射到Mapper.xml,因为不是在那里实现接口方法的。<code>&lt;mapper resource=&quot;com/theo/dao/UserMapper.xml&quot;/&gt;</code>就需要改成<code>&lt;mapper class=&quot;com.theo.dao.UserMapper&quot;/&gt;</code>或是<code>&lt;package name=&quot;com.theo.dao&quot;/&gt;</code></p><blockquote><p><strong>注解开发只能用于SQL语句简单无比的的接口方法上，这种开发是无法解决如列名与属性名不一致的情况的！！！</strong></p></blockquote><h1 id="MyBatis执行流程剖析"><a href="#MyBatis执行流程剖析" class="headerlink" title="MyBatis执行流程剖析"></a>MyBatis执行流程剖析</h1><p>随便在一个测试中debug，断点定位到<code>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</code></p><p><img src="https://img.imgdb.cn/item/6055619d524f85ce2994e88a.jpg" alt="整体流程图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>InputStream inputStream = Resources.getResourceAsStream(resource);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> SqlSessionFactoryBuilder()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br></code></pre></td></tr></table></figure><p>而build(inputStram)又会调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XMLConfigBuilder parser = <span class="hljs-keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);<br></code></pre></td></tr></table></figure><p>这里解析了内部配置文件，环境等<br>将所有解析出来的东西封装成Configuration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br></code></pre></td></tr></table></figure><ul><li>创建事务管理器transaction，用来管理dataSource，autoCommit，connection，level等等</li></ul><p><img src="https://img.imgdb.cn/item/605565fe524f85ce2997463b.jpg" alt="事务管理内容"></p><ul><li><p>transaction与其他执行驱动包装成executor执行器</p></li><li><p>executor与Configuration包装成sqlSession</p></li></ul><p><img src="https://img.imgdb.cn/item/605566d6524f85ce2997a1b8.jpg" alt="SqlSession"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; userList = userMapper.getUserList();<br></code></pre></td></tr></table></figure><p><strong>执行完CURD后要记得手动回滚或提交</strong></p><h1 id="复杂查询环境"><a href="#复杂查询环境" class="headerlink" title="复杂查询环境"></a>复杂查询环境</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>构建两个表，一个student一个teacher。student表中tid作为外键连接teacher表中id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>    id   int(10)     not null,<br>    name varchar(20) not null,<br>    tid int(10) not null ,<br>    constraint student_py primary key (id),<br>    constraint student_fk foreign key (tid) references teacher(id)<br>)engine&#x3D;innodb default charset &#x3D; utf8;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table teacher(<br>    id   int(10)     not null,<br>    name varchar(20) not null,<br>    constraint teacher_py primary key (id)<br>)engine&#x3D;innodb default charset &#x3D; utf8;<br></code></pre></td></tr></table></figure><p><img src="https://img.imgdb.cn/item/6055a5f7524f85ce29b9e88f.jpg" alt="student与teacher之间的架构关系"></p><p>在student中插入数据(1,”tzq1”,1)、(2,”tzq2”,1)、(3,”tzq3”,1)，在teacher中插入数据(1,”theo”)。</p><h2 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a><a href="/download/mybatis-%E5%A4%9A%E5%AF%B9%E4%B8%80.rar">多对一处理</a></h2><p>如上，三个学生都对应了同一个老师。我们需要查询出所有学生的id，姓名以及所属老师。那么设计Student和Teacher实体类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    Teacher teacher;<br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>不难发现，简单的select语句依然会犯属性名与列名不对应的错误，<strong>甚至连类型都不一致，这就不是单靠resultMap改名就能解决的事。</strong></p><h3 id="association结果映射"><a href="#association结果映射" class="headerlink" title="association结果映射"></a>association结果映射</h3><p>如上所说，association作用就是把tid更名为teacher，同时将类型int更改为Teacher</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;tid2teacher&quot;</span>&gt;</span><br>    SELECT * FROM student;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tid2teacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    SELECT * FROM teacher WHERE id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用函数时，第一步<code>SELECT * FROM student</code>获取到<code>tid</code>，返回时准备通过<code>resultMap</code>映射。第二步知道将<code>tid</code>映射成<code>teacher</code>，因为类型不一致就要通过association更改：<code>javaType</code>为映射后的类型，为了达到这个结果，执行<code>select</code>。第三步将tid作为参数传入<code>getTeacher</code>，SQL返回结果经resultType封装成<code>Teacher</code>对象，该对象会填充到属性<code>teacher</code>中。</p><h3 id="association嵌套映射"><a href="#association嵌套映射" class="headerlink" title="association嵌套映射"></a>association嵌套映射</h3><p>上一种方式需要额外写一套<code>&lt;select&gt;</code>，而嵌套映射不需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Student2Teacher&quot;</span>&gt;</span><br>    SELECT student.id sid,student.name sname,teacher.name tname,teacher.id tid <br>    FROM student,teacher <br>    WHERE student.tid = teacher.id;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student2Teacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用函数时，第一步SQL语句拿出了student表中的id、name和teacher表中的id、name并分别取了别名，返回时准备通过<code>resultMap</code>映射。第二步将要用的<code>sid</code>，<code>sname</code>更名为<code>id</code>、<code>name</code>。在association中把<code>tid</code>，<code>tname</code>更名为<code>id</code>，<code>name</code>；通过javaType的指示封装成<code>Teacher</code>的对象，填入到<code>teacher</code>属性中。</p><p><strong>以上两种是思路完全不同的方法，比较推荐第二种，更易理解与记忆</strong></p><h2 id="一对多处理"><a href="#一对多处理" class="headerlink" title="一对多处理"></a>一对多处理</h2><p>一个老师也对应了多个学生，我们修改下实体类属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    <span class="hljs-keyword">int</span> tid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    List&lt;Student&gt; student;<br>&#125;<br></code></pre></td></tr></table></figure><p>相较于多对一处理，这回需要把与id关联的所有student元组聚合成列表，填充到student属性中。</p><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacherList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;Teacher2Student&quot;</span>&gt;</span><br>    SELECT student.id sid,student.name sname,student.tid stid,teacher.id tid,teacher.name tname<br>    FROM student,teacher<br>    WHERE student.tid = teacher.id;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Teacher2Student&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意的是：SQL查出的是两表的广义笛卡尔积，新表中同一老师id的元组，其<code>sid</code>、<code>sname</code>、<code>stid</code>重命名为<code>student</code>、<code>id</code>、<code>tid</code>再封装成<code>Student</code>对象，这样的多个对象形成集合填充到<code>student</code>属性中。</p><h1 id="动态SQL语句"><a href="#动态SQL语句" class="headerlink" title="动态SQL语句"></a>动态SQL语句</h1><h2 id="where-if-标签"><a href="#where-if-标签" class="headerlink" title="where+if 标签"></a>where+if 标签</h2><p>在UserMaper.class中新增一个方法：通过Map传入想要查询的条件，如果Map为空就查询出所有信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserMap</span><span class="hljs-params">(Map map)</span></span>;<br></code></pre></td></tr></table></figure><p>因为输入的数据不一定都是一样的，所以这个方法的SQL语句也是动态变化的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    SELECT id,username,password FROM admin<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span><br>            id = #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>            AND username = #&#123;username&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>        AND password = #&#123;password&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果输入的map为{id=1,username=tzq}，那么就会拼接出SQL语句：<code>SELECT id,username,password FROM admin WHERE id = 1 AND username = tzq;</code>。当然，如果map中id字段为空，并不会直接把<code>AND username = #&#123;username&#125;</code>直接拼接到WHERE后面，而是会自动删去AND以保证语法的合法性。</p><h2 id="where-choose-标签"><a href="#where-choose-标签" class="headerlink" title="where+choose 标签"></a>where+choose 标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    SELECT id,username,password FROM admin<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span><br>                id = #&#123;id&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>                AND username = #&#123;username&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>                AND password = #&#123;password&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>choose标签有点像java的switch语句，当有个条件成立时就将语句拼接到SQL后面，然后就自动退出choose标签了（相当于break）。也就是说即使输入map为{id=1,username=tzq}，满足了id，就不会再去插入<code>AND username = #&#123;username&#125;</code>。</p><p>还有一个标签<code>&lt;otherwise&gt;...&lt;/otherwise&gt;</code>,只有当when都没有匹配时就会匹配该标签,并拼接到SQL语句后面。这样如果在标签中填入恒为错误的语句，这样当用户输入的map为空时就无法查到任何信息了。</p><h2 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h2><p>在UserMaper.class中新增一个方法：通过Map传入想要更改的属性(用户名,密码)，但需要id作定位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">UpdateUserMap</span><span class="hljs-params">(Map map)</span></span>;<br></code></pre></td></tr></table></figure><p>因为输入的数据不一定都是一样的，所以这个方法的SQL语句也是动态变化的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UpdateUserMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    UPDATE admin<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>            username = #&#123;username&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            password = #&#123;password&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>这里最后一个if标签里可以添加<code>,</code>，因为set标签默认配置了trim标签，会将导致SQL语法错误的<code>,</code>自动删去。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis实现简单JavaWeb&quot;&gt;&lt;a href=&quot;#MyBatis实现简单JavaWeb&quot; class=&quot;headerlink&quot; title=&quot;MyBatis实现简单JavaWeb&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.co</summary>
      
    
    
    
    
    <category term="SSM框架" scheme="http://example.com/tags/SSM%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Druid-ThreadLocal-QueryRunner</title>
    <link href="http://example.com/2021/03/13/Druid-ThreadLocal-QueryRunner/"/>
    <id>http://example.com/2021/03/13/Druid-ThreadLocal-QueryRunner/</id>
    <published>2021-03-13T09:23:54.000Z</published>
    <updated>2021-03-14T07:32:36.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>一般情况下我们链接数据库是需要则创建，利用完则销毁，也要遵循JDBC的四步骤：注册驱动，建立通道，配置小车，销毁。</p><p>当然，这种一条一条地创建链接是十分耗费资源的，而且效率也不高。数据库连接池的概念应运而生。</p><p>我们预先设置好一部分链接，放在一个池中，并且将这些连接标记为空闲状态。如果要使用连接就从池中获取一个连接使用，用完之后再次放回到池中。</p><ul><li>连接池自己应该有自动初始化的功能，自动增长，自动缩减</li><li>自动增长：当池中的空闲连接使用完后，自动创建新的空闲连接到连接池中</li><li>自动缩减：当池中的空闲连接剩余过多时，自动关闭部分链接</li></ul><h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><p>数据库连接池有很多种：C3P0，DBCP，Druid。其中Druid是目前最为流行的连接池。</p><p>Druid连接池是阿里巴巴开源平台上一个数据库连接池实现，结合了C3P0，DBCP，PROXOOL等DB池的优点，同时加入了日志监控，能很好地监控DB池连接状况和SQL执行情况。下载Duird的jar包：<a href="/download/druid-1.1.5.jar">druid-1.1.5.jar</a></p><h3 id="配置文件-IO流创建连接池"><a href="#配置文件-IO流创建连接池" class="headerlink" title="配置文件+IO流创建连接池"></a>配置文件+IO流创建连接池</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">//database.properties</span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/companydb</span></span><br><span class="line"></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">*********</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span> = <span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span> = <span class="string">20</span></span><br><span class="line"><span class="attr">minIdle</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">maxWait</span> = <span class="string">3000</span></span><br></pre></td></tr></table></figure><ul><li>使用IO流来加载该配置文件,其中注意<code>Dbutils.class</code>是当前类名。这个流是写在类<code>Dbutils</code>中的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream inputStream = Dbutils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;/database.properties&quot;</span>);</span><br><span class="line">properties.load(inputStream);</span><br></pre></td></tr></table></figure><ul><li>将已经加载了IO流的<code>properties</code>导入连接池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource ds;</span><br><span class="line">ds = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);</span><br></pre></td></tr></table></figure><ul><li>至此，一个Druid连接池创建好了。其中需要特别注意的是，使用流创建连接池时<strong>配置文件中的key必须要和官方配置参数完全相同。</strong></li></ul><table><thead><tr><th>官方配置参数</th><th>缺省值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候 <br/>可以通过名字来区分开来。如果没有配置，将会生成一个名字， <br/>格式是：”DataSource-“ + System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如MySQL数据库： <br/>url=jdbc:mysql://localhost:3306/数据库名称?useUnicode=true&amp;characterEncoding=utf8<br/>&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中可以使用ConfigFilter</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。</td></tr></tbody></table><ul><li><p>处理完异常后，创建连接池的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource ds;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream inputStream = DbUtils.class.getResourceAsStream(<span class="string">&quot;/database.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            ds = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal-lt-gt-存储链接"><a href="#ThreadLocal-lt-gt-存储链接" class="headerlink" title="ThreadLocal&lt;&gt;存储链接"></a>ThreadLocal&lt;&gt;存储链接</h1></li></ul><h2 id="ThreadLocal用法"><a href="#ThreadLocal用法" class="headerlink" title="ThreadLocal用法"></a>ThreadLocal用法</h2><p>ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</p><p>1、<strong>ThreadLocal.get</strong>: 获取ThreadLocal中当前线程共享变量的值。</p><p>2、<strong>ThreadLocal.set</strong>: 设置ThreadLocal中当前线程共享变量的值。</p><p>3、<strong>ThreadLocal.remove</strong>: 移除ThreadLocal中当前线程共享变量的值。</p><p>4、<strong>ThreadLocal.initialValue</strong>: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。</p><h2 id="ThreadLocal存储Connection"><a href="#ThreadLocal存储Connection" class="headerlink" title="ThreadLocal存储Connection"></a>ThreadLocal存储Connection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><p>创建ThreadLocal&lt;&gt;时将其声明为<code>private static final</code>，可以有效防止ThreadLocal的弱引用问题。<strong>至此，每一个线程将会有一个属于自己的链接Connection，如果没有的话就去连接池中取一个然后绑定到当前线程中。线程使用完链接后就remove()解除绑定，同时连接池中close()关闭该链接。</strong></p><h2 id="以getConnection-为例"><a href="#以getConnection-为例" class="headerlink" title="以getConnection()为例"></a>以getConnection()为例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Connection connection = THREAD_LOCAL.get();<span class="comment">//试图获取与当前线程绑定的Connection</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="keyword">null</span>)&#123;<span class="comment">//说明当前线程还没有绑定Connection,去连接池获取</span></span><br><span class="line">            connection = ds.getConnection();<span class="comment">//连接池创建了一个Connection</span></span><br><span class="line">            THREAD_LOCAL.set(connection);<span class="comment">//将该Connection与当前线程绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">        throwables.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;<span class="comment">//当前线程绑定好了一个Connection,开始准备制作小车PreparedStatement。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = Dbutils.getConnection();</span><br></pre></td></tr></table></figure><h1 id="相比于传统方法获取Connection"><a href="#相比于传统方法获取Connection" class="headerlink" title="相比于传统方法获取Connection"></a>相比于传统方法获取Connection</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection connection = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PreparedStatement preparedStatement =<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="string">&quot;database&quot;</span>);</span><br><span class="line">String driver = resourceBundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String url = resourceBundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String username = resourceBundle.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password = resourceBundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(driver);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立通道</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的看出，连接池技术很好的代替了以上一整块代码，免去了注册驱动以及一条条建立通道的麻烦，最重要的是，可复用性和隐蔽性碾压了传统方法，所有的原始数据如username，password等都不会在代码中展现出来，全部都隐蔽在配置文件中。</p><p>ThreadLocal&lt;&gt;的优越性体现在与连接池的高度契合上，它使得一次作业绑定唯一一个Connection，否则一次作业中可以通过<code>ds.getConnection()</code>一直获取Connection，这显得十分无意义且浪费连接池资源。</p><h1 id="QueryRunner-ResultSetHandler"><a href="#QueryRunner-ResultSetHandler" class="headerlink" title="QueryRunner+ResultSetHandler"></a>QueryRunner+ResultSetHandler</h1><p>使用前需添加jar包：<a href="/download/QueryRunner-Handler.rar">commons-dbutils.jar+mysql-connector-java.jar</a></p><p> QreryRunner类(org.apache.commons.dbutils.QueryRunner) 是Dbutils的核心类之一，它显著的简化了SQL查询，并与ResultSetHandler协同工作将使编码量大为减少。它包含以下几个方法：</p><ol><li><pre><code>  **query(Connection conn, String sql, ResultSetHandler rsh,Object[] params)**：执行选择查询，在查询中，对象阵列的值被用来作为查询的置换参数。</code></pre></li><li><pre><code>  **update(Connection conn, String sql, Object[] params)**：被用来执行插入、更新或删除（DML）操作。</code></pre></li></ol><p>其中ResultSetHandler接口(org.apache.commons.dbutils.ResultSethandler)执行处理一个结果集对象，将数据转变并处理为任何一种形式，供其他应用使用。实现类如下：</p><ul><li><strong>ArrayHandler</strong>：把结果集中的第一行数据转成对象数组。</li><li><strong>ArrayListHandler</strong>：把结果集中的每一行数据都转成一个对象数组，再存放到List中。</li><li><strong>BeanHandler</strong>：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li><strong>BeanListHandler</strong>：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。//重点</li><li><strong>MapHandler</strong>：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。//重点</li><li><strong>MapListHandler</strong>：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Admin admin = queryRunner.query(DbUtils.getConection(),<span class="string">&quot;select * FROM admin WHERE username=?;&quot;</span>,<span class="keyword">new</span> BeanHandler&lt;Admin&gt;(Admin.class),<span class="string">&quot;theo&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>Connection conn</code>：线程绑定的通道，用来传输SQL语句，返回结果</p><p><code>String sql</code>：如果是查询语句就使用<code>.query()</code>，如果是DML语句就使用<code>.update()</code>。</p><p><code>ReslutSetHandler rsh</code>：因为JDBC中查询语句需要返回<code>ResultSet</code>，而<code>ResultSet</code>本质上是表格。虽然我们可以人为遍历表格然后一个个装入Admin生成一个对象实例，<code>ReslutSetHandler rsh</code>代替我们做了这件事。</p><p><code>Object[] params</code>：可变数组 ，预加载的SQL语句中有多少<code>?</code>这里就对应了多少参数。相当于<code>preparedStatement.setString(1,username);</code>。</p><p><strong>总之，QueryRunner技术代替了准备小车和执行语句[ps.executeUpdate()、ps.executeQuery()]的作用，进一步的，搭配ResultSetHandler还可以将返回结果进行处理，用过都说好！</strong></p></blockquote><ul><li><strong>QueryRunner.query()</strong></li></ul><p>这条语句牵涉到了数据库，Admin类。如果要用到BeanHandler就必须要考虑数据库key值与Admin类属性的匹配。比如说数据库中表头有<code>username VARCHAR(20)</code>，Admin类的属性就得是<code>String username;</code>而不是<code>String UserName;</code>。如果返回的ResultSet是多行多列，也就是有多个实体信息，就需要用到BeanListHandler了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库连接池&quot;&gt;&lt;a href=&quot;#数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;数据库连接池&quot;&gt;&lt;/a&gt;数据库连接池&lt;/h1&gt;&lt;p&gt;一般情况下我们链接数据库是需要则创建，利用完则销毁，也要遵循JDBC的四步骤：注册驱动，建立通道，配置小车，</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://example.com/2021/03/05/JDBC/"/>
    <id>http://example.com/2021/03/05/JDBC/</id>
    <published>2021-03-05T11:13:00.000Z</published>
    <updated>2021-03-13T09:28:13.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC概念先导"><a href="#JDBC概念先导" class="headerlink" title="JDBC概念先导"></a>JDBC概念先导</h1><p>JDBC（<strong>J</strong>ava <strong>D</strong>ata<strong>B</strong>ase <strong>C</strong>onnectivity）即Java语言连接数据库，本质上是一套位于<code>java.sql.*</code>下的接口。因为每种数据库的底层实现原理都不一致，如Oracle、MySQL，为了统一能够被Java调用，SUN制定了<code>JDBC</code>这套接口，其他数据库厂家就需要实现接口的实现类。</p><h2 id="JDBC实现的过程"><a href="#JDBC实现的过程" class="headerlink" title="JDBC实现的过程"></a>JDBC实现的过程</h2><ol><li><strong>Driver注册</strong></li></ol><p>在JAVA工程中注册好Driver，即为MySQL服务器打开通道口</p><ol start="2"><li><strong>建立通道</strong></li></ol><p>通过JDBC【java.sql.DriverManager】在JAVA工程与MySQL服务器之间建立通道，以便于JAVA工程能向MySQL发送命令，MySQL能向JAVA工程返回结果。</p><ol start="3"><li><strong>实现交通工具</strong></li></ol><p>Connection接口实现类【PreparedStatement接口实现类】能作为JAVA工程和MySQL之间通信的工具。</p><ol start="4"><li><strong>执行并返回结果</strong></li></ol><p>Connection接口实现类到达MySQL，MySQL收到SQL命令后执行，将操作结果放回Connection接口实现类中。</p><ol start="5"><li><strong>释放资源</strong></li></ol><p>在工作完成后，需要对所有对象进行销毁，主要包括以下实现类：<code>Connection【管理连接通道】</code>，<code>PreparedStatement【管理交通工具】</code>，<code>ResultSet【查询命令返回的临时表】</code></p><h2 id="JDBC你需要知道的类"><a href="#JDBC你需要知道的类" class="headerlink" title="JDBC你需要知道的类"></a>JDBC你需要知道的类</h2><ul><li><strong>java.sql.DriverManager</strong></li></ul><p>这个类存放在JDK1.8下，负责将数据库厂商提供的Driver接口进行注册，以便建立通道。</p><ul><li><strong>java.sql.Connection</strong></li></ul><p>负责管理Java工程与数据库服务器之间的连接通道</p><ul><li><strong>java.sql.PreparedStatement</strong></li></ul><p>负责管理在连接通道上进行往返的交通工具</p><ul><li><strong>java.sql.ResultSet</strong></li></ul><p>负责管理数据库服务器返回的临时表，即返回给JAVA工程的处理结果。</p><h1 id="JDBC开发"><a href="#JDBC开发" class="headerlink" title="JDBC开发"></a>JDBC开发</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.theo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCtest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立通道</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/companydb&quot;</span>;</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;tzq1635886602&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立交通工具</span></span><br><span class="line">        PreparedStatement ps = connection.prepareStatement(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理命令放回结果</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        result = ps.executeUpdate(<span class="string">&quot;INSERT INTO admin() VALUES(&#x27;theo2&#x27;,&#x27;123456&#x27;,&#x27;15879313152&#x27;,&#x27;theo_tzq@qq.com&#x27;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>注册驱动</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line">DriverManager.registerDriver(driver);</span><br></pre></td></tr></table></figure><p>注册好JAVA工程对MySQL的通道口，接下来创建通道。</p><blockquote><p>注册驱动还可以通过类加载动作来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Driver</code>类中有一个静态代码块，类加载时就能实现注册驱动。我们使用<code>Class.forname(类名)</code>就能启动该类的静态代码块。由于类名是一个字符串，我们很好的可以将这些写在配置文件中。</p></blockquote><ul><li><strong>创建通道</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/companydb&quot;</span>;</span><br><span class="line">Connection connection = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;tzq1635886602&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>jdbc:mysql://localhost:3306</code>接通到MySQL服务器下，通过<code>localhost:3306</code>连接到你本地数据库，<code>companydb</code>就是你想操作的数据表了,这里算便也用了学习MySQL时创建的表。<code>DriverManager.getConnection(url,username,password)</code>则是需要登入你的MySQL账号才能建立成功通道。</p><ul><li><strong>创建交通工具</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = connection.prepareStatement(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>connection.prepareStatement(&quot;&quot;)</code>创建交通工具，这里sql先不写。</p><ul><li><strong>输送命令</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ps.executeUpdate(<span class="string">&quot;INSERT INTO admin() VALUES(&#x27;theo&#x27;,&#x27;123456&#x27;,&#x27;15879313152&#x27;,&#x27;theo_tzq@qq.com&#x27;);&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>ps.executeUpdate(sql)</code>利用交通工具的命令输送SQL语句。返回值时SQL语句成功影响的行数。</p><ul><li><strong>销毁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;ps.close();&#125;</span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;connection.close(); &#125;</span><br></pre></td></tr></table></figure><p>每个使用到的实现类都要经过<code>close()</code>销毁</p><blockquote><p>以上就实现了一个简单的JAVA工程链接MySQL的任务，执行JAVA后打开admin会发现新增了theo数据。</p><p>如果需要连接到Oracle数据库，就只需要改变通道url和注册方式（导入Oracle的专有jar包）。实现起来十分方便。</p></blockquote><h2 id="使用properties文件获取连接数据"><a href="#使用properties文件获取连接数据" class="headerlink" title="使用properties文件获取连接数据"></a>使用properties文件获取连接数据</h2><p>使用配置文件<code>.properties</code>来注册驱动和建立通道。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#JDBC.properties</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/companydb</span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.sql.jdbc.Driver</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">tzq1635886602</span></span><br></pre></td></tr></table></figure><p>再使用资源版定器绑定属性配置文件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle(<span class="string">&quot;JDBC&quot;</span>);<span class="comment">//不用加后缀名，会自动去Java工程的目录找该配置文件、</span></span><br><span class="line">String driver = bundle.getString(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">String url = bundle.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String username = bundle.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password = bundle.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">Class.forName(driver);</span><br><span class="line"><span class="comment">//创建通道</span></span><br><span class="line">Connection connection = DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure><p>也可以通过I/O流与配置文件，这样可以省去多次使用<code>bundle.getString()</code>来获取特定数据。这个坑有待补充。</p><h2 id="ps-executeUpdate与ps-execteQuery"><a href="#ps-executeUpdate与ps-execteQuery" class="headerlink" title="ps.executeUpdate与ps.execteQuery"></a>ps.executeUpdate与ps.execteQuery</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>int ps.executeUpdate(SQL语句)</td><td>负责推送的语句有如INSERT,UPDATE,DElETE等会返回影响了多少行数的命令</td></tr><tr><td>ResultSet ps.executeQuery(SQL语句)</td><td>负责推送查询语句SELECT.放回的是临时表,在销毁阶段也要注意将ResultSet销毁了.</td></tr></tbody></table><p>这里查看如何<a href="https://www.bilibili.com/video/BV1Yz411B7Pk?p=73">提取ResultSet返回的对象信息</a></p><h2 id="ps-Batch-与预编译"><a href="#ps-Batch-与预编译" class="headerlink" title="ps.Batch()与预编译"></a><a href="https://www.bilibili.com/video/BV1Yz411B7Pk?p=74">ps.Batch()与预编译</a></h2><p>之前我们造车没有填入参数，<code>PreparedStatement ps = connection.prepareStatement(&quot;&quot;);</code>，通过添加SQL语句可以为该车指定模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String SQL = <span class="string">&quot;INSERT INTO admin() VALUES(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = connection.prepareStatement(SQL);<span class="comment">//定制好该车承载SQL语句的模板,批处理添加SQL语句时只需要填好?空位即可。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    ps.setString(<span class="number">1</span>,<span class="string">&quot;TZQ&quot;</span>+i+<span class="string">&quot;号&quot;</span>);<span class="comment">//ps.setString(n,m) n是指第几个问号,m是填充的内容</span></span><br><span class="line">    ps.setString(<span class="number">2</span>,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    ps.setString(<span class="number">3</span>,<span class="string">&quot;12345678910&quot;</span>);</span><br><span class="line">    ps.setString(<span class="number">4</span>,<span class="string">&quot;qq@com&quot;</span>);</span><br><span class="line">    ps.addBatch();<span class="comment">//每循环一次一条完整的SQL语句就会压到ps中,循环结束ps身上就会带上一百组SQL命令.</span></span><br><span class="line">&#125;</span><br><span class="line">ps.executeBatch();<span class="comment">//代替executeUpdate或execteQuery,将装好命令的车送到SQL服务器中.</span></span><br></pre></td></tr></table></figure><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a><a href="https://www.bilibili.com/video/BV1Bt41137iB?p=25&spm_id_from=pageDriver">事务控制</a></h2><p>我们之前说过,JDBC获得的结果都是临时表，真实的数据没有被改变。当如果我们想要改变数据库，我们需要用到<code>connection.commit</code>等函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">ps.executeUpdate(SQL);<span class="comment">//推送SQL命令</span></span><br><span class="line">connection.commit();<span class="comment">//确认将该影响应用到真实数据库中</span></span><br><span class="line">connection.rollback();<span class="comment">//确认不将命令的影响应用到真实数据库,还原备份数据库</span></span><br></pre></td></tr></table></figure><p>当<code>connection.setAutoCommit()</code>未被设置时，默认为true。这样的话每执行一次execute，数据库的数据就会更新并保存。倘若代码中有两次execute，第二次execute出现了错误，我想要将数据库还原到两次execute前的数据。由于第一次execute正常执行，数据库最新的备份时第一次execute后的，那么我想回溯到最初的数据库就晚了。</p><p>因此，设置<code>connection.setAutoCommit(false)</code>，可以保证整个代码正常运行后再人为地覆盖掉最初数据。代码中出错了就能通过<code>connection.rollback</code>回溯到最开始版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC概念先导&quot;&gt;&lt;a href=&quot;#JDBC概念先导&quot; class=&quot;headerlink&quot; title=&quot;JDBC概念先导&quot;&gt;&lt;/a&gt;JDBC概念先导&lt;/h1&gt;&lt;p&gt;JDBC（&lt;strong&gt;J&lt;/strong&gt;ava &lt;strong&gt;D&lt;/strong&gt;a</summary>
      
    
    
    
    
    <category term="Java!" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux+CentOS7</title>
    <link href="http://example.com/2021/03/03/Linux-CentOS7/"/>
    <id>http://example.com/2021/03/03/Linux-CentOS7/</id>
    <published>2021-03-03T11:00:24.000Z</published>
    <updated>2021-03-03T13:50:40.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux文件操作"><a href="#Linux文件操作" class="headerlink" title="Linux文件操作"></a>Linux文件操作</h1><ul><li><strong>目录操作</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">pwd</span> <span class="comment">#查看当前目录路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls-l<span class="comment">#查看当前目录下的文件和目录的详细信息,去除-l则只查看文件名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> <span class="comment">#回到用户主目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ./example<span class="comment">#进入当前目录的example目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ../example<span class="comment">#进入上级目录的example目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ~/example<span class="comment">#进入主目录的example目录</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">mkdir -p example/example2/example3<span class="comment">#创建出路径上的所有目录,不带-p参数则在当前目录创建</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">rm -rf example<span class="comment">#强制删除该目录所有内容</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">rm -rf /*<span class="comment">#跑路</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cp -rf example example2<span class="comment">#将example目录复制到example2下，如若example2不存在则新建example2，内容与example相同。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">mv example example2<span class="comment">#将目重命名为example2</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>文件操作</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar -cvf example.tar example1,example2,example3<span class="comment">#将三个目录归档到example.tar</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -xcf example.tar -C outdir<span class="comment">#将example.tar解压到outdir下</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -czvf example.tar.gz example1,example2,example3<span class="comment">#将三个目录归档并压缩到example.tar.gz</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -xzcf example.tar.gz -C outdir<span class="comment">#将example.tar.gz解压到outdir下</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>软链接</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ln -s example example2<span class="comment">#创建example的快捷方式,命名为example2</span></span></span><br></pre></td></tr></table></figure><h1 id="Linux用户操作"><a href="#Linux用户操作" class="headerlink" title="Linux用户操作"></a>Linux用户操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">su<span class="comment">#进入当前用户的root模式</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">useradd theo2<span class="comment">#创建theo2用户,可以在~/home/ 下查看到用户目录的变化</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">userdel theo2<span class="comment">#删除theo2用户</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">passwd theo2<span class="comment">#添加或修改用户目录。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">groupadd group<span class="comment">#创建组</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">useradd -g group example<span class="comment">#将用户创建到组中</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">usermod -g group example<span class="comment">#将现存用户移到组中</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">cat /etc/group<span class="comment">#显示所有组的信息:名称+ID</span></span></span><br></pre></td></tr></table></figure><h1 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h1><ul><li><strong>查看权限</strong></li></ul><p><code>ls -l</code>可以查看文件的权限。如下</p><p><code>drwxrwxr-x. 3 theo theo 17 3月   3 18:52 file -rw-rw-r--. 1 theo theo 11 3月   3 20:18 text.txt</code></p><blockquote><p><code>d</code>：文件夹</p><p><code>r</code>：可读；<code>w</code>：可写；<code>x</code>：可执行；<code>-</code>：没有相应性质</p><p>分区概念：<code>-|---|---|---</code>对应着不同区所拥有的不同权限，<code>-|自己|同组|陌生人</code>。权限也可在<code>文件&gt;属性&gt;权限</code>查看</p></blockquote><ul><li><strong>修改权限</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">chmod o+w text.txt<span class="comment">#作用对象 +/- 权限</span></span></span><br></pre></td></tr></table></figure><p><code>o</code>：其他人；<code>u</code>：用户本人；<code>a</code>：所有用户。<code>w/r/x</code>对应不同权限。</p><p>如果省去<code>o/u/a</code>，默认作用对象为本用户和本组。</p><h1 id="Linux脚本"><a href="#Linux脚本" class="headerlink" title="Linux脚本"></a>Linux脚本</h1><ul><li><strong>环境变量</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> JAVA_HOME=/opt/jdk1.8<span class="comment">#设置环境变量,当时该设置的环境变量只在该终端上有效。退出终端将消失</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">printenv<span class="comment">#查看所有环境变量</span></span></span><br></pre></td></tr></table></figure><p><strong>用户环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gedit ~/.bash_profile<span class="comment">#文本编辑器打开环境变量设置,在末行添加export JAVA_HOME=/opt/jdk1.8，只对本用户有效。</span></span></span><br></pre></td></tr></table></figure><p><strong>系统环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gedit etc/profile.d/group.sh<span class="comment">#先在profile.d下编写脚本group.sh,实现export ...,这种方法对所有用户有效</span></span></span><br></pre></td></tr></table></figure><p><strong>PATH环境变量（root权限）</strong></p><p>执行脚本时一般使用<code>./example.sh</code>，使用<code>example.sh</code>却提示找不到命令。这是因为后者将会去PATH寻找该脚本，找不到就无法执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gedit etc/profile.d/group.sh</span></span><br></pre></td></tr></table></figure><p>先在profile.d下编写脚本group.sh。实现<code>export PATH=$PATH:/home/theo</code>，这样就会添加一条脚本搜索路径<code>/home/theo/example.sh</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux文件操作&quot;&gt;&lt;a href=&quot;#Linux文件操作&quot; class=&quot;headerlink&quot; title=&quot;Linux文件操作&quot;&gt;&lt;/a&gt;Linux文件操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目录操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;fi</summary>
      
    
    
    
    
  </entry>
  
</feed>
